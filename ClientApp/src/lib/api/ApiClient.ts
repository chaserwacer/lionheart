//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AddActivityEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    post(body: CreateActivityRequest | undefined): Promise<ActivityDTO> {
        let url_ = this.baseUrl + "/api/activity/add-activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<ActivityDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ActivityDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ActivityDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ActivityDTO>(null as any);
    }
}

export class AddWellnessStateEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    post(body: CreateWellnessStateRequest | undefined): Promise<Activity> {
        let url_ = this.baseUrl + "/api/wellness/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Activity.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = Activity.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }
}

export class CreateChatConversationEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    post(body: CreateChatConversationRequest | undefined): Promise<LHChatConversationDTO> {
        let url_ = this.baseUrl + "/api/chat/conversation/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<LHChatConversationDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = LHChatConversationDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LHChatConversationDTO>(null as any);
    }
}

export class CreateDTSetEntryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    post(body: CreateDTSetEntryRequest | undefined): Promise<DTSetEntryDTO> {
        let url_ = this.baseUrl + "/api/dt-set-entry/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<DTSetEntryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DTSetEntryDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DTSetEntryDTO>(null as any);
    }
}

export class CreateEquipmentEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    post(body: CreateEquipmentRequest | undefined): Promise<EquipmentDTO> {
        let url_ = this.baseUrl + "/api/equipment/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<EquipmentDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EquipmentDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EquipmentDTO>(null as any);
    }
}

export class CreateInjuryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    post(body: CreateInjuryRequest | undefined): Promise<InjuryDTO> {
        let url_ = this.baseUrl + "/api/injury/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<InjuryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = InjuryDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InjuryDTO>(null as any);
    }
}

export class CreateInjuryEventEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    post(body: CreateInjuryEventRequest | undefined): Promise<InjuryDTO> {
        let url_ = this.baseUrl + "/api/injury/add-event";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<InjuryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InjuryDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InjuryDTO>(null as any);
    }
}

export class CreateLiftSetEntryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    post(body: CreateLiftSetEntryRequest | undefined): Promise<LiftSetEntryDTO> {
        let url_ = this.baseUrl + "/api/lift-set-entry/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<LiftSetEntryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = LiftSetEntryDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LiftSetEntryDTO>(null as any);
    }
}

export class CreateMovementBaseEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    post(body: CreateMovementBaseRequest | undefined): Promise<MovementBaseDTO> {
        let url_ = this.baseUrl + "/api/movement-base/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<MovementBaseDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MovementBaseDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementBaseDTO>(null as any);
    }
}

export class CreateMovementDataEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    post(body: CreateMovementDataRequest | undefined): Promise<MovementDataDTO> {
        let url_ = this.baseUrl + "/api/movement-data/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<MovementDataDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MovementDataDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementDataDTO>(null as any);
    }
}

export class CreateMovementEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    post(body: CreateMovementRequest | undefined): Promise<MovementDTO> {
        let url_ = this.baseUrl + "/api/movement/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<MovementDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MovementDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementDTO>(null as any);
    }
}

export class CreateProfileEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    post(body: CreateProfileRequest | undefined): Promise<LionheartUser> {
        let url_ = this.baseUrl + "/api/user/create-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<LionheartUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = LionheartUser.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LionheartUser>(null as any);
    }
}

export class CreateTrainingProgramEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    post(body: CreateTrainingProgramRequest | undefined): Promise<TrainingProgramDTO> {
        let url_ = this.baseUrl + "/api/training-program/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<TrainingProgramDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingProgramDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingProgramDTO>(null as any);
    }
}

export class CreateTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    post(body: CreateTrainingSessionRequest | undefined): Promise<TrainingSessionDTO> {
        let url_ = this.baseUrl + "/api/training-session/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<TrainingSessionDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingSessionDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO>(null as any);
    }
}

export class DeleteActivityEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: string | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/activity/delete-activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class DeleteChatConversationEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete(conversationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/chat/conversation/{conversationId}";
        if (conversationId === undefined || conversationId === null)
            throw new Error("The parameter 'conversationId' must be defined.");
        url_ = url_.replace("{conversationId}", encodeURIComponent("" + conversationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class GetChatConversationEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(conversationId: string): Promise<LHChatConversationDTO> {
        let url_ = this.baseUrl + "/api/chat/conversation/{conversationId}";
        if (conversationId === undefined || conversationId === null)
            throw new Error("The parameter 'conversationId' must be defined.");
        url_ = url_.replace("{conversationId}", encodeURIComponent("" + conversationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<LHChatConversationDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LHChatConversationDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LHChatConversationDTO>(null as any);
    }
}

export class DeleteDTSetEntryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete(setEntryId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/dt-set-entry/delete/{setEntryId}";
        if (setEntryId === undefined || setEntryId === null)
            throw new Error("The parameter 'setEntryId' must be defined.");
        url_ = url_.replace("{setEntryId}", encodeURIComponent("" + setEntryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteEquipmentEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete(equipmentId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/equipment/delete/{equipmentId}";
        if (equipmentId === undefined || equipmentId === null)
            throw new Error("The parameter 'equipmentId' must be defined.");
        url_ = url_.replace("{equipmentId}", encodeURIComponent("" + equipmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteInjuryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete(injuryId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/injury/delete/{injuryId}";
        if (injuryId === undefined || injuryId === null)
            throw new Error("The parameter 'injuryId' must be defined.");
        url_ = url_.replace("{injuryId}", encodeURIComponent("" + injuryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteInjuryEventEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete(injuryEventId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/injury/event/{injuryEventId}";
        if (injuryEventId === undefined || injuryEventId === null)
            throw new Error("The parameter 'injuryEventId' must be defined.");
        url_ = url_.replace("{injuryEventId}", encodeURIComponent("" + injuryEventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteLiftSetEntryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete(setEntryId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/lift-set-entry/delete/{setEntryId}";
        if (setEntryId === undefined || setEntryId === null)
            throw new Error("The parameter 'setEntryId' must be defined.");
        url_ = url_.replace("{setEntryId}", encodeURIComponent("" + setEntryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteMovementBaseEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete(movementBaseId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/movement-base/delete/{movementBaseId}";
        if (movementBaseId === undefined || movementBaseId === null)
            throw new Error("The parameter 'movementBaseId' must be defined.");
        url_ = url_.replace("{movementBaseId}", encodeURIComponent("" + movementBaseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteMovementEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete(movementId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/movement/delete/{movementId}";
        if (movementId === undefined || movementId === null)
            throw new Error("The parameter 'movementId' must be defined.");
        url_ = url_.replace("{movementId}", encodeURIComponent("" + movementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteTrainingProgramEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete(programId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/training-program/delete/{programId}";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete(trainingSessionId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/training-session/delete/{trainingSessionId}";
        if (trainingSessionId === undefined || trainingSessionId === null)
            throw new Error("The parameter 'trainingSessionId' must be defined.");
        url_ = url_.replace("{trainingSessionId}", encodeURIComponent("" + trainingSessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DuplicateTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    post(trainingSessionId: string): Promise<TrainingSessionDTO> {
        let url_ = this.baseUrl + "/api/training-session/duplicate/{trainingSessionId}";
        if (trainingSessionId === undefined || trainingSessionId === null)
            throw new Error("The parameter 'trainingSessionId' must be defined.");
        url_ = url_.replace("{trainingSessionId}", encodeURIComponent("" + trainingSessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<TrainingSessionDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSessionDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO>(null as any);
    }
}

export class GetActivitiesEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(startDate: Date, endDate: Date): Promise<ActivityDTO[]> {
        let url_ = this.baseUrl + "/api/activity/get-user-activities?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ActivityDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActivityDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ActivityDTO[]>(null as any);
    }
}

export class GetActivityEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(activityId: string): Promise<ActivityDTO> {
        let url_ = this.baseUrl + "/api/activity/get-activity/{activityId}";
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ActivityDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ActivityDTO>(null as any);
    }
}

export class GetAllChatConversationsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(): Promise<LHChatConversationDTO[]> {
        let url_ = this.baseUrl + "/api/chat/conversations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<LHChatConversationDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LHChatConversationDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LHChatConversationDTO[]>(null as any);
    }
}

export class GetAllMuscleGroupsAsyncClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(): Promise<MuscleGroup[]> {
        let url_ = this.baseUrl + "/api/muscle-groups/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<MuscleGroup[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MuscleGroup.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MuscleGroup[]>(null as any);
    }
}

export class GetDailyOuraDataEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param request (optional) 
     * @return OK
     */
    get(request: Date | undefined): Promise<DailyOuraDataDTO> {
        let url_ = this.baseUrl + "/api/oura/get-daily-oura-data?";
        if (request === null)
            throw new Error("The parameter 'request' cannot be null.");
        else if (request !== undefined)
            url_ += "request=" + encodeURIComponent(request ? "" + request.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<DailyOuraDataDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DailyOuraDataDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyOuraDataDTO>(null as any);
    }
}

export class GetDailyOuraDataRangeEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    post(body: DateRangeRequest | undefined): Promise<DailyOuraDataDTO[]> {
        let url_ = this.baseUrl + "/api/oura/get-daily-oura-data-range";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<DailyOuraDataDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DailyOuraDataDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyOuraDataDTO[]>(null as any);
    }
}

export class GetEquipmentsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(): Promise<EquipmentDTO[]> {
        let url_ = this.baseUrl + "/api/equipment/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<EquipmentDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EquipmentDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EquipmentDTO[]>(null as any);
    }
}

export class GetInjuriesEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(): Promise<InjuryDTO[]> {
        let url_ = this.baseUrl + "/api/injury/get-user-injuries";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<InjuryDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InjuryDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InjuryDTO[]>(null as any);
    }
}

export class GetMostRecentChatConversationEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(): Promise<LHChatConversationDTO> {
        let url_ = this.baseUrl + "/api/chat/conversation/most-recent";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<LHChatConversationDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LHChatConversationDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("No Content", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LHChatConversationDTO>(null as any);
    }
}

export class GetMovementBasesEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(): Promise<MovementBaseDTO[]> {
        let url_ = this.baseUrl + "/api/movement-base/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<MovementBaseDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MovementBaseDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementBaseDTO[]>(null as any);
    }
}

export class GetMovementDataEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(movementDataId: string): Promise<MovementDataDTO> {
        let url_ = this.baseUrl + "/api/movement-data/{movementDataId}";
        if (movementDataId === undefined || movementDataId === null)
            throw new Error("The parameter 'movementDataId' must be defined.");
        url_ = url_.replace("{movementDataId}", encodeURIComponent("" + movementDataId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<MovementDataDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MovementDataDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementDataDTO>(null as any);
    }
}

export class GetMovementDatasEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(): Promise<MovementDataDTO[]> {
        let url_ = this.baseUrl + "/api/movement-datas";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<MovementDataDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MovementDataDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementDataDTO[]>(null as any);
    }
}

export class GetMovementsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(sessionID: string): Promise<MovementDTO[]> {
        let url_ = this.baseUrl + "/api/movement/get-all/{sessionId}";
        if (sessionID === undefined || sessionID === null)
            throw new Error("The parameter 'sessionID' must be defined.");
        url_ = url_.replace("{sessionID}", encodeURIComponent("" + sessionID));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<MovementDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MovementDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementDTO[]>(null as any);
    }
}

export class GetPersonalRecordsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(): Promise<PersonalRecordDTO[]> {
        let url_ = this.baseUrl + "/api/personal-records";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<PersonalRecordDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PersonalRecordDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersonalRecordDTO[]>(null as any);
    }
}

export class GetPRHistoryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param pRType (optional) 
     * @return OK
     */
    get(movementDataId: string, pRType: PersonalRecordType | undefined): Promise<PersonalRecordDTO[]> {
        let url_ = this.baseUrl + "/api/personal-records/history/{movementDataId}?";
        if (movementDataId === undefined || movementDataId === null)
            throw new Error("The parameter 'movementDataId' must be defined.");
        url_ = url_.replace("{MovementDataId}", encodeURIComponent("" + movementDataId));
        if (pRType === null)
            throw new Error("The parameter 'pRType' cannot be null.");
        else if (pRType !== undefined)
            url_ += "PRType=" + encodeURIComponent("" + pRType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<PersonalRecordDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PersonalRecordDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersonalRecordDTO[]>(null as any);
    }
}

export class GetPRSummariesEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(): Promise<MovementDataPRSummary[]> {
        let url_ = this.baseUrl + "/api/personal-records/summaries";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<MovementDataPRSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MovementDataPRSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementDataPRSummary[]>(null as any);
    }
}

export class GetPRSummaryForMovementDataEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(movementDataId: string): Promise<MovementDataPRSummary> {
        let url_ = this.baseUrl + "/api/personal-records/summary/{movementDataId}";
        if (movementDataId === undefined || movementDataId === null)
            throw new Error("The parameter 'movementDataId' must be defined.");
        url_ = url_.replace("{movementDataId}", encodeURIComponent("" + movementDataId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<MovementDataPRSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MovementDataPRSummary.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementDataPRSummary>(null as any);
    }
}

export class GetTrainingProgramEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(programId: string): Promise<TrainingProgramDTO> {
        let url_ = this.baseUrl + "/api/training-program/get/{programId}";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TrainingProgramDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingProgramDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingProgramDTO>(null as any);
    }
}

export class GetTrainingProgramsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(): Promise<TrainingProgramDTO[]> {
        let url_ = this.baseUrl + "/api/training-program/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TrainingProgramDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingProgramDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingProgramDTO[]>(null as any);
    }
}

export class GetTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(sessionId: string, programId: string): Promise<TrainingSessionDTO> {
        let url_ = this.baseUrl + "/api/training-session/get/{programId}/{sessionId}";
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TrainingSessionDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSessionDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO>(null as any);
    }
}

export class GetTrainingSessionsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(trainingProgramId: string): Promise<TrainingSessionDTO[]> {
        let url_ = this.baseUrl + "/api/training-session/get-all/{trainingProgramId}";
        if (trainingProgramId === undefined || trainingProgramId === null)
            throw new Error("The parameter 'trainingProgramId' must be defined.");
        url_ = url_.replace("{trainingProgramId}", encodeURIComponent("" + trainingProgramId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TrainingSessionDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingSessionDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO[]>(null as any);
    }
}

export class GetWellnessStateEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param date (optional) 
     * @return OK
     */
    get(date: Date | undefined): Promise<WellnessState> {
        let url_ = this.baseUrl + "/api/wellness/get?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<WellnessState> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WellnessState.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WellnessState.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WellnessState>(null as any);
    }
}

export class GetWellnessStatesEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(startDate: Date, endDate: Date): Promise<WellnessState[]> {
        let url_ = this.baseUrl + "/api/wellness/get-range?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<WellnessState[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WellnessState.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData401)) {
                result401 = [] as any;
                for (let item of resultData401)
                    result401!.push(WellnessState.fromJS(item));
            }
            else {
                result401 = <any>null;
            }
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WellnessState[]>(null as any);
    }
}

export class HasCreatedProfileEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(): Promise<BootUserDTO> {
        let url_ = this.baseUrl + "/api/user/has-created-profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<BootUserDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BootUserDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BootUserDTO>(null as any);
    }
}

export class LionheartClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    register(body: RegisterRequest): Promise<void> {
        let url_ = this.baseUrl + "/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param useCookies (optional) 
     * @param useSessionCookies (optional) 
     * @return OK
     */
    login(useCookies: boolean | undefined, useSessionCookies: boolean | undefined, body: LoginRequest): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/login?";
        if (useCookies === null)
            throw new Error("The parameter 'useCookies' cannot be null.");
        else if (useCookies !== undefined)
            url_ += "useCookies=" + encodeURIComponent("" + useCookies) + "&";
        if (useSessionCookies === null)
            throw new Error("The parameter 'useSessionCookies' cannot be null.");
        else if (useSessionCookies !== undefined)
            url_ += "useSessionCookies=" + encodeURIComponent("" + useSessionCookies) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<AccessTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    /**
     * @return OK
     */
    refresh(body: RefreshRequest): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: Response): Promise<AccessTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    /**
     * @param changedEmail (optional) 
     * @return OK
     */
    mapIdentityApi_confirmEmail(userId: string, code: string, changedEmail: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/confirmEmail?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined and cannot be null.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (changedEmail === null)
            throw new Error("The parameter 'changedEmail' cannot be null.");
        else if (changedEmail !== undefined)
            url_ += "changedEmail=" + encodeURIComponent("" + changedEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMapIdentityApi_confirmEmail(_response);
        });
    }

    protected processMapIdentityApi_confirmEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    resendConfirmationEmail(body: ResendConfirmationEmailRequest): Promise<void> {
        let url_ = this.baseUrl + "/resendConfirmationEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResendConfirmationEmail(_response);
        });
    }

    protected processResendConfirmationEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    forgotPassword(body: ForgotPasswordRequest): Promise<void> {
        let url_ = this.baseUrl + "/forgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    resetPassword(body: ResetPasswordRequest): Promise<void> {
        let url_ = this.baseUrl + "/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    _2fa(body: TwoFactorRequest): Promise<TwoFactorResponse> {
        let url_ = this.baseUrl + "/manage/2fa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process_2fa(_response);
        });
    }

    protected process_2fa(response: Response): Promise<TwoFactorResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwoFactorResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TwoFactorResponse>(null as any);
    }

    /**
     * @return OK
     */
    infoGET(): Promise<InfoResponse> {
        let url_ = this.baseUrl + "/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInfoGET(_response);
        });
    }

    protected processInfoGET(response: Response): Promise<InfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InfoResponse>(null as any);
    }

    /**
     * @return OK
     */
    infoPOST(body: InfoRequest): Promise<InfoResponse> {
        let url_ = this.baseUrl + "/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInfoPOST(_response);
        });
    }

    protected processInfoPOST(response: Response): Promise<InfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InfoResponse>(null as any);
    }
}

export class LogoutUserEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param request (optional) 
     * @return No Content
     */
    post(request: any | undefined): Promise<BootUserDTO> {
        let url_ = this.baseUrl + "/api/user/logout?";
        if (request === null)
            throw new Error("The parameter 'request' cannot be null.");
        else if (request !== undefined)
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<BootUserDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = BootUserDTO.fromJS(resultData204);
            return result204;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BootUserDTO>(null as any);
    }
}

export class ProcessUserChatMessageEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    post(body: AddChatMessageRequest | undefined): Promise<LHChatMessageDTO> {
        let url_ = this.baseUrl + "/api/chat/message/process";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<LHChatMessageDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LHChatMessageDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LHChatMessageDTO>(null as any);
    }
}

export class RevertPREndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    post(personalRecordId: string): Promise<PersonalRecordDTO> {
        let url_ = this.baseUrl + "/api/personal-records/revert/{personalRecordId}";
        if (personalRecordId === undefined || personalRecordId === null)
            throw new Error("The parameter 'personalRecordId' must be defined.");
        url_ = url_.replace("{personalRecordId}", encodeURIComponent("" + personalRecordId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<PersonalRecordDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonalRecordDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("No Content", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersonalRecordDTO>(null as any);
    }
}

export class SetPersonalApiAccessTokenEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    post(body: CreatePersonalApiAccessTokenRequest | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/user/set-personal-api-access-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return result201;
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class SyncOuraApiEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    post(body: DateRangeRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/oura/sync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UpdateActivityEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    put(body: UpdateActivityRequest | undefined): Promise<ActivityDTO> {
        let url_ = this.baseUrl + "/api/activity/update-activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<ActivityDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ActivityDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ActivityDTO>(null as any);
    }
}

export class UpdateChatConversationEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    put(body: UpdateChatConversationRequest | undefined): Promise<LHChatConversationDTO> {
        let url_ = this.baseUrl + "/api/chat/conversation/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<LHChatConversationDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LHChatConversationDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LHChatConversationDTO>(null as any);
    }
}

export class UpdateDTSetEntryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    put(body: UpdateDTSetEntryRequest | undefined): Promise<DTSetEntryDTO> {
        let url_ = this.baseUrl + "/api/dt-set-entry/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<DTSetEntryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DTSetEntryDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DTSetEntryDTO>(null as any);
    }
}

export class UpdateEquipmentEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    post(body: UpdateEquipmentRequest | undefined): Promise<EquipmentDTO> {
        let url_ = this.baseUrl + "/api/equipment/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<EquipmentDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EquipmentDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EquipmentDTO>(null as any);
    }
}

export class UpdateInjuryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    put(body: UpdateInjuryRequest | undefined): Promise<InjuryDTO> {
        let url_ = this.baseUrl + "/api/injury/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<InjuryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InjuryDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InjuryDTO>(null as any);
    }
}

export class UpdateInjuryEventEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    put(body: UpdateInjuryEventRequest | undefined): Promise<InjuryDTO> {
        let url_ = this.baseUrl + "/api/injury/event";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<InjuryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InjuryDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InjuryDTO>(null as any);
    }
}

export class UpdateLiftSetEntryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    put(body: UpdateLiftSetEntryRequest | undefined): Promise<LiftSetEntryDTO> {
        let url_ = this.baseUrl + "/api/lift-set-entry/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<LiftSetEntryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LiftSetEntryDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LiftSetEntryDTO>(null as any);
    }
}

export class UpdateMovementBaseEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    post(body: UpdateMovementBaseRequest | undefined): Promise<MovementBaseDTO> {
        let url_ = this.baseUrl + "/api/movement-base/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<MovementBaseDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MovementBaseDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementBaseDTO>(null as any);
    }
}

export class UpdateMovementEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    put(body: UpdateMovementRequest | undefined): Promise<MovementDTO> {
        let url_ = this.baseUrl + "/api/movement/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<MovementDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MovementDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementDTO>(null as any);
    }
}

export class UpdateMovementOrderEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    put(body: UpdateMovementOrderRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/movement/update-order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UpdateTrainingProgramEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    put(body: UpdateTrainingProgramRequest | undefined): Promise<TrainingProgramDTO> {
        let url_ = this.baseUrl + "/api/training-program/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<TrainingProgramDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingProgramDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingProgramDTO>(null as any);
    }
}

export class UpdateTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    put(body: UpdateTrainingSessionRequest | undefined): Promise<TrainingSessionDTO> {
        let url_ = this.baseUrl + "/api/training-session/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<TrainingSessionDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSessionDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO>(null as any);
    }
}

export class AccessTokenResponse implements IAccessTokenResponse {
    readonly tokenType?: string | undefined;
    accessToken!: string | undefined;
    expiresIn!: number;
    refreshToken!: string | undefined;

    constructor(data?: IAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).tokenType = _data["tokenType"];
            this.accessToken = _data["accessToken"];
            this.expiresIn = _data["expiresIn"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenType"] = this.tokenType;
        data["accessToken"] = this.accessToken;
        data["expiresIn"] = this.expiresIn;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IAccessTokenResponse {
    tokenType?: string | undefined;
    accessToken: string | undefined;
    expiresIn: number;
    refreshToken: string | undefined;
}

export class Activity implements IActivity {
    activityID?: string;
    userID?: string;
    dateTime?: Date;
    timeInMinutes?: number;
    caloriesBurned?: number;
    name?: string | undefined;
    userSummary?: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;

    constructor(data?: IActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityID = _data["activityID"];
            this.userID = _data["userID"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.timeInMinutes = _data["timeInMinutes"];
            this.caloriesBurned = _data["caloriesBurned"];
            this.name = _data["name"];
            this.userSummary = _data["userSummary"];
            this.perceivedEffortRatings = _data["perceivedEffortRatings"] ? PerceivedEffortRatings.fromJS(_data["perceivedEffortRatings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Activity {
        data = typeof data === 'object' ? data : {};
        let result = new Activity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityID"] = this.activityID;
        data["userID"] = this.userID;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["timeInMinutes"] = this.timeInMinutes;
        data["caloriesBurned"] = this.caloriesBurned;
        data["name"] = this.name;
        data["userSummary"] = this.userSummary;
        data["perceivedEffortRatings"] = this.perceivedEffortRatings ? this.perceivedEffortRatings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IActivity {
    activityID?: string;
    userID?: string;
    dateTime?: Date;
    timeInMinutes?: number;
    caloriesBurned?: number;
    name?: string | undefined;
    userSummary?: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;
}

export class ActivityDTO implements IActivityDTO {
    activityID?: string;
    dateTime?: Date;
    timeInMinutes?: number;
    caloriesBurned?: number;
    name?: string | undefined;
    userSummary?: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;

    constructor(data?: IActivityDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityID = _data["activityID"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.timeInMinutes = _data["timeInMinutes"];
            this.caloriesBurned = _data["caloriesBurned"];
            this.name = _data["name"];
            this.userSummary = _data["userSummary"];
            this.perceivedEffortRatings = _data["perceivedEffortRatings"] ? PerceivedEffortRatings.fromJS(_data["perceivedEffortRatings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActivityDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityID"] = this.activityID;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["timeInMinutes"] = this.timeInMinutes;
        data["caloriesBurned"] = this.caloriesBurned;
        data["name"] = this.name;
        data["userSummary"] = this.userSummary;
        data["perceivedEffortRatings"] = this.perceivedEffortRatings ? this.perceivedEffortRatings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IActivityDTO {
    activityID?: string;
    dateTime?: Date;
    timeInMinutes?: number;
    caloriesBurned?: number;
    name?: string | undefined;
    userSummary?: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;
}

export class ActivityData implements IActivityData {
    activityScore?: number;
    steps?: number;
    activeCalories?: number;
    totalCalories?: number;
    targetCalories?: number;
    meetDailyTargets?: number;
    moveEveryHour?: number;
    recoveryTime?: number;
    stayActive?: number;
    trainingFrequency?: number;
    trainingVolume?: number;

    constructor(data?: IActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityScore = _data["activityScore"];
            this.steps = _data["steps"];
            this.activeCalories = _data["activeCalories"];
            this.totalCalories = _data["totalCalories"];
            this.targetCalories = _data["targetCalories"];
            this.meetDailyTargets = _data["meetDailyTargets"];
            this.moveEveryHour = _data["moveEveryHour"];
            this.recoveryTime = _data["recoveryTime"];
            this.stayActive = _data["stayActive"];
            this.trainingFrequency = _data["trainingFrequency"];
            this.trainingVolume = _data["trainingVolume"];
        }
    }

    static fromJS(data: any): ActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityScore"] = this.activityScore;
        data["steps"] = this.steps;
        data["activeCalories"] = this.activeCalories;
        data["totalCalories"] = this.totalCalories;
        data["targetCalories"] = this.targetCalories;
        data["meetDailyTargets"] = this.meetDailyTargets;
        data["moveEveryHour"] = this.moveEveryHour;
        data["recoveryTime"] = this.recoveryTime;
        data["stayActive"] = this.stayActive;
        data["trainingFrequency"] = this.trainingFrequency;
        data["trainingVolume"] = this.trainingVolume;
        return data;
    }
}

export interface IActivityData {
    activityScore?: number;
    steps?: number;
    activeCalories?: number;
    totalCalories?: number;
    targetCalories?: number;
    meetDailyTargets?: number;
    moveEveryHour?: number;
    recoveryTime?: number;
    stayActive?: number;
    trainingFrequency?: number;
    trainingVolume?: number;
}

export class AddChatMessageRequest implements IAddChatMessageRequest {
    chatConversationID!: string;
    content!: string | undefined;

    constructor(data?: IAddChatMessageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatConversationID = _data["chatConversationID"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): AddChatMessageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddChatMessageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatConversationID"] = this.chatConversationID;
        data["content"] = this.content;
        return data;
    }
}

export interface IAddChatMessageRequest {
    chatConversationID: string;
    content: string | undefined;
}

export class ApiAccessToken implements IApiAccessToken {
    objectID?: string;
    userID?: string;
    applicationName?: string | undefined;
    personalAccessToken?: string | undefined;

    constructor(data?: IApiAccessToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectID = _data["objectID"];
            this.userID = _data["userID"];
            this.applicationName = _data["applicationName"];
            this.personalAccessToken = _data["personalAccessToken"];
        }
    }

    static fromJS(data: any): ApiAccessToken {
        data = typeof data === 'object' ? data : {};
        let result = new ApiAccessToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectID"] = this.objectID;
        data["userID"] = this.userID;
        data["applicationName"] = this.applicationName;
        data["personalAccessToken"] = this.personalAccessToken;
        return data;
    }
}

export interface IApiAccessToken {
    objectID?: string;
    userID?: string;
    applicationName?: string | undefined;
    personalAccessToken?: string | undefined;
}

export class BootUserDTO implements IBootUserDTO {
    name?: string | undefined;
    hasCreatedProfile?: boolean;

    constructor(data?: IBootUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.hasCreatedProfile = _data["hasCreatedProfile"];
        }
    }

    static fromJS(data: any): BootUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BootUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["hasCreatedProfile"] = this.hasCreatedProfile;
        return data;
    }
}

export interface IBootUserDTO {
    name?: string | undefined;
    hasCreatedProfile?: boolean;
}

export class CreateActivityRequest implements ICreateActivityRequest {
    dateTime?: Date;
    timeInMinutes?: number;
    caloriesBurned?: number;
    name?: string | undefined;
    userSummary?: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;

    constructor(data?: ICreateActivityRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.timeInMinutes = _data["timeInMinutes"];
            this.caloriesBurned = _data["caloriesBurned"];
            this.name = _data["name"];
            this.userSummary = _data["userSummary"];
            this.perceivedEffortRatings = _data["perceivedEffortRatings"] ? PerceivedEffortRatings.fromJS(_data["perceivedEffortRatings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateActivityRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["timeInMinutes"] = this.timeInMinutes;
        data["caloriesBurned"] = this.caloriesBurned;
        data["name"] = this.name;
        data["userSummary"] = this.userSummary;
        data["perceivedEffortRatings"] = this.perceivedEffortRatings ? this.perceivedEffortRatings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateActivityRequest {
    dateTime?: Date;
    timeInMinutes?: number;
    caloriesBurned?: number;
    name?: string | undefined;
    userSummary?: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;
}

export class CreateChatConversationRequest implements ICreateChatConversationRequest {
    name!: string | undefined;

    constructor(data?: ICreateChatConversationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateChatConversationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChatConversationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateChatConversationRequest {
    name: string | undefined;
}

export class CreateDTSetEntryRequest implements ICreateDTSetEntryRequest {
    movementID?: string;
    recommendedDistance?: number;
    actualDistance?: number;
    intervalDuration?: string;
    targetPace?: string;
    actualPace?: string;
    recommendedDuration?: string;
    actualDuration?: string;
    recommendedRest?: string;
    actualRest?: string;
    intervalType?: IntervalType;
    distanceUnit?: DistanceUnit;
    actualRPE?: number;

    constructor(data?: ICreateDTSetEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementID = _data["movementID"];
            this.recommendedDistance = _data["recommendedDistance"];
            this.actualDistance = _data["actualDistance"];
            this.intervalDuration = _data["intervalDuration"];
            this.targetPace = _data["targetPace"];
            this.actualPace = _data["actualPace"];
            this.recommendedDuration = _data["recommendedDuration"];
            this.actualDuration = _data["actualDuration"];
            this.recommendedRest = _data["recommendedRest"];
            this.actualRest = _data["actualRest"];
            this.intervalType = _data["intervalType"];
            this.distanceUnit = _data["distanceUnit"];
            this.actualRPE = _data["actualRPE"];
        }
    }

    static fromJS(data: any): CreateDTSetEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDTSetEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementID"] = this.movementID;
        data["recommendedDistance"] = this.recommendedDistance;
        data["actualDistance"] = this.actualDistance;
        data["intervalDuration"] = this.intervalDuration;
        data["targetPace"] = this.targetPace;
        data["actualPace"] = this.actualPace;
        data["recommendedDuration"] = this.recommendedDuration;
        data["actualDuration"] = this.actualDuration;
        data["recommendedRest"] = this.recommendedRest;
        data["actualRest"] = this.actualRest;
        data["intervalType"] = this.intervalType;
        data["distanceUnit"] = this.distanceUnit;
        data["actualRPE"] = this.actualRPE;
        return data;
    }
}

export interface ICreateDTSetEntryRequest {
    movementID?: string;
    recommendedDistance?: number;
    actualDistance?: number;
    intervalDuration?: string;
    targetPace?: string;
    actualPace?: string;
    recommendedDuration?: string;
    actualDuration?: string;
    recommendedRest?: string;
    actualRest?: string;
    intervalType?: IntervalType;
    distanceUnit?: DistanceUnit;
    actualRPE?: number;
}

export class CreateEquipmentRequest implements ICreateEquipmentRequest {
    name?: string | undefined;

    constructor(data?: ICreateEquipmentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateEquipmentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEquipmentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateEquipmentRequest {
    name?: string | undefined;
}

export class CreateInjuryEventRequest implements ICreateInjuryEventRequest {
    trainingSessionID?: string | undefined;
    injuryID!: string;
    notes!: string;
    painLevel!: number;
    injuryType!: InjuryEventType;
    movementIDs!: string[];

    constructor(data?: ICreateInjuryEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.movementIDs = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            this.injuryID = _data["injuryID"];
            this.notes = _data["notes"];
            this.painLevel = _data["painLevel"];
            this.injuryType = _data["injuryType"];
            if (Array.isArray(_data["movementIDs"])) {
                this.movementIDs = [] as any;
                for (let item of _data["movementIDs"])
                    this.movementIDs!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateInjuryEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInjuryEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        data["injuryID"] = this.injuryID;
        data["notes"] = this.notes;
        data["painLevel"] = this.painLevel;
        data["injuryType"] = this.injuryType;
        if (Array.isArray(this.movementIDs)) {
            data["movementIDs"] = [];
            for (let item of this.movementIDs)
                data["movementIDs"].push(item);
        }
        return data;
    }
}

export interface ICreateInjuryEventRequest {
    trainingSessionID?: string | undefined;
    injuryID: string;
    notes: string;
    painLevel: number;
    injuryType: InjuryEventType;
    movementIDs: string[];
}

export class CreateInjuryRequest implements ICreateInjuryRequest {
    name!: string;
    injuryDate!: Date;
    notes!: string;

    constructor(data?: ICreateInjuryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.injuryDate = _data["injuryDate"] ? new Date(_data["injuryDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): CreateInjuryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInjuryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["injuryDate"] = this.injuryDate ? this.injuryDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICreateInjuryRequest {
    name: string;
    injuryDate: Date;
    notes: string;
}

export class CreateLiftSetEntryRequest implements ICreateLiftSetEntryRequest {
    movementID?: string;
    recommendedReps?: number | undefined;
    recommendedWeight?: number | undefined;
    recommendedRPE?: number | undefined;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit?: WeightUnit;

    constructor(data?: ICreateLiftSetEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementID = _data["movementID"];
            this.recommendedReps = _data["recommendedReps"];
            this.recommendedWeight = _data["recommendedWeight"];
            this.recommendedRPE = _data["recommendedRPE"];
            this.actualReps = _data["actualReps"];
            this.actualWeight = _data["actualWeight"];
            this.actualRPE = _data["actualRPE"];
            this.weightUnit = _data["weightUnit"];
        }
    }

    static fromJS(data: any): CreateLiftSetEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLiftSetEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementID"] = this.movementID;
        data["recommendedReps"] = this.recommendedReps;
        data["recommendedWeight"] = this.recommendedWeight;
        data["recommendedRPE"] = this.recommendedRPE;
        data["actualReps"] = this.actualReps;
        data["actualWeight"] = this.actualWeight;
        data["actualRPE"] = this.actualRPE;
        data["weightUnit"] = this.weightUnit;
        return data;
    }
}

export interface ICreateLiftSetEntryRequest {
    movementID?: string;
    recommendedReps?: number | undefined;
    recommendedWeight?: number | undefined;
    recommendedRPE?: number | undefined;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit?: WeightUnit;
}

export class CreateMovementBaseRequest implements ICreateMovementBaseRequest {
    name?: string | undefined;
    description?: string | undefined;
    muscleGroups?: MuscleGroup[] | undefined;

    constructor(data?: ICreateMovementBaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["muscleGroups"])) {
                this.muscleGroups = [] as any;
                for (let item of _data["muscleGroups"])
                    this.muscleGroups!.push(MuscleGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateMovementBaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMovementBaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.muscleGroups)) {
            data["muscleGroups"] = [];
            for (let item of this.muscleGroups)
                data["muscleGroups"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ICreateMovementBaseRequest {
    name?: string | undefined;
    description?: string | undefined;
    muscleGroups?: MuscleGroup[] | undefined;
}

export class CreateMovementDataRequest implements ICreateMovementDataRequest {
    equipmentID?: string;
    movementBaseID?: string;
    movementModifierID?: string | undefined;

    constructor(data?: ICreateMovementDataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentID = _data["equipmentID"];
            this.movementBaseID = _data["movementBaseID"];
            this.movementModifierID = _data["movementModifierID"];
        }
    }

    static fromJS(data: any): CreateMovementDataRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMovementDataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentID"] = this.equipmentID;
        data["movementBaseID"] = this.movementBaseID;
        data["movementModifierID"] = this.movementModifierID;
        return data;
    }
}

export interface ICreateMovementDataRequest {
    equipmentID?: string;
    movementBaseID?: string;
    movementModifierID?: string | undefined;
}

export class CreateMovementRequest implements ICreateMovementRequest {
    trainingSessionID?: string;
    movementData?: CreateMovementDataRequest;
    notes?: string | undefined;

    constructor(data?: ICreateMovementRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            this.movementData = _data["movementData"] ? CreateMovementDataRequest.fromJS(_data["movementData"]) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): CreateMovementRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMovementRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        data["movementData"] = this.movementData ? this.movementData.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICreateMovementRequest {
    trainingSessionID?: string;
    movementData?: CreateMovementDataRequest;
    notes?: string | undefined;
}

export class CreatePersonalApiAccessTokenRequest implements ICreatePersonalApiAccessTokenRequest {
    applicationName!: string;
    accessToken!: string;

    constructor(data?: ICreatePersonalApiAccessTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationName = _data["applicationName"];
            this.accessToken = _data["accessToken"];
        }
    }

    static fromJS(data: any): CreatePersonalApiAccessTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePersonalApiAccessTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationName"] = this.applicationName;
        data["accessToken"] = this.accessToken;
        return data;
    }
}

export interface ICreatePersonalApiAccessTokenRequest {
    applicationName: string;
    accessToken: string;
}

export class CreateProfileRequest implements ICreateProfileRequest {
    displayName!: string;
    age!: number;
    weight!: number;

    constructor(data?: ICreateProfileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.age = _data["age"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): CreateProfileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProfileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["age"] = this.age;
        data["weight"] = this.weight;
        return data;
    }
}

export interface ICreateProfileRequest {
    displayName: string;
    age: number;
    weight: number;
}

export class CreateTrainingProgramRequest implements ICreateTrainingProgramRequest {
    trainingProgramID?: string;
    title?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    tags?: string[] | undefined;

    constructor(data?: ICreateTrainingProgramRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingProgramID = _data["trainingProgramID"];
            this.title = _data["title"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateTrainingProgramRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTrainingProgramRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramID"] = this.trainingProgramID;
        data["title"] = this.title;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface ICreateTrainingProgramRequest {
    trainingProgramID?: string;
    title?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    tags?: string[] | undefined;
}

export class CreateTrainingSessionRequest implements ICreateTrainingSessionRequest {
    date?: Date;
    trainingProgramID?: string | undefined;
    notes?: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;

    constructor(data?: ICreateTrainingSessionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.trainingProgramID = _data["trainingProgramID"];
            this.notes = _data["notes"];
            this.perceivedEffortRatings = _data["perceivedEffortRatings"] ? PerceivedEffortRatings.fromJS(_data["perceivedEffortRatings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateTrainingSessionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTrainingSessionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["trainingProgramID"] = this.trainingProgramID;
        data["notes"] = this.notes;
        data["perceivedEffortRatings"] = this.perceivedEffortRatings ? this.perceivedEffortRatings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateTrainingSessionRequest {
    date?: Date;
    trainingProgramID?: string | undefined;
    notes?: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;
}

export class CreateWellnessStateRequest implements ICreateWellnessStateRequest {
    date!: Date;
    energy!: number;
    motivation!: number;
    mood!: number;
    stress!: number;

    constructor(data?: ICreateWellnessStateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.energy = _data["energy"];
            this.motivation = _data["motivation"];
            this.mood = _data["mood"];
            this.stress = _data["stress"];
        }
    }

    static fromJS(data: any): CreateWellnessStateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWellnessStateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["energy"] = this.energy;
        data["motivation"] = this.motivation;
        data["mood"] = this.mood;
        data["stress"] = this.stress;
        return data;
    }
}

export interface ICreateWellnessStateRequest {
    date: Date;
    energy: number;
    motivation: number;
    mood: number;
    stress: number;
}

export class DTSetEntry implements IDTSetEntry {
    setEntryID!: string;
    movementID!: string;
    movement?: Movement;
    recommendedDistance!: number;
    actualDistance!: number;
    intervalDuration!: string;
    targetPace!: string;
    actualPace!: string;
    recommendedDuration!: string;
    actualDuration!: string;
    recommendedRest!: string;
    actualRest!: string;
    intervalType!: IntervalType;
    distanceUnit!: DistanceUnit;
    actualRPE!: number;

    constructor(data?: IDTSetEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryID = _data["setEntryID"];
            this.movementID = _data["movementID"];
            this.movement = _data["movement"] ? Movement.fromJS(_data["movement"]) : <any>undefined;
            this.recommendedDistance = _data["recommendedDistance"];
            this.actualDistance = _data["actualDistance"];
            this.intervalDuration = _data["intervalDuration"];
            this.targetPace = _data["targetPace"];
            this.actualPace = _data["actualPace"];
            this.recommendedDuration = _data["recommendedDuration"];
            this.actualDuration = _data["actualDuration"];
            this.recommendedRest = _data["recommendedRest"];
            this.actualRest = _data["actualRest"];
            this.intervalType = _data["intervalType"];
            this.distanceUnit = _data["distanceUnit"];
            this.actualRPE = _data["actualRPE"];
        }
    }

    static fromJS(data: any): DTSetEntry {
        data = typeof data === 'object' ? data : {};
        let result = new DTSetEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryID"] = this.setEntryID;
        data["movementID"] = this.movementID;
        data["movement"] = this.movement ? this.movement.toJSON() : <any>undefined;
        data["recommendedDistance"] = this.recommendedDistance;
        data["actualDistance"] = this.actualDistance;
        data["intervalDuration"] = this.intervalDuration;
        data["targetPace"] = this.targetPace;
        data["actualPace"] = this.actualPace;
        data["recommendedDuration"] = this.recommendedDuration;
        data["actualDuration"] = this.actualDuration;
        data["recommendedRest"] = this.recommendedRest;
        data["actualRest"] = this.actualRest;
        data["intervalType"] = this.intervalType;
        data["distanceUnit"] = this.distanceUnit;
        data["actualRPE"] = this.actualRPE;
        return data;
    }
}

export interface IDTSetEntry {
    setEntryID: string;
    movementID: string;
    movement?: Movement;
    recommendedDistance: number;
    actualDistance: number;
    intervalDuration: string;
    targetPace: string;
    actualPace: string;
    recommendedDuration: string;
    actualDuration: string;
    recommendedRest: string;
    actualRest: string;
    intervalType: IntervalType;
    distanceUnit: DistanceUnit;
    actualRPE: number;
}

export class DTSetEntryDTO implements IDTSetEntryDTO {
    setEntryID?: string;
    movementID?: string;
    recommendedDistance?: number;
    actualDistance?: number;
    intervalDuration?: string;
    targetPace?: string;
    actualPace?: string;
    recommendedDuration?: string;
    actualDuration?: string;
    recommendedRest?: string;
    actualRest?: string;
    intervalType?: IntervalType;
    distanceUnit?: DistanceUnit;
    actualRPE?: number;

    constructor(data?: IDTSetEntryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryID = _data["setEntryID"];
            this.movementID = _data["movementID"];
            this.recommendedDistance = _data["recommendedDistance"];
            this.actualDistance = _data["actualDistance"];
            this.intervalDuration = _data["intervalDuration"];
            this.targetPace = _data["targetPace"];
            this.actualPace = _data["actualPace"];
            this.recommendedDuration = _data["recommendedDuration"];
            this.actualDuration = _data["actualDuration"];
            this.recommendedRest = _data["recommendedRest"];
            this.actualRest = _data["actualRest"];
            this.intervalType = _data["intervalType"];
            this.distanceUnit = _data["distanceUnit"];
            this.actualRPE = _data["actualRPE"];
        }
    }

    static fromJS(data: any): DTSetEntryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DTSetEntryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryID"] = this.setEntryID;
        data["movementID"] = this.movementID;
        data["recommendedDistance"] = this.recommendedDistance;
        data["actualDistance"] = this.actualDistance;
        data["intervalDuration"] = this.intervalDuration;
        data["targetPace"] = this.targetPace;
        data["actualPace"] = this.actualPace;
        data["recommendedDuration"] = this.recommendedDuration;
        data["actualDuration"] = this.actualDuration;
        data["recommendedRest"] = this.recommendedRest;
        data["actualRest"] = this.actualRest;
        data["intervalType"] = this.intervalType;
        data["distanceUnit"] = this.distanceUnit;
        data["actualRPE"] = this.actualRPE;
        return data;
    }
}

export interface IDTSetEntryDTO {
    setEntryID?: string;
    movementID?: string;
    recommendedDistance?: number;
    actualDistance?: number;
    intervalDuration?: string;
    targetPace?: string;
    actualPace?: string;
    recommendedDuration?: string;
    actualDuration?: string;
    recommendedRest?: string;
    actualRest?: string;
    intervalType?: IntervalType;
    distanceUnit?: DistanceUnit;
    actualRPE?: number;
}

export class DailyOuraData implements IDailyOuraData {
    objectID?: string;
    userID?: string;
    date?: Date;
    syncDate?: Date;
    resilienceData!: ResilienceData;
    activityData!: ActivityData;
    sleepData!: SleepData;
    readinessData!: ReadinessData;
    activityJson?: string | undefined;
    resilienceJson?: string | undefined;
    sleepJson?: string | undefined;
    readinessJson?: string | undefined;

    constructor(data?: IDailyOuraData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.resilienceData = new ResilienceData();
            this.activityData = new ActivityData();
            this.sleepData = new SleepData();
            this.readinessData = new ReadinessData();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectID = _data["objectID"];
            this.userID = _data["userID"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.syncDate = _data["syncDate"] ? new Date(_data["syncDate"].toString()) : <any>undefined;
            this.resilienceData = _data["resilienceData"] ? ResilienceData.fromJS(_data["resilienceData"]) : new ResilienceData();
            this.activityData = _data["activityData"] ? ActivityData.fromJS(_data["activityData"]) : new ActivityData();
            this.sleepData = _data["sleepData"] ? SleepData.fromJS(_data["sleepData"]) : new SleepData();
            this.readinessData = _data["readinessData"] ? ReadinessData.fromJS(_data["readinessData"]) : new ReadinessData();
            this.activityJson = _data["activityJson"];
            this.resilienceJson = _data["resilienceJson"];
            this.sleepJson = _data["sleepJson"];
            this.readinessJson = _data["readinessJson"];
        }
    }

    static fromJS(data: any): DailyOuraData {
        data = typeof data === 'object' ? data : {};
        let result = new DailyOuraData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectID"] = this.objectID;
        data["userID"] = this.userID;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["syncDate"] = this.syncDate ? formatDate(this.syncDate) : <any>undefined;
        data["resilienceData"] = this.resilienceData ? this.resilienceData.toJSON() : <any>undefined;
        data["activityData"] = this.activityData ? this.activityData.toJSON() : <any>undefined;
        data["sleepData"] = this.sleepData ? this.sleepData.toJSON() : <any>undefined;
        data["readinessData"] = this.readinessData ? this.readinessData.toJSON() : <any>undefined;
        data["activityJson"] = this.activityJson;
        data["resilienceJson"] = this.resilienceJson;
        data["sleepJson"] = this.sleepJson;
        data["readinessJson"] = this.readinessJson;
        return data;
    }
}

export interface IDailyOuraData {
    objectID?: string;
    userID?: string;
    date?: Date;
    syncDate?: Date;
    resilienceData: ResilienceData;
    activityData: ActivityData;
    sleepData: SleepData;
    readinessData: ReadinessData;
    activityJson?: string | undefined;
    resilienceJson?: string | undefined;
    sleepJson?: string | undefined;
    readinessJson?: string | undefined;
}

export class DailyOuraDataDTO implements IDailyOuraDataDTO {
    objectID?: string;
    date?: Date;
    resilienceData?: ResilienceData;
    activityData?: ActivityData;
    sleepData?: SleepData;
    readinessData?: ReadinessData;

    constructor(data?: IDailyOuraDataDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectID = _data["objectID"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.resilienceData = _data["resilienceData"] ? ResilienceData.fromJS(_data["resilienceData"]) : <any>undefined;
            this.activityData = _data["activityData"] ? ActivityData.fromJS(_data["activityData"]) : <any>undefined;
            this.sleepData = _data["sleepData"] ? SleepData.fromJS(_data["sleepData"]) : <any>undefined;
            this.readinessData = _data["readinessData"] ? ReadinessData.fromJS(_data["readinessData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DailyOuraDataDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DailyOuraDataDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectID"] = this.objectID;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["resilienceData"] = this.resilienceData ? this.resilienceData.toJSON() : <any>undefined;
        data["activityData"] = this.activityData ? this.activityData.toJSON() : <any>undefined;
        data["sleepData"] = this.sleepData ? this.sleepData.toJSON() : <any>undefined;
        data["readinessData"] = this.readinessData ? this.readinessData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDailyOuraDataDTO {
    objectID?: string;
    date?: Date;
    resilienceData?: ResilienceData;
    activityData?: ActivityData;
    sleepData?: SleepData;
    readinessData?: ReadinessData;
}

export class DateRangeRequest implements IDateRangeRequest {
    startDate!: Date;
    endDate!: Date;

    constructor(data?: IDateRangeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateRangeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDateRangeRequest {
    startDate: Date;
    endDate: Date;
}

export enum DistanceUnit {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class Equipment implements IEquipment {
    equipmentID!: string;
    name!: string;
    userID!: string;
    enabled!: boolean;

    constructor(data?: IEquipment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentID = _data["equipmentID"];
            this.name = _data["name"];
            this.userID = _data["userID"];
            this.enabled = _data["enabled"];
        }
    }

    static fromJS(data: any): Equipment {
        data = typeof data === 'object' ? data : {};
        let result = new Equipment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentID"] = this.equipmentID;
        data["name"] = this.name;
        data["userID"] = this.userID;
        data["enabled"] = this.enabled;
        return data;
    }
}

export interface IEquipment {
    equipmentID: string;
    name: string;
    userID: string;
    enabled: boolean;
}

export class EquipmentDTO implements IEquipmentDTO {
    equipmentID?: string;
    name?: string | undefined;
    enabled?: boolean;

    constructor(data?: IEquipmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentID = _data["equipmentID"];
            this.name = _data["name"];
            this.enabled = _data["enabled"];
        }
    }

    static fromJS(data: any): EquipmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentID"] = this.equipmentID;
        data["name"] = this.name;
        data["enabled"] = this.enabled;
        return data;
    }
}

export interface IEquipmentDTO {
    equipmentID?: string;
    name?: string | undefined;
    enabled?: boolean;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email!: string | undefined;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email: string | undefined;
}

export class HttpValidationProblemDetails implements IHttpValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IHttpValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;
}

export class IdentityUser implements IIdentityUser {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;

    constructor(data?: IIdentityUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): IdentityUser {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IIdentityUser {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export class InfoRequest implements IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;

    constructor(data?: IInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newEmail = _data["newEmail"];
            this.newPassword = _data["newPassword"];
            this.oldPassword = _data["oldPassword"];
        }
    }

    static fromJS(data: any): InfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newEmail"] = this.newEmail;
        data["newPassword"] = this.newPassword;
        data["oldPassword"] = this.oldPassword;
        return data;
    }
}

export interface IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;
}

export class InfoResponse implements IInfoResponse {
    email!: string | undefined;
    isEmailConfirmed!: boolean;

    constructor(data?: IInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
        }
    }

    static fromJS(data: any): InfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        return data;
    }
}

export interface IInfoResponse {
    email: string | undefined;
    isEmailConfirmed: boolean;
}

export class Injury implements IInjury {
    injuryID?: string;
    userID!: string;
    name!: string;
    notes!: string;
    injuryDate!: Date;
    isActive?: boolean;
    injuryEvents?: InjuryEvent[] | undefined;

    constructor(data?: IInjury) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.injuryID = _data["injuryID"];
            this.userID = _data["userID"];
            this.name = _data["name"];
            this.notes = _data["notes"];
            this.injuryDate = _data["injuryDate"] ? new Date(_data["injuryDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["injuryEvents"])) {
                this.injuryEvents = [] as any;
                for (let item of _data["injuryEvents"])
                    this.injuryEvents!.push(InjuryEvent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Injury {
        data = typeof data === 'object' ? data : {};
        let result = new Injury();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["injuryID"] = this.injuryID;
        data["userID"] = this.userID;
        data["name"] = this.name;
        data["notes"] = this.notes;
        data["injuryDate"] = this.injuryDate ? formatDate(this.injuryDate) : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.injuryEvents)) {
            data["injuryEvents"] = [];
            for (let item of this.injuryEvents)
                data["injuryEvents"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IInjury {
    injuryID?: string;
    userID: string;
    name: string;
    notes: string;
    injuryDate: Date;
    isActive?: boolean;
    injuryEvents?: InjuryEvent[] | undefined;
}

export class InjuryDTO implements IInjuryDTO {
    injuryID!: string;
    name!: string;
    notes!: string;
    injuryDate!: Date;
    isActive!: boolean;
    injuryEvents!: InjuryEventDTO[];

    constructor(data?: IInjuryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.injuryEvents = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.injuryID = _data["injuryID"];
            this.name = _data["name"];
            this.notes = _data["notes"];
            this.injuryDate = _data["injuryDate"] ? new Date(_data["injuryDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["injuryEvents"])) {
                this.injuryEvents = [] as any;
                for (let item of _data["injuryEvents"])
                    this.injuryEvents!.push(InjuryEventDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InjuryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InjuryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["injuryID"] = this.injuryID;
        data["name"] = this.name;
        data["notes"] = this.notes;
        data["injuryDate"] = this.injuryDate ? formatDate(this.injuryDate) : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.injuryEvents)) {
            data["injuryEvents"] = [];
            for (let item of this.injuryEvents)
                data["injuryEvents"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IInjuryDTO {
    injuryID: string;
    name: string;
    notes: string;
    injuryDate: Date;
    isActive: boolean;
    injuryEvents: InjuryEventDTO[];
}

export class InjuryEvent implements IInjuryEvent {
    injuryEventID?: string;
    injuryID!: string;
    injury?: Injury;
    trainingSessionID?: string | undefined;
    notes?: string | undefined;
    painLevel?: number;
    movementIDs?: string[] | undefined;
    injuryType?: InjuryEventType;
    creationTime?: Date;

    constructor(data?: IInjuryEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.injuryEventID = _data["injuryEventID"];
            this.injuryID = _data["injuryID"];
            this.injury = _data["injury"] ? Injury.fromJS(_data["injury"]) : <any>undefined;
            this.trainingSessionID = _data["trainingSessionID"];
            this.notes = _data["notes"];
            this.painLevel = _data["painLevel"];
            if (Array.isArray(_data["movementIDs"])) {
                this.movementIDs = [] as any;
                for (let item of _data["movementIDs"])
                    this.movementIDs!.push(item);
            }
            this.injuryType = _data["injuryType"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InjuryEvent {
        data = typeof data === 'object' ? data : {};
        let result = new InjuryEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["injuryEventID"] = this.injuryEventID;
        data["injuryID"] = this.injuryID;
        data["injury"] = this.injury ? this.injury.toJSON() : <any>undefined;
        data["trainingSessionID"] = this.trainingSessionID;
        data["notes"] = this.notes;
        data["painLevel"] = this.painLevel;
        if (Array.isArray(this.movementIDs)) {
            data["movementIDs"] = [];
            for (let item of this.movementIDs)
                data["movementIDs"].push(item);
        }
        data["injuryType"] = this.injuryType;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IInjuryEvent {
    injuryEventID?: string;
    injuryID: string;
    injury?: Injury;
    trainingSessionID?: string | undefined;
    notes?: string | undefined;
    painLevel?: number;
    movementIDs?: string[] | undefined;
    injuryType?: InjuryEventType;
    creationTime?: Date;
}

export class InjuryEventDTO implements IInjuryEventDTO {
    injuryEventID!: string;
    trainingSessionID?: string | undefined;
    movementIDs?: string[] | undefined;
    notes!: string;
    painLevel!: number;
    injuryType!: InjuryEventType;
    creationTime!: Date;

    constructor(data?: IInjuryEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.injuryEventID = _data["injuryEventID"];
            this.trainingSessionID = _data["trainingSessionID"];
            if (Array.isArray(_data["movementIDs"])) {
                this.movementIDs = [] as any;
                for (let item of _data["movementIDs"])
                    this.movementIDs!.push(item);
            }
            this.notes = _data["notes"];
            this.painLevel = _data["painLevel"];
            this.injuryType = _data["injuryType"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InjuryEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InjuryEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["injuryEventID"] = this.injuryEventID;
        data["trainingSessionID"] = this.trainingSessionID;
        if (Array.isArray(this.movementIDs)) {
            data["movementIDs"] = [];
            for (let item of this.movementIDs)
                data["movementIDs"].push(item);
        }
        data["notes"] = this.notes;
        data["painLevel"] = this.painLevel;
        data["injuryType"] = this.injuryType;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IInjuryEventDTO {
    injuryEventID: string;
    trainingSessionID?: string | undefined;
    movementIDs?: string[] | undefined;
    notes: string;
    painLevel: number;
    injuryType: InjuryEventType;
    creationTime: Date;
}

export enum InjuryEventType {
    _0 = 0,
    _1 = 1,
}

export enum IntervalType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export class LHChatConversation implements ILHChatConversation {
    chatConversationID!: string;
    userID!: string;
    createdAt!: Date;
    lastUpdate!: Date;
    name!: string | undefined;
    chatSystemMessage!: LHSystemChatMessage;
    modelMessages!: LHModelChatMessage[] | undefined;
    userMessages!: LHUserChatMessage[] | undefined;
    toolMessages!: LHChatToolCallResult[] | undefined;

    constructor(data?: ILHChatConversation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.chatSystemMessage = new LHSystemChatMessage();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatConversationID = _data["chatConversationID"];
            this.userID = _data["userID"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.chatSystemMessage = _data["chatSystemMessage"] ? LHSystemChatMessage.fromJS(_data["chatSystemMessage"]) : new LHSystemChatMessage();
            if (Array.isArray(_data["modelMessages"])) {
                this.modelMessages = [] as any;
                for (let item of _data["modelMessages"])
                    this.modelMessages!.push(LHModelChatMessage.fromJS(item));
            }
            if (Array.isArray(_data["userMessages"])) {
                this.userMessages = [] as any;
                for (let item of _data["userMessages"])
                    this.userMessages!.push(LHUserChatMessage.fromJS(item));
            }
            if (Array.isArray(_data["toolMessages"])) {
                this.toolMessages = [] as any;
                for (let item of _data["toolMessages"])
                    this.toolMessages!.push(LHChatToolCallResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LHChatConversation {
        data = typeof data === 'object' ? data : {};
        let result = new LHChatConversation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatConversationID"] = this.chatConversationID;
        data["userID"] = this.userID;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["chatSystemMessage"] = this.chatSystemMessage ? this.chatSystemMessage.toJSON() : <any>undefined;
        if (Array.isArray(this.modelMessages)) {
            data["modelMessages"] = [];
            for (let item of this.modelMessages)
                data["modelMessages"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.userMessages)) {
            data["userMessages"] = [];
            for (let item of this.userMessages)
                data["userMessages"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.toolMessages)) {
            data["toolMessages"] = [];
            for (let item of this.toolMessages)
                data["toolMessages"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ILHChatConversation {
    chatConversationID: string;
    userID: string;
    createdAt: Date;
    lastUpdate: Date;
    name: string | undefined;
    chatSystemMessage: LHSystemChatMessage;
    modelMessages: LHModelChatMessage[] | undefined;
    userMessages: LHUserChatMessage[] | undefined;
    toolMessages: LHChatToolCallResult[] | undefined;
}

export class LHChatConversationDTO implements ILHChatConversationDTO {
    chatConversationID!: string;
    createdAt!: Date;
    lastUpdate!: Date;
    name!: string | undefined;
    messages!: LHChatMessageDTO[] | undefined;

    constructor(data?: ILHChatConversationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatConversationID = _data["chatConversationID"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
            this.name = _data["name"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(LHChatMessageDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LHChatConversationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LHChatConversationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatConversationID"] = this.chatConversationID;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        data["name"] = this.name;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ILHChatConversationDTO {
    chatConversationID: string;
    createdAt: Date;
    lastUpdate: Date;
    name: string | undefined;
    messages: LHChatMessageDTO[] | undefined;
}

export class LHChatMessageDTO implements ILHChatMessageDTO {
    chatMessageItemID?: string;
    chatConversationID?: string;
    creationTime?: Date;
    tokenCount?: number;
    content?: string | undefined;

    constructor(data?: ILHChatMessageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatMessageItemID = _data["chatMessageItemID"];
            this.chatConversationID = _data["chatConversationID"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.tokenCount = _data["tokenCount"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): LHChatMessageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LHChatMessageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatMessageItemID"] = this.chatMessageItemID;
        data["chatConversationID"] = this.chatConversationID;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["tokenCount"] = this.tokenCount;
        data["content"] = this.content;
        return data;
    }
}

export interface ILHChatMessageDTO {
    chatMessageItemID?: string;
    chatConversationID?: string;
    creationTime?: Date;
    tokenCount?: number;
    content?: string | undefined;
}

export class LHChatToolCallResult implements ILHChatToolCallResult {
    chatMessageItemID!: string;
    chatConversationID!: string;
    chatConversation?: LHChatConversation;
    creationTime!: Date;
    tokenCount!: number;
    content!: string | undefined;

    constructor(data?: ILHChatToolCallResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatMessageItemID = _data["chatMessageItemID"];
            this.chatConversationID = _data["chatConversationID"];
            this.chatConversation = _data["chatConversation"] ? LHChatConversation.fromJS(_data["chatConversation"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.tokenCount = _data["tokenCount"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): LHChatToolCallResult {
        data = typeof data === 'object' ? data : {};
        let result = new LHChatToolCallResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatMessageItemID"] = this.chatMessageItemID;
        data["chatConversationID"] = this.chatConversationID;
        data["chatConversation"] = this.chatConversation ? this.chatConversation.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["tokenCount"] = this.tokenCount;
        data["content"] = this.content;
        return data;
    }
}

export interface ILHChatToolCallResult {
    chatMessageItemID: string;
    chatConversationID: string;
    chatConversation?: LHChatConversation;
    creationTime: Date;
    tokenCount: number;
    content: string | undefined;
}

export class LHModelChatMessage implements ILHModelChatMessage {
    chatMessageItemID!: string;
    chatConversationID!: string;
    chatConversation?: LHChatConversation;
    creationTime!: Date;
    tokenCount!: number;
    content!: string | undefined;

    constructor(data?: ILHModelChatMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatMessageItemID = _data["chatMessageItemID"];
            this.chatConversationID = _data["chatConversationID"];
            this.chatConversation = _data["chatConversation"] ? LHChatConversation.fromJS(_data["chatConversation"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.tokenCount = _data["tokenCount"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): LHModelChatMessage {
        data = typeof data === 'object' ? data : {};
        let result = new LHModelChatMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatMessageItemID"] = this.chatMessageItemID;
        data["chatConversationID"] = this.chatConversationID;
        data["chatConversation"] = this.chatConversation ? this.chatConversation.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["tokenCount"] = this.tokenCount;
        data["content"] = this.content;
        return data;
    }
}

export interface ILHModelChatMessage {
    chatMessageItemID: string;
    chatConversationID: string;
    chatConversation?: LHChatConversation;
    creationTime: Date;
    tokenCount: number;
    content: string | undefined;
}

export class LHSystemChatMessage implements ILHSystemChatMessage {
    chatMessageItemID!: string;
    chatConversationID!: string;
    chatConversation?: LHChatConversation;
    creationTime!: Date;
    tokenCount!: number;
    content!: string | undefined;

    constructor(data?: ILHSystemChatMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatMessageItemID = _data["chatMessageItemID"];
            this.chatConversationID = _data["chatConversationID"];
            this.chatConversation = _data["chatConversation"] ? LHChatConversation.fromJS(_data["chatConversation"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.tokenCount = _data["tokenCount"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): LHSystemChatMessage {
        data = typeof data === 'object' ? data : {};
        let result = new LHSystemChatMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatMessageItemID"] = this.chatMessageItemID;
        data["chatConversationID"] = this.chatConversationID;
        data["chatConversation"] = this.chatConversation ? this.chatConversation.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["tokenCount"] = this.tokenCount;
        data["content"] = this.content;
        return data;
    }
}

export interface ILHSystemChatMessage {
    chatMessageItemID: string;
    chatConversationID: string;
    chatConversation?: LHChatConversation;
    creationTime: Date;
    tokenCount: number;
    content: string | undefined;
}

export class LHUserChatMessage implements ILHUserChatMessage {
    chatMessageItemID!: string;
    chatConversationID!: string;
    chatConversation?: LHChatConversation;
    creationTime!: Date;
    tokenCount!: number;
    content!: string | undefined;

    constructor(data?: ILHUserChatMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatMessageItemID = _data["chatMessageItemID"];
            this.chatConversationID = _data["chatConversationID"];
            this.chatConversation = _data["chatConversation"] ? LHChatConversation.fromJS(_data["chatConversation"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.tokenCount = _data["tokenCount"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): LHUserChatMessage {
        data = typeof data === 'object' ? data : {};
        let result = new LHUserChatMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatMessageItemID"] = this.chatMessageItemID;
        data["chatConversationID"] = this.chatConversationID;
        data["chatConversation"] = this.chatConversation ? this.chatConversation.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["tokenCount"] = this.tokenCount;
        data["content"] = this.content;
        return data;
    }
}

export interface ILHUserChatMessage {
    chatMessageItemID: string;
    chatConversationID: string;
    chatConversation?: LHChatConversation;
    creationTime: Date;
    tokenCount: number;
    content: string | undefined;
}

export class LiftSetEntry implements ILiftSetEntry {
    setEntryID?: string;
    movementID?: string;
    movement?: Movement;
    recommendedReps?: number | undefined;
    recommendedWeight?: number | undefined;
    recommendedRPE?: number | undefined;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit!: WeightUnit;

    constructor(data?: ILiftSetEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryID = _data["setEntryID"];
            this.movementID = _data["movementID"];
            this.movement = _data["movement"] ? Movement.fromJS(_data["movement"]) : <any>undefined;
            this.recommendedReps = _data["recommendedReps"];
            this.recommendedWeight = _data["recommendedWeight"];
            this.recommendedRPE = _data["recommendedRPE"];
            this.actualReps = _data["actualReps"];
            this.actualWeight = _data["actualWeight"];
            this.actualRPE = _data["actualRPE"];
            this.weightUnit = _data["weightUnit"];
        }
    }

    static fromJS(data: any): LiftSetEntry {
        data = typeof data === 'object' ? data : {};
        let result = new LiftSetEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryID"] = this.setEntryID;
        data["movementID"] = this.movementID;
        data["movement"] = this.movement ? this.movement.toJSON() : <any>undefined;
        data["recommendedReps"] = this.recommendedReps;
        data["recommendedWeight"] = this.recommendedWeight;
        data["recommendedRPE"] = this.recommendedRPE;
        data["actualReps"] = this.actualReps;
        data["actualWeight"] = this.actualWeight;
        data["actualRPE"] = this.actualRPE;
        data["weightUnit"] = this.weightUnit;
        return data;
    }
}

export interface ILiftSetEntry {
    setEntryID?: string;
    movementID?: string;
    movement?: Movement;
    recommendedReps?: number | undefined;
    recommendedWeight?: number | undefined;
    recommendedRPE?: number | undefined;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit: WeightUnit;
}

export class LiftSetEntryDTO implements ILiftSetEntryDTO {
    setEntryID?: string;
    movementID?: string;
    recommendedReps?: number | undefined;
    recommendedWeight?: number | undefined;
    recommendedRPE?: number | undefined;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit?: WeightUnit;

    constructor(data?: ILiftSetEntryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryID = _data["setEntryID"];
            this.movementID = _data["movementID"];
            this.recommendedReps = _data["recommendedReps"];
            this.recommendedWeight = _data["recommendedWeight"];
            this.recommendedRPE = _data["recommendedRPE"];
            this.actualReps = _data["actualReps"];
            this.actualWeight = _data["actualWeight"];
            this.actualRPE = _data["actualRPE"];
            this.weightUnit = _data["weightUnit"];
        }
    }

    static fromJS(data: any): LiftSetEntryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LiftSetEntryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryID"] = this.setEntryID;
        data["movementID"] = this.movementID;
        data["recommendedReps"] = this.recommendedReps;
        data["recommendedWeight"] = this.recommendedWeight;
        data["recommendedRPE"] = this.recommendedRPE;
        data["actualReps"] = this.actualReps;
        data["actualWeight"] = this.actualWeight;
        data["actualRPE"] = this.actualRPE;
        data["weightUnit"] = this.weightUnit;
        return data;
    }
}

export interface ILiftSetEntryDTO {
    setEntryID?: string;
    movementID?: string;
    recommendedReps?: number | undefined;
    recommendedWeight?: number | undefined;
    recommendedRPE?: number | undefined;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit?: WeightUnit;
}

export class LionheartUser implements ILionheartUser {
    userID?: string;
    identityUser?: IdentityUser;
    name?: string | undefined;
    age?: number;
    weight?: number;
    wellnessStates?: WellnessState[] | undefined;
    activities?: Activity[] | undefined;
    apiAccessTokens?: ApiAccessToken[] | undefined;
    dailyOuraInfos?: DailyOuraData[] | undefined;
    trainingPrograms?: TrainingProgram[] | undefined;
    trainingSessions?: TrainingSession[] | undefined;
    movementBases?: MovementBase[] | undefined;
    movementDatas?: MovementData[] | undefined;
    movementModifiers?: MovementModifier[] | undefined;
    equipments?: Equipment[] | undefined;
    personalRecords?: PersonalRecord[] | undefined;
    injuries?: Injury[] | undefined;
    chatConversations?: LHChatConversation[] | undefined;

    constructor(data?: ILionheartUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userID = _data["userID"];
            this.identityUser = _data["identityUser"] ? IdentityUser.fromJS(_data["identityUser"]) : <any>undefined;
            this.name = _data["name"];
            this.age = _data["age"];
            this.weight = _data["weight"];
            if (Array.isArray(_data["wellnessStates"])) {
                this.wellnessStates = [] as any;
                for (let item of _data["wellnessStates"])
                    this.wellnessStates!.push(WellnessState.fromJS(item));
            }
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(Activity.fromJS(item));
            }
            if (Array.isArray(_data["apiAccessTokens"])) {
                this.apiAccessTokens = [] as any;
                for (let item of _data["apiAccessTokens"])
                    this.apiAccessTokens!.push(ApiAccessToken.fromJS(item));
            }
            if (Array.isArray(_data["dailyOuraInfos"])) {
                this.dailyOuraInfos = [] as any;
                for (let item of _data["dailyOuraInfos"])
                    this.dailyOuraInfos!.push(DailyOuraData.fromJS(item));
            }
            if (Array.isArray(_data["trainingPrograms"])) {
                this.trainingPrograms = [] as any;
                for (let item of _data["trainingPrograms"])
                    this.trainingPrograms!.push(TrainingProgram.fromJS(item));
            }
            if (Array.isArray(_data["trainingSessions"])) {
                this.trainingSessions = [] as any;
                for (let item of _data["trainingSessions"])
                    this.trainingSessions!.push(TrainingSession.fromJS(item));
            }
            if (Array.isArray(_data["movementBases"])) {
                this.movementBases = [] as any;
                for (let item of _data["movementBases"])
                    this.movementBases!.push(MovementBase.fromJS(item));
            }
            if (Array.isArray(_data["movementDatas"])) {
                this.movementDatas = [] as any;
                for (let item of _data["movementDatas"])
                    this.movementDatas!.push(MovementData.fromJS(item));
            }
            if (Array.isArray(_data["movementModifiers"])) {
                this.movementModifiers = [] as any;
                for (let item of _data["movementModifiers"])
                    this.movementModifiers!.push(MovementModifier.fromJS(item));
            }
            if (Array.isArray(_data["equipments"])) {
                this.equipments = [] as any;
                for (let item of _data["equipments"])
                    this.equipments!.push(Equipment.fromJS(item));
            }
            if (Array.isArray(_data["personalRecords"])) {
                this.personalRecords = [] as any;
                for (let item of _data["personalRecords"])
                    this.personalRecords!.push(PersonalRecord.fromJS(item));
            }
            if (Array.isArray(_data["injuries"])) {
                this.injuries = [] as any;
                for (let item of _data["injuries"])
                    this.injuries!.push(Injury.fromJS(item));
            }
            if (Array.isArray(_data["chatConversations"])) {
                this.chatConversations = [] as any;
                for (let item of _data["chatConversations"])
                    this.chatConversations!.push(LHChatConversation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LionheartUser {
        data = typeof data === 'object' ? data : {};
        let result = new LionheartUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userID"] = this.userID;
        data["identityUser"] = this.identityUser ? this.identityUser.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["age"] = this.age;
        data["weight"] = this.weight;
        if (Array.isArray(this.wellnessStates)) {
            data["wellnessStates"] = [];
            for (let item of this.wellnessStates)
                data["wellnessStates"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.apiAccessTokens)) {
            data["apiAccessTokens"] = [];
            for (let item of this.apiAccessTokens)
                data["apiAccessTokens"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.dailyOuraInfos)) {
            data["dailyOuraInfos"] = [];
            for (let item of this.dailyOuraInfos)
                data["dailyOuraInfos"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.trainingPrograms)) {
            data["trainingPrograms"] = [];
            for (let item of this.trainingPrograms)
                data["trainingPrograms"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.trainingSessions)) {
            data["trainingSessions"] = [];
            for (let item of this.trainingSessions)
                data["trainingSessions"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.movementBases)) {
            data["movementBases"] = [];
            for (let item of this.movementBases)
                data["movementBases"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.movementDatas)) {
            data["movementDatas"] = [];
            for (let item of this.movementDatas)
                data["movementDatas"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.movementModifiers)) {
            data["movementModifiers"] = [];
            for (let item of this.movementModifiers)
                data["movementModifiers"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.equipments)) {
            data["equipments"] = [];
            for (let item of this.equipments)
                data["equipments"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.personalRecords)) {
            data["personalRecords"] = [];
            for (let item of this.personalRecords)
                data["personalRecords"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.injuries)) {
            data["injuries"] = [];
            for (let item of this.injuries)
                data["injuries"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.chatConversations)) {
            data["chatConversations"] = [];
            for (let item of this.chatConversations)
                data["chatConversations"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ILionheartUser {
    userID?: string;
    identityUser?: IdentityUser;
    name?: string | undefined;
    age?: number;
    weight?: number;
    wellnessStates?: WellnessState[] | undefined;
    activities?: Activity[] | undefined;
    apiAccessTokens?: ApiAccessToken[] | undefined;
    dailyOuraInfos?: DailyOuraData[] | undefined;
    trainingPrograms?: TrainingProgram[] | undefined;
    trainingSessions?: TrainingSession[] | undefined;
    movementBases?: MovementBase[] | undefined;
    movementDatas?: MovementData[] | undefined;
    movementModifiers?: MovementModifier[] | undefined;
    equipments?: Equipment[] | undefined;
    personalRecords?: PersonalRecord[] | undefined;
    injuries?: Injury[] | undefined;
    chatConversations?: LHChatConversation[] | undefined;
}

export class LoginRequest implements ILoginRequest {
    email!: string | undefined;
    password!: string | undefined;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.twoFactorRecoveryCode = _data["twoFactorRecoveryCode"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["twoFactorCode"] = this.twoFactorCode;
        data["twoFactorRecoveryCode"] = this.twoFactorRecoveryCode;
        return data;
    }
}

export interface ILoginRequest {
    email: string | undefined;
    password: string | undefined;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;
}

export class Movement implements IMovement {
    movementID!: string;
    trainingSessionID!: string;
    trainingSession?: TrainingSession;
    movementDataID!: string;
    movementData?: MovementData;
    liftSets!: LiftSetEntry[] | undefined;
    distanceTimeSets!: DTSetEntry[] | undefined;
    notes!: string | undefined;
    isCompleted!: boolean;
    ordering!: number;

    constructor(data?: IMovement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementID = _data["movementID"];
            this.trainingSessionID = _data["trainingSessionID"];
            this.trainingSession = _data["trainingSession"] ? TrainingSession.fromJS(_data["trainingSession"]) : <any>undefined;
            this.movementDataID = _data["movementDataID"];
            this.movementData = _data["movementData"] ? MovementData.fromJS(_data["movementData"]) : <any>undefined;
            if (Array.isArray(_data["liftSets"])) {
                this.liftSets = [] as any;
                for (let item of _data["liftSets"])
                    this.liftSets!.push(LiftSetEntry.fromJS(item));
            }
            if (Array.isArray(_data["distanceTimeSets"])) {
                this.distanceTimeSets = [] as any;
                for (let item of _data["distanceTimeSets"])
                    this.distanceTimeSets!.push(DTSetEntry.fromJS(item));
            }
            this.notes = _data["notes"];
            this.isCompleted = _data["isCompleted"];
            this.ordering = _data["ordering"];
        }
    }

    static fromJS(data: any): Movement {
        data = typeof data === 'object' ? data : {};
        let result = new Movement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementID"] = this.movementID;
        data["trainingSessionID"] = this.trainingSessionID;
        data["trainingSession"] = this.trainingSession ? this.trainingSession.toJSON() : <any>undefined;
        data["movementDataID"] = this.movementDataID;
        data["movementData"] = this.movementData ? this.movementData.toJSON() : <any>undefined;
        if (Array.isArray(this.liftSets)) {
            data["liftSets"] = [];
            for (let item of this.liftSets)
                data["liftSets"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.distanceTimeSets)) {
            data["distanceTimeSets"] = [];
            for (let item of this.distanceTimeSets)
                data["distanceTimeSets"].push(item ? item.toJSON() : <any>undefined);
        }
        data["notes"] = this.notes;
        data["isCompleted"] = this.isCompleted;
        data["ordering"] = this.ordering;
        return data;
    }
}

export interface IMovement {
    movementID: string;
    trainingSessionID: string;
    trainingSession?: TrainingSession;
    movementDataID: string;
    movementData?: MovementData;
    liftSets: LiftSetEntry[] | undefined;
    distanceTimeSets: DTSetEntry[] | undefined;
    notes: string | undefined;
    isCompleted: boolean;
    ordering: number;
}

export class MovementBase implements IMovementBase {
    movementBaseID!: string;
    name!: string | undefined;
    userID!: string;
    description!: string | undefined;
    muscleGroups!: MuscleGroup[] | undefined;

    constructor(data?: IMovementBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementBaseID = _data["movementBaseID"];
            this.name = _data["name"];
            this.userID = _data["userID"];
            this.description = _data["description"];
            if (Array.isArray(_data["muscleGroups"])) {
                this.muscleGroups = [] as any;
                for (let item of _data["muscleGroups"])
                    this.muscleGroups!.push(MuscleGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MovementBase {
        data = typeof data === 'object' ? data : {};
        let result = new MovementBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementBaseID"] = this.movementBaseID;
        data["name"] = this.name;
        data["userID"] = this.userID;
        data["description"] = this.description;
        if (Array.isArray(this.muscleGroups)) {
            data["muscleGroups"] = [];
            for (let item of this.muscleGroups)
                data["muscleGroups"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IMovementBase {
    movementBaseID: string;
    name: string | undefined;
    userID: string;
    description: string | undefined;
    muscleGroups: MuscleGroup[] | undefined;
}

export class MovementBaseDTO implements IMovementBaseDTO {
    movementBaseID?: string;
    name?: string | undefined;
    description?: string | undefined;
    muscleGroups?: MuscleGroup[] | undefined;

    constructor(data?: IMovementBaseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementBaseID = _data["movementBaseID"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["muscleGroups"])) {
                this.muscleGroups = [] as any;
                for (let item of _data["muscleGroups"])
                    this.muscleGroups!.push(MuscleGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MovementBaseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MovementBaseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementBaseID"] = this.movementBaseID;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.muscleGroups)) {
            data["muscleGroups"] = [];
            for (let item of this.muscleGroups)
                data["muscleGroups"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IMovementBaseDTO {
    movementBaseID?: string;
    name?: string | undefined;
    description?: string | undefined;
    muscleGroups?: MuscleGroup[] | undefined;
}

export class MovementDTO implements IMovementDTO {
    movementID?: string;
    trainingSessionID?: string;
    movementDataID?: string;
    movementData?: MovementDataDTO;
    liftSets?: LiftSetEntryDTO[] | undefined;
    distanceTimeSets?: DTSetEntryDTO[] | undefined;
    notes?: string | undefined;
    isCompleted?: boolean;
    ordering?: number;

    constructor(data?: IMovementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementID = _data["movementID"];
            this.trainingSessionID = _data["trainingSessionID"];
            this.movementDataID = _data["movementDataID"];
            this.movementData = _data["movementData"] ? MovementDataDTO.fromJS(_data["movementData"]) : <any>undefined;
            if (Array.isArray(_data["liftSets"])) {
                this.liftSets = [] as any;
                for (let item of _data["liftSets"])
                    this.liftSets!.push(LiftSetEntryDTO.fromJS(item));
            }
            if (Array.isArray(_data["distanceTimeSets"])) {
                this.distanceTimeSets = [] as any;
                for (let item of _data["distanceTimeSets"])
                    this.distanceTimeSets!.push(DTSetEntryDTO.fromJS(item));
            }
            this.notes = _data["notes"];
            this.isCompleted = _data["isCompleted"];
            this.ordering = _data["ordering"];
        }
    }

    static fromJS(data: any): MovementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MovementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementID"] = this.movementID;
        data["trainingSessionID"] = this.trainingSessionID;
        data["movementDataID"] = this.movementDataID;
        data["movementData"] = this.movementData ? this.movementData.toJSON() : <any>undefined;
        if (Array.isArray(this.liftSets)) {
            data["liftSets"] = [];
            for (let item of this.liftSets)
                data["liftSets"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.distanceTimeSets)) {
            data["distanceTimeSets"] = [];
            for (let item of this.distanceTimeSets)
                data["distanceTimeSets"].push(item ? item.toJSON() : <any>undefined);
        }
        data["notes"] = this.notes;
        data["isCompleted"] = this.isCompleted;
        data["ordering"] = this.ordering;
        return data;
    }
}

export interface IMovementDTO {
    movementID?: string;
    trainingSessionID?: string;
    movementDataID?: string;
    movementData?: MovementDataDTO;
    liftSets?: LiftSetEntryDTO[] | undefined;
    distanceTimeSets?: DTSetEntryDTO[] | undefined;
    notes?: string | undefined;
    isCompleted?: boolean;
    ordering?: number;
}

export class MovementData implements IMovementData {
    movementDataID!: string;
    userID!: string;
    equipmentID!: string;
    equipment!: Equipment;
    movementBaseID!: string;
    movementBase!: MovementBase;
    movementModifierID?: string | undefined;
    movementModifier?: MovementModifier;
    createdAt?: Date;

    constructor(data?: IMovementData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.equipment = new Equipment();
            this.movementBase = new MovementBase();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementDataID = _data["movementDataID"];
            this.userID = _data["userID"];
            this.equipmentID = _data["equipmentID"];
            this.equipment = _data["equipment"] ? Equipment.fromJS(_data["equipment"]) : new Equipment();
            this.movementBaseID = _data["movementBaseID"];
            this.movementBase = _data["movementBase"] ? MovementBase.fromJS(_data["movementBase"]) : new MovementBase();
            this.movementModifierID = _data["movementModifierID"];
            this.movementModifier = _data["movementModifier"] ? MovementModifier.fromJS(_data["movementModifier"]) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MovementData {
        data = typeof data === 'object' ? data : {};
        let result = new MovementData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementDataID"] = this.movementDataID;
        data["userID"] = this.userID;
        data["equipmentID"] = this.equipmentID;
        data["equipment"] = this.equipment ? this.equipment.toJSON() : <any>undefined;
        data["movementBaseID"] = this.movementBaseID;
        data["movementBase"] = this.movementBase ? this.movementBase.toJSON() : <any>undefined;
        data["movementModifierID"] = this.movementModifierID;
        data["movementModifier"] = this.movementModifier ? this.movementModifier.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IMovementData {
    movementDataID: string;
    userID: string;
    equipmentID: string;
    equipment: Equipment;
    movementBaseID: string;
    movementBase: MovementBase;
    movementModifierID?: string | undefined;
    movementModifier?: MovementModifier;
    createdAt?: Date;
}

export class MovementDataDTO implements IMovementDataDTO {
    movementDataID?: string;
    equipmentID?: string;
    equipment?: EquipmentDTO;
    movementBaseID?: string;
    movementBase?: MovementBaseDTO;
    movementModifierID?: string | undefined;
    movementModifier?: MovementModifierDTO;

    constructor(data?: IMovementDataDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementDataID = _data["movementDataID"];
            this.equipmentID = _data["equipmentID"];
            this.equipment = _data["equipment"] ? EquipmentDTO.fromJS(_data["equipment"]) : <any>undefined;
            this.movementBaseID = _data["movementBaseID"];
            this.movementBase = _data["movementBase"] ? MovementBaseDTO.fromJS(_data["movementBase"]) : <any>undefined;
            this.movementModifierID = _data["movementModifierID"];
            this.movementModifier = _data["movementModifier"] ? MovementModifierDTO.fromJS(_data["movementModifier"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MovementDataDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MovementDataDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementDataID"] = this.movementDataID;
        data["equipmentID"] = this.equipmentID;
        data["equipment"] = this.equipment ? this.equipment.toJSON() : <any>undefined;
        data["movementBaseID"] = this.movementBaseID;
        data["movementBase"] = this.movementBase ? this.movementBase.toJSON() : <any>undefined;
        data["movementModifierID"] = this.movementModifierID;
        data["movementModifier"] = this.movementModifier ? this.movementModifier.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMovementDataDTO {
    movementDataID?: string;
    equipmentID?: string;
    equipment?: EquipmentDTO;
    movementBaseID?: string;
    movementBase?: MovementBaseDTO;
    movementModifierID?: string | undefined;
    movementModifier?: MovementModifierDTO;
}

export class MovementDataPRSummary implements IMovementDataPRSummary {
    movementDataID?: string;
    movementData?: MovementDataDTO;
    strengthPR?: PersonalRecordDTO;
    volumePR?: PersonalRecordDTO;
    lastPRDate?: Date | undefined;

    constructor(data?: IMovementDataPRSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementDataID = _data["movementDataID"];
            this.movementData = _data["movementData"] ? MovementDataDTO.fromJS(_data["movementData"]) : <any>undefined;
            this.strengthPR = _data["strengthPR"] ? PersonalRecordDTO.fromJS(_data["strengthPR"]) : <any>undefined;
            this.volumePR = _data["volumePR"] ? PersonalRecordDTO.fromJS(_data["volumePR"]) : <any>undefined;
            this.lastPRDate = _data["lastPRDate"] ? new Date(_data["lastPRDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MovementDataPRSummary {
        data = typeof data === 'object' ? data : {};
        let result = new MovementDataPRSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementDataID"] = this.movementDataID;
        data["movementData"] = this.movementData ? this.movementData.toJSON() : <any>undefined;
        data["strengthPR"] = this.strengthPR ? this.strengthPR.toJSON() : <any>undefined;
        data["volumePR"] = this.volumePR ? this.volumePR.toJSON() : <any>undefined;
        data["lastPRDate"] = this.lastPRDate ? this.lastPRDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IMovementDataPRSummary {
    movementDataID?: string;
    movementData?: MovementDataDTO;
    strengthPR?: PersonalRecordDTO;
    volumePR?: PersonalRecordDTO;
    lastPRDate?: Date | undefined;
}

export class MovementModifier implements IMovementModifier {
    movementModifierID!: string;
    name!: string;
    userID!: string;

    constructor(data?: IMovementModifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementModifierID = _data["movementModifierID"];
            this.name = _data["name"];
            this.userID = _data["userID"];
        }
    }

    static fromJS(data: any): MovementModifier {
        data = typeof data === 'object' ? data : {};
        let result = new MovementModifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementModifierID"] = this.movementModifierID;
        data["name"] = this.name;
        data["userID"] = this.userID;
        return data;
    }
}

export interface IMovementModifier {
    movementModifierID: string;
    name: string;
    userID: string;
}

export class MovementModifierDTO implements IMovementModifierDTO {
    movementModifierID?: string;
    name?: string | undefined;

    constructor(data?: IMovementModifierDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementModifierID = _data["movementModifierID"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MovementModifierDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MovementModifierDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementModifierID"] = this.movementModifierID;
        data["name"] = this.name;
        return data;
    }
}

export interface IMovementModifierDTO {
    movementModifierID?: string;
    name?: string | undefined;
}

export class MovementOrderUpdate implements IMovementOrderUpdate {
    movementID?: string;
    ordering?: number;

    constructor(data?: IMovementOrderUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementID = _data["movementID"];
            this.ordering = _data["ordering"];
        }
    }

    static fromJS(data: any): MovementOrderUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new MovementOrderUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementID"] = this.movementID;
        data["ordering"] = this.ordering;
        return data;
    }
}

export interface IMovementOrderUpdate {
    movementID?: string;
    ordering?: number;
}

export class MuscleGroup implements IMuscleGroup {
    muscleGroupID!: string;
    name!: string | undefined;

    constructor(data?: IMuscleGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.muscleGroupID = _data["muscleGroupID"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MuscleGroup {
        data = typeof data === 'object' ? data : {};
        let result = new MuscleGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muscleGroupID"] = this.muscleGroupID;
        data["name"] = this.name;
        return data;
    }
}

export interface IMuscleGroup {
    muscleGroupID: string;
    name: string | undefined;
}

export class PerceivedEffortRatings implements IPerceivedEffortRatings {
    recordedAt!: Date;
    accumulatedFatigue?: number | undefined;
    difficultyRating?: number | undefined;
    engagementRating?: number | undefined;
    externalVariablesRating?: number | undefined;

    constructor(data?: IPerceivedEffortRatings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recordedAt = _data["recordedAt"] ? new Date(_data["recordedAt"].toString()) : <any>undefined;
            this.accumulatedFatigue = _data["accumulatedFatigue"];
            this.difficultyRating = _data["difficultyRating"];
            this.engagementRating = _data["engagementRating"];
            this.externalVariablesRating = _data["externalVariablesRating"];
        }
    }

    static fromJS(data: any): PerceivedEffortRatings {
        data = typeof data === 'object' ? data : {};
        let result = new PerceivedEffortRatings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recordedAt"] = this.recordedAt ? this.recordedAt.toISOString() : <any>undefined;
        data["accumulatedFatigue"] = this.accumulatedFatigue;
        data["difficultyRating"] = this.difficultyRating;
        data["engagementRating"] = this.engagementRating;
        data["externalVariablesRating"] = this.externalVariablesRating;
        return data;
    }
}

export interface IPerceivedEffortRatings {
    recordedAt: Date;
    accumulatedFatigue?: number | undefined;
    difficultyRating?: number | undefined;
    engagementRating?: number | undefined;
    externalVariablesRating?: number | undefined;
}

export class PersonalRecord implements IPersonalRecord {
    personalRecordID!: string;
    userID!: string;
    movementDataID!: string;
    movementData!: MovementData;
    prType!: PersonalRecordType;
    weight!: number;
    weightUnit!: WeightUnit;
    reps!: number;
    readonly volume?: number;
    createdAt!: Date;
    previousPRCreatedAt?: Date | undefined;
    previousPersonalRecordID?: string | undefined;
    previousPersonalRecord?: PersonalRecord;
    sourceLiftSetEntryID?: string | undefined;
    sourceLiftSetEntry?: LiftSetEntry;
    isActive!: boolean;

    constructor(data?: IPersonalRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.movementData = new MovementData();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.personalRecordID = _data["personalRecordID"];
            this.userID = _data["userID"];
            this.movementDataID = _data["movementDataID"];
            this.movementData = _data["movementData"] ? MovementData.fromJS(_data["movementData"]) : new MovementData();
            this.prType = _data["prType"];
            this.weight = _data["weight"];
            this.weightUnit = _data["weightUnit"];
            this.reps = _data["reps"];
            (<any>this).volume = _data["volume"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.previousPRCreatedAt = _data["previousPRCreatedAt"] ? new Date(_data["previousPRCreatedAt"].toString()) : <any>undefined;
            this.previousPersonalRecordID = _data["previousPersonalRecordID"];
            this.previousPersonalRecord = _data["previousPersonalRecord"] ? PersonalRecord.fromJS(_data["previousPersonalRecord"]) : <any>undefined;
            this.sourceLiftSetEntryID = _data["sourceLiftSetEntryID"];
            this.sourceLiftSetEntry = _data["sourceLiftSetEntry"] ? LiftSetEntry.fromJS(_data["sourceLiftSetEntry"]) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PersonalRecord {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personalRecordID"] = this.personalRecordID;
        data["userID"] = this.userID;
        data["movementDataID"] = this.movementDataID;
        data["movementData"] = this.movementData ? this.movementData.toJSON() : <any>undefined;
        data["prType"] = this.prType;
        data["weight"] = this.weight;
        data["weightUnit"] = this.weightUnit;
        data["reps"] = this.reps;
        data["volume"] = this.volume;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["previousPRCreatedAt"] = this.previousPRCreatedAt ? this.previousPRCreatedAt.toISOString() : <any>undefined;
        data["previousPersonalRecordID"] = this.previousPersonalRecordID;
        data["previousPersonalRecord"] = this.previousPersonalRecord ? this.previousPersonalRecord.toJSON() : <any>undefined;
        data["sourceLiftSetEntryID"] = this.sourceLiftSetEntryID;
        data["sourceLiftSetEntry"] = this.sourceLiftSetEntry ? this.sourceLiftSetEntry.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IPersonalRecord {
    personalRecordID: string;
    userID: string;
    movementDataID: string;
    movementData: MovementData;
    prType: PersonalRecordType;
    weight: number;
    weightUnit: WeightUnit;
    reps: number;
    volume?: number;
    createdAt: Date;
    previousPRCreatedAt?: Date | undefined;
    previousPersonalRecordID?: string | undefined;
    previousPersonalRecord?: PersonalRecord;
    sourceLiftSetEntryID?: string | undefined;
    sourceLiftSetEntry?: LiftSetEntry;
    isActive: boolean;
}

export class PersonalRecordDTO implements IPersonalRecordDTO {
    personalRecordID?: string;
    userID?: string;
    movementDataID?: string;
    movementData?: MovementDataDTO;
    prType?: PersonalRecordType;
    weight?: number;
    weightUnit?: WeightUnit;
    reps?: number;
    volume?: number;
    createdAt?: Date;
    previousPRCreatedAt?: Date | undefined;
    previousPersonalRecordID?: string | undefined;
    sourceLiftSetEntryID?: string | undefined;
    isActive?: boolean;

    constructor(data?: IPersonalRecordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.personalRecordID = _data["personalRecordID"];
            this.userID = _data["userID"];
            this.movementDataID = _data["movementDataID"];
            this.movementData = _data["movementData"] ? MovementDataDTO.fromJS(_data["movementData"]) : <any>undefined;
            this.prType = _data["prType"];
            this.weight = _data["weight"];
            this.weightUnit = _data["weightUnit"];
            this.reps = _data["reps"];
            this.volume = _data["volume"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.previousPRCreatedAt = _data["previousPRCreatedAt"] ? new Date(_data["previousPRCreatedAt"].toString()) : <any>undefined;
            this.previousPersonalRecordID = _data["previousPersonalRecordID"];
            this.sourceLiftSetEntryID = _data["sourceLiftSetEntryID"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PersonalRecordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalRecordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personalRecordID"] = this.personalRecordID;
        data["userID"] = this.userID;
        data["movementDataID"] = this.movementDataID;
        data["movementData"] = this.movementData ? this.movementData.toJSON() : <any>undefined;
        data["prType"] = this.prType;
        data["weight"] = this.weight;
        data["weightUnit"] = this.weightUnit;
        data["reps"] = this.reps;
        data["volume"] = this.volume;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["previousPRCreatedAt"] = this.previousPRCreatedAt ? this.previousPRCreatedAt.toISOString() : <any>undefined;
        data["previousPersonalRecordID"] = this.previousPersonalRecordID;
        data["sourceLiftSetEntryID"] = this.sourceLiftSetEntryID;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IPersonalRecordDTO {
    personalRecordID?: string;
    userID?: string;
    movementDataID?: string;
    movementData?: MovementDataDTO;
    prType?: PersonalRecordType;
    weight?: number;
    weightUnit?: WeightUnit;
    reps?: number;
    volume?: number;
    createdAt?: Date;
    previousPRCreatedAt?: Date | undefined;
    previousPersonalRecordID?: string | undefined;
    sourceLiftSetEntryID?: string | undefined;
    isActive?: boolean;
}

export enum PersonalRecordType {
    _0 = 0,
    _1 = 1,
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class ReadinessData implements IReadinessData {
    readinessScore?: number;
    temperatureDeviation?: number;
    activityBalance?: number;
    bodyTemperature?: number;
    hrvBalance?: number;
    previousDayActivity?: number;
    previousNight?: number;
    recoveryIndex?: number;
    restingHeartRate?: number;
    sleepBalance?: number;

    constructor(data?: IReadinessData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.readinessScore = _data["readinessScore"];
            this.temperatureDeviation = _data["temperatureDeviation"];
            this.activityBalance = _data["activityBalance"];
            this.bodyTemperature = _data["bodyTemperature"];
            this.hrvBalance = _data["hrvBalance"];
            this.previousDayActivity = _data["previousDayActivity"];
            this.previousNight = _data["previousNight"];
            this.recoveryIndex = _data["recoveryIndex"];
            this.restingHeartRate = _data["restingHeartRate"];
            this.sleepBalance = _data["sleepBalance"];
        }
    }

    static fromJS(data: any): ReadinessData {
        data = typeof data === 'object' ? data : {};
        let result = new ReadinessData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["readinessScore"] = this.readinessScore;
        data["temperatureDeviation"] = this.temperatureDeviation;
        data["activityBalance"] = this.activityBalance;
        data["bodyTemperature"] = this.bodyTemperature;
        data["hrvBalance"] = this.hrvBalance;
        data["previousDayActivity"] = this.previousDayActivity;
        data["previousNight"] = this.previousNight;
        data["recoveryIndex"] = this.recoveryIndex;
        data["restingHeartRate"] = this.restingHeartRate;
        data["sleepBalance"] = this.sleepBalance;
        return data;
    }
}

export interface IReadinessData {
    readinessScore?: number;
    temperatureDeviation?: number;
    activityBalance?: number;
    bodyTemperature?: number;
    hrvBalance?: number;
    previousDayActivity?: number;
    previousNight?: number;
    recoveryIndex?: number;
    restingHeartRate?: number;
    sleepBalance?: number;
}

export class RefreshRequest implements IRefreshRequest {
    refreshToken!: string | undefined;

    constructor(data?: IRefreshRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshRequest {
    refreshToken: string | undefined;
}

export class RegisterRequest implements IRegisterRequest {
    email!: string | undefined;
    password!: string | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterRequest {
    email: string | undefined;
    password: string | undefined;
}

export class ResendConfirmationEmailRequest implements IResendConfirmationEmailRequest {
    email!: string | undefined;

    constructor(data?: IResendConfirmationEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResendConfirmationEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResendConfirmationEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IResendConfirmationEmailRequest {
    email: string | undefined;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    email!: string | undefined;
    resetCode!: string | undefined;
    newPassword!: string | undefined;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.resetCode = _data["resetCode"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["resetCode"] = this.resetCode;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordRequest {
    email: string | undefined;
    resetCode: string | undefined;
    newPassword: string | undefined;
}

export class ResilienceData implements IResilienceData {
    sleepRecovery?: number;
    daytimeRecovery?: number;
    stress?: number;
    resilienceLevel?: string | undefined;

    constructor(data?: IResilienceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sleepRecovery = _data["sleepRecovery"];
            this.daytimeRecovery = _data["daytimeRecovery"];
            this.stress = _data["stress"];
            this.resilienceLevel = _data["resilienceLevel"];
        }
    }

    static fromJS(data: any): ResilienceData {
        data = typeof data === 'object' ? data : {};
        let result = new ResilienceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sleepRecovery"] = this.sleepRecovery;
        data["daytimeRecovery"] = this.daytimeRecovery;
        data["stress"] = this.stress;
        data["resilienceLevel"] = this.resilienceLevel;
        return data;
    }
}

export interface IResilienceData {
    sleepRecovery?: number;
    daytimeRecovery?: number;
    stress?: number;
    resilienceLevel?: string | undefined;
}

export class SleepData implements ISleepData {
    sleepScore?: number;
    deepSleep?: number;
    efficiency?: number;
    latency?: number;
    remSleep?: number;
    restfulness?: number;
    timing?: number;
    totalSleep?: number;

    constructor(data?: ISleepData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sleepScore = _data["sleepScore"];
            this.deepSleep = _data["deepSleep"];
            this.efficiency = _data["efficiency"];
            this.latency = _data["latency"];
            this.remSleep = _data["remSleep"];
            this.restfulness = _data["restfulness"];
            this.timing = _data["timing"];
            this.totalSleep = _data["totalSleep"];
        }
    }

    static fromJS(data: any): SleepData {
        data = typeof data === 'object' ? data : {};
        let result = new SleepData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sleepScore"] = this.sleepScore;
        data["deepSleep"] = this.deepSleep;
        data["efficiency"] = this.efficiency;
        data["latency"] = this.latency;
        data["remSleep"] = this.remSleep;
        data["restfulness"] = this.restfulness;
        data["timing"] = this.timing;
        data["totalSleep"] = this.totalSleep;
        return data;
    }
}

export interface ISleepData {
    sleepScore?: number;
    deepSleep?: number;
    efficiency?: number;
    latency?: number;
    remSleep?: number;
    restfulness?: number;
    timing?: number;
    totalSleep?: number;
}

export class TrainingProgram implements ITrainingProgram {
    trainingProgramID!: string;
    userID!: string;
    title!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    isCompleted!: boolean;
    trainingSessions!: TrainingSession[] | undefined;
    tags!: string[] | undefined;

    constructor(data?: ITrainingProgram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingProgramID = _data["trainingProgramID"];
            this.userID = _data["userID"];
            this.title = _data["title"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.isCompleted = _data["isCompleted"];
            if (Array.isArray(_data["trainingSessions"])) {
                this.trainingSessions = [] as any;
                for (let item of _data["trainingSessions"])
                    this.trainingSessions!.push(TrainingSession.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): TrainingProgram {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingProgram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramID"] = this.trainingProgramID;
        data["userID"] = this.userID;
        data["title"] = this.title;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        data["isCompleted"] = this.isCompleted;
        if (Array.isArray(this.trainingSessions)) {
            data["trainingSessions"] = [];
            for (let item of this.trainingSessions)
                data["trainingSessions"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface ITrainingProgram {
    trainingProgramID: string;
    userID: string;
    title: string | undefined;
    startDate: Date;
    endDate: Date;
    isCompleted: boolean;
    trainingSessions: TrainingSession[] | undefined;
    tags: string[] | undefined;
}

export class TrainingProgramDTO implements ITrainingProgramDTO {
    trainingProgramID!: string;
    title!: string;
    startDate!: Date;
    endDate!: Date;
    isCompleted!: boolean;
    trainingSessions!: TrainingSessionDTO[];
    tags!: string[];

    constructor(data?: ITrainingProgramDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.trainingSessions = [];
            this.tags = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingProgramID = _data["trainingProgramID"];
            this.title = _data["title"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.isCompleted = _data["isCompleted"];
            if (Array.isArray(_data["trainingSessions"])) {
                this.trainingSessions = [] as any;
                for (let item of _data["trainingSessions"])
                    this.trainingSessions!.push(TrainingSessionDTO.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): TrainingProgramDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingProgramDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramID"] = this.trainingProgramID;
        data["title"] = this.title;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        data["isCompleted"] = this.isCompleted;
        if (Array.isArray(this.trainingSessions)) {
            data["trainingSessions"] = [];
            for (let item of this.trainingSessions)
                data["trainingSessions"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface ITrainingProgramDTO {
    trainingProgramID: string;
    title: string;
    startDate: Date;
    endDate: Date;
    isCompleted: boolean;
    trainingSessions: TrainingSessionDTO[];
    tags: string[];
}

export class TrainingSession implements ITrainingSession {
    trainingSessionID!: string;
    userID!: string;
    trainingProgramID?: string | undefined;
    trainingProgram?: TrainingProgram;
    date!: Date;
    status!: TrainingSessionStatus;
    movements!: Movement[] | undefined;
    creationTime!: Date;
    notes!: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;

    constructor(data?: ITrainingSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            this.userID = _data["userID"];
            this.trainingProgramID = _data["trainingProgramID"];
            this.trainingProgram = _data["trainingProgram"] ? TrainingProgram.fromJS(_data["trainingProgram"]) : <any>undefined;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            if (Array.isArray(_data["movements"])) {
                this.movements = [] as any;
                for (let item of _data["movements"])
                    this.movements!.push(Movement.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.perceivedEffortRatings = _data["perceivedEffortRatings"] ? PerceivedEffortRatings.fromJS(_data["perceivedEffortRatings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingSession {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        data["userID"] = this.userID;
        data["trainingProgramID"] = this.trainingProgramID;
        data["trainingProgram"] = this.trainingProgram ? this.trainingProgram.toJSON() : <any>undefined;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["status"] = this.status;
        if (Array.isArray(this.movements)) {
            data["movements"] = [];
            for (let item of this.movements)
                data["movements"].push(item ? item.toJSON() : <any>undefined);
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["perceivedEffortRatings"] = this.perceivedEffortRatings ? this.perceivedEffortRatings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITrainingSession {
    trainingSessionID: string;
    userID: string;
    trainingProgramID?: string | undefined;
    trainingProgram?: TrainingProgram;
    date: Date;
    status: TrainingSessionStatus;
    movements: Movement[] | undefined;
    creationTime: Date;
    notes: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;
}

export class TrainingSessionDTO implements ITrainingSessionDTO {
    trainingSessionID?: string;
    trainingProgramID?: string | undefined;
    date?: Date;
    status?: TrainingSessionStatus;
    movements?: MovementDTO[] | undefined;
    creationTime?: Date;
    notes?: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;

    constructor(data?: ITrainingSessionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            this.trainingProgramID = _data["trainingProgramID"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            if (Array.isArray(_data["movements"])) {
                this.movements = [] as any;
                for (let item of _data["movements"])
                    this.movements!.push(MovementDTO.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.perceivedEffortRatings = _data["perceivedEffortRatings"] ? PerceivedEffortRatings.fromJS(_data["perceivedEffortRatings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingSessionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSessionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        data["trainingProgramID"] = this.trainingProgramID;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["status"] = this.status;
        if (Array.isArray(this.movements)) {
            data["movements"] = [];
            for (let item of this.movements)
                data["movements"].push(item ? item.toJSON() : <any>undefined);
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["perceivedEffortRatings"] = this.perceivedEffortRatings ? this.perceivedEffortRatings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITrainingSessionDTO {
    trainingSessionID?: string;
    trainingProgramID?: string | undefined;
    date?: Date;
    status?: TrainingSessionStatus;
    movements?: MovementDTO[] | undefined;
    creationTime?: Date;
    notes?: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;
}

export enum TrainingSessionStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class TwoFactorRequest implements ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;

    constructor(data?: ITwoFactorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enable = _data["enable"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.resetSharedKey = _data["resetSharedKey"];
            this.resetRecoveryCodes = _data["resetRecoveryCodes"];
            this.forgetMachine = _data["forgetMachine"];
        }
    }

    static fromJS(data: any): TwoFactorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enable"] = this.enable;
        data["twoFactorCode"] = this.twoFactorCode;
        data["resetSharedKey"] = this.resetSharedKey;
        data["resetRecoveryCodes"] = this.resetRecoveryCodes;
        data["forgetMachine"] = this.forgetMachine;
        return data;
    }
}

export interface ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;
}

export class TwoFactorResponse implements ITwoFactorResponse {
    sharedKey!: string | undefined;
    recoveryCodesLeft!: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled!: boolean;
    isMachineRemembered!: boolean;

    constructor(data?: ITwoFactorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sharedKey = _data["sharedKey"];
            this.recoveryCodesLeft = _data["recoveryCodesLeft"];
            if (Array.isArray(_data["recoveryCodes"])) {
                this.recoveryCodes = [] as any;
                for (let item of _data["recoveryCodes"])
                    this.recoveryCodes!.push(item);
            }
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isMachineRemembered = _data["isMachineRemembered"];
        }
    }

    static fromJS(data: any): TwoFactorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sharedKey"] = this.sharedKey;
        data["recoveryCodesLeft"] = this.recoveryCodesLeft;
        if (Array.isArray(this.recoveryCodes)) {
            data["recoveryCodes"] = [];
            for (let item of this.recoveryCodes)
                data["recoveryCodes"].push(item);
        }
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isMachineRemembered"] = this.isMachineRemembered;
        return data;
    }
}

export interface ITwoFactorResponse {
    sharedKey: string | undefined;
    recoveryCodesLeft: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled: boolean;
    isMachineRemembered: boolean;
}

export class UpdateActivityRequest implements IUpdateActivityRequest {
    activityID?: string;
    dateTime?: Date;
    timeInMinutes?: number;
    caloriesBurned?: number;
    name?: string | undefined;
    userSummary?: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;

    constructor(data?: IUpdateActivityRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityID = _data["activityID"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.timeInMinutes = _data["timeInMinutes"];
            this.caloriesBurned = _data["caloriesBurned"];
            this.name = _data["name"];
            this.userSummary = _data["userSummary"];
            this.perceivedEffortRatings = _data["perceivedEffortRatings"] ? PerceivedEffortRatings.fromJS(_data["perceivedEffortRatings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateActivityRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateActivityRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityID"] = this.activityID;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["timeInMinutes"] = this.timeInMinutes;
        data["caloriesBurned"] = this.caloriesBurned;
        data["name"] = this.name;
        data["userSummary"] = this.userSummary;
        data["perceivedEffortRatings"] = this.perceivedEffortRatings ? this.perceivedEffortRatings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateActivityRequest {
    activityID?: string;
    dateTime?: Date;
    timeInMinutes?: number;
    caloriesBurned?: number;
    name?: string | undefined;
    userSummary?: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;
}

export class UpdateChatConversationRequest implements IUpdateChatConversationRequest {
    chatConversationID!: string;
    name!: string | undefined;

    constructor(data?: IUpdateChatConversationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatConversationID = _data["chatConversationID"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateChatConversationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateChatConversationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatConversationID"] = this.chatConversationID;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateChatConversationRequest {
    chatConversationID: string;
    name: string | undefined;
}

export class UpdateDTSetEntryRequest implements IUpdateDTSetEntryRequest {
    setEntryID?: string;
    movementID?: string;
    recommendedDistance?: number;
    actualDistance?: number;
    intervalDuration?: string;
    targetPace?: string;
    actualPace?: string;
    recommendedDuration?: string;
    actualDuration?: string;
    recommendedRest?: string;
    actualRest?: string;
    intervalType?: IntervalType;
    distanceUnit?: DistanceUnit;
    actualRPE?: number;

    constructor(data?: IUpdateDTSetEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryID = _data["setEntryID"];
            this.movementID = _data["movementID"];
            this.recommendedDistance = _data["recommendedDistance"];
            this.actualDistance = _data["actualDistance"];
            this.intervalDuration = _data["intervalDuration"];
            this.targetPace = _data["targetPace"];
            this.actualPace = _data["actualPace"];
            this.recommendedDuration = _data["recommendedDuration"];
            this.actualDuration = _data["actualDuration"];
            this.recommendedRest = _data["recommendedRest"];
            this.actualRest = _data["actualRest"];
            this.intervalType = _data["intervalType"];
            this.distanceUnit = _data["distanceUnit"];
            this.actualRPE = _data["actualRPE"];
        }
    }

    static fromJS(data: any): UpdateDTSetEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDTSetEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryID"] = this.setEntryID;
        data["movementID"] = this.movementID;
        data["recommendedDistance"] = this.recommendedDistance;
        data["actualDistance"] = this.actualDistance;
        data["intervalDuration"] = this.intervalDuration;
        data["targetPace"] = this.targetPace;
        data["actualPace"] = this.actualPace;
        data["recommendedDuration"] = this.recommendedDuration;
        data["actualDuration"] = this.actualDuration;
        data["recommendedRest"] = this.recommendedRest;
        data["actualRest"] = this.actualRest;
        data["intervalType"] = this.intervalType;
        data["distanceUnit"] = this.distanceUnit;
        data["actualRPE"] = this.actualRPE;
        return data;
    }
}

export interface IUpdateDTSetEntryRequest {
    setEntryID?: string;
    movementID?: string;
    recommendedDistance?: number;
    actualDistance?: number;
    intervalDuration?: string;
    targetPace?: string;
    actualPace?: string;
    recommendedDuration?: string;
    actualDuration?: string;
    recommendedRest?: string;
    actualRest?: string;
    intervalType?: IntervalType;
    distanceUnit?: DistanceUnit;
    actualRPE?: number;
}

export class UpdateEquipmentRequest implements IUpdateEquipmentRequest {
    equipmentID?: string;
    name?: string | undefined;
    enabled?: boolean;

    constructor(data?: IUpdateEquipmentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentID = _data["equipmentID"];
            this.name = _data["name"];
            this.enabled = _data["enabled"];
        }
    }

    static fromJS(data: any): UpdateEquipmentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEquipmentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentID"] = this.equipmentID;
        data["name"] = this.name;
        data["enabled"] = this.enabled;
        return data;
    }
}

export interface IUpdateEquipmentRequest {
    equipmentID?: string;
    name?: string | undefined;
    enabled?: boolean;
}

export class UpdateInjuryEventRequest implements IUpdateInjuryEventRequest {
    trainingSessionID?: string | undefined;
    injuryEventID!: string;
    painLevel!: number;
    injuryType!: InjuryEventType;
    notes!: string;
    movementIDs!: string[];

    constructor(data?: IUpdateInjuryEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.movementIDs = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            this.injuryEventID = _data["injuryEventID"];
            this.painLevel = _data["painLevel"];
            this.injuryType = _data["injuryType"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["movementIDs"])) {
                this.movementIDs = [] as any;
                for (let item of _data["movementIDs"])
                    this.movementIDs!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateInjuryEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInjuryEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        data["injuryEventID"] = this.injuryEventID;
        data["painLevel"] = this.painLevel;
        data["injuryType"] = this.injuryType;
        data["notes"] = this.notes;
        if (Array.isArray(this.movementIDs)) {
            data["movementIDs"] = [];
            for (let item of this.movementIDs)
                data["movementIDs"].push(item);
        }
        return data;
    }
}

export interface IUpdateInjuryEventRequest {
    trainingSessionID?: string | undefined;
    injuryEventID: string;
    painLevel: number;
    injuryType: InjuryEventType;
    notes: string;
    movementIDs: string[];
}

export class UpdateInjuryRequest implements IUpdateInjuryRequest {
    injuryID!: string;
    name!: string;
    notes!: string;
    isActive!: boolean;

    constructor(data?: IUpdateInjuryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.injuryID = _data["injuryID"];
            this.name = _data["name"];
            this.notes = _data["notes"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateInjuryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInjuryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["injuryID"] = this.injuryID;
        data["name"] = this.name;
        data["notes"] = this.notes;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateInjuryRequest {
    injuryID: string;
    name: string;
    notes: string;
    isActive: boolean;
}

export class UpdateLiftSetEntryRequest implements IUpdateLiftSetEntryRequest {
    setEntryID?: string;
    movementID?: string;
    recommendedReps?: number | undefined;
    recommendedWeight?: number | undefined;
    recommendedRPE?: number | undefined;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit?: WeightUnit;

    constructor(data?: IUpdateLiftSetEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryID = _data["setEntryID"];
            this.movementID = _data["movementID"];
            this.recommendedReps = _data["recommendedReps"];
            this.recommendedWeight = _data["recommendedWeight"];
            this.recommendedRPE = _data["recommendedRPE"];
            this.actualReps = _data["actualReps"];
            this.actualWeight = _data["actualWeight"];
            this.actualRPE = _data["actualRPE"];
            this.weightUnit = _data["weightUnit"];
        }
    }

    static fromJS(data: any): UpdateLiftSetEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLiftSetEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryID"] = this.setEntryID;
        data["movementID"] = this.movementID;
        data["recommendedReps"] = this.recommendedReps;
        data["recommendedWeight"] = this.recommendedWeight;
        data["recommendedRPE"] = this.recommendedRPE;
        data["actualReps"] = this.actualReps;
        data["actualWeight"] = this.actualWeight;
        data["actualRPE"] = this.actualRPE;
        data["weightUnit"] = this.weightUnit;
        return data;
    }
}

export interface IUpdateLiftSetEntryRequest {
    setEntryID?: string;
    movementID?: string;
    recommendedReps?: number | undefined;
    recommendedWeight?: number | undefined;
    recommendedRPE?: number | undefined;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit?: WeightUnit;
}

export class UpdateMovementBaseRequest implements IUpdateMovementBaseRequest {
    movementBaseID?: string;
    name?: string | undefined;
    description?: string | undefined;
    muscleGroups?: MuscleGroup[] | undefined;

    constructor(data?: IUpdateMovementBaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementBaseID = _data["movementBaseID"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["muscleGroups"])) {
                this.muscleGroups = [] as any;
                for (let item of _data["muscleGroups"])
                    this.muscleGroups!.push(MuscleGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateMovementBaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMovementBaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementBaseID"] = this.movementBaseID;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.muscleGroups)) {
            data["muscleGroups"] = [];
            for (let item of this.muscleGroups)
                data["muscleGroups"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IUpdateMovementBaseRequest {
    movementBaseID?: string;
    name?: string | undefined;
    description?: string | undefined;
    muscleGroups?: MuscleGroup[] | undefined;
}

export class UpdateMovementOrderRequest implements IUpdateMovementOrderRequest {
    trainingSessionID?: string;
    movements?: MovementOrderUpdate[] | undefined;

    constructor(data?: IUpdateMovementOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            if (Array.isArray(_data["movements"])) {
                this.movements = [] as any;
                for (let item of _data["movements"])
                    this.movements!.push(MovementOrderUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateMovementOrderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMovementOrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        if (Array.isArray(this.movements)) {
            data["movements"] = [];
            for (let item of this.movements)
                data["movements"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IUpdateMovementOrderRequest {
    trainingSessionID?: string;
    movements?: MovementOrderUpdate[] | undefined;
}

export class UpdateMovementRequest implements IUpdateMovementRequest {
    movementID?: string;
    movementData?: CreateMovementDataRequest;
    notes?: string | undefined;
    isCompleted?: boolean;

    constructor(data?: IUpdateMovementRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementID = _data["movementID"];
            this.movementData = _data["movementData"] ? CreateMovementDataRequest.fromJS(_data["movementData"]) : <any>undefined;
            this.notes = _data["notes"];
            this.isCompleted = _data["isCompleted"];
        }
    }

    static fromJS(data: any): UpdateMovementRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMovementRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementID"] = this.movementID;
        data["movementData"] = this.movementData ? this.movementData.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        data["isCompleted"] = this.isCompleted;
        return data;
    }
}

export interface IUpdateMovementRequest {
    movementID?: string;
    movementData?: CreateMovementDataRequest;
    notes?: string | undefined;
    isCompleted?: boolean;
}

export class UpdateTrainingProgramRequest implements IUpdateTrainingProgramRequest {
    trainingProgramID?: string;
    title?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    isCompleted?: boolean;
    tags?: string[] | undefined;

    constructor(data?: IUpdateTrainingProgramRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingProgramID = _data["trainingProgramID"];
            this.title = _data["title"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.isCompleted = _data["isCompleted"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateTrainingProgramRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTrainingProgramRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramID"] = this.trainingProgramID;
        data["title"] = this.title;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isCompleted"] = this.isCompleted;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface IUpdateTrainingProgramRequest {
    trainingProgramID?: string;
    title?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    isCompleted?: boolean;
    tags?: string[] | undefined;
}

export class UpdateTrainingSessionRequest implements IUpdateTrainingSessionRequest {
    trainingSessionID?: string;
    trainingProgramID?: string | undefined;
    date?: Date;
    status?: TrainingSessionStatus;
    notes?: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;

    constructor(data?: IUpdateTrainingSessionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            this.trainingProgramID = _data["trainingProgramID"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.notes = _data["notes"];
            this.perceivedEffortRatings = _data["perceivedEffortRatings"] ? PerceivedEffortRatings.fromJS(_data["perceivedEffortRatings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateTrainingSessionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTrainingSessionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        data["trainingProgramID"] = this.trainingProgramID;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["notes"] = this.notes;
        data["perceivedEffortRatings"] = this.perceivedEffortRatings ? this.perceivedEffortRatings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateTrainingSessionRequest {
    trainingSessionID?: string;
    trainingProgramID?: string | undefined;
    date?: Date;
    status?: TrainingSessionStatus;
    notes?: string | undefined;
    perceivedEffortRatings?: PerceivedEffortRatings;
}

export enum WeightUnit {
    _0 = 0,
    _1 = 1,
}

export class WellnessState implements IWellnessState {
    stateID?: string;
    userID?: string;
    date?: Date;
    motivationScore?: number;
    stressScore?: number;
    moodScore?: number;
    energyScore?: number;
    overallScore?: number;

    constructor(data?: IWellnessState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stateID = _data["stateID"];
            this.userID = _data["userID"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.motivationScore = _data["motivationScore"];
            this.stressScore = _data["stressScore"];
            this.moodScore = _data["moodScore"];
            this.energyScore = _data["energyScore"];
            this.overallScore = _data["overallScore"];
        }
    }

    static fromJS(data: any): WellnessState {
        data = typeof data === 'object' ? data : {};
        let result = new WellnessState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stateID"] = this.stateID;
        data["userID"] = this.userID;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["motivationScore"] = this.motivationScore;
        data["stressScore"] = this.stressScore;
        data["moodScore"] = this.moodScore;
        data["energyScore"] = this.energyScore;
        data["overallScore"] = this.overallScore;
        return data;
    }
}

export interface IWellnessState {
    stateID?: string;
    userID?: string;
    date?: Date;
    motivationScore?: number;
    stressScore?: number;
    moodScore?: number;
    energyScore?: number;
    overallScore?: number;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}