//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AddActivityEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    addActivity(body: CreateActivityRequest | undefined): Promise<Activity> {
        let url_ = this.baseUrl + "/api/activity/add-activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddActivity(_response);
        });
    }

    protected processAddActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Activity.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = Activity.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }
}

export class AddLiftActivityEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    addLiftActivity(body: CreateLiftRequest | undefined): Promise<Activity> {
        let url_ = this.baseUrl + "/api/activity/add-lift-activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddLiftActivity(_response);
        });
    }

    protected processAddLiftActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Activity.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = Activity.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }
}

export class AddRideActivityEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    addRideActivity(body: CreateRideRequest | undefined): Promise<Activity> {
        let url_ = this.baseUrl + "/api/activity/add-ride-activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddRideActivity(_response);
        });
    }

    protected processAddRideActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Activity.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = Activity.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }
}

export class AddRunWalkActivityEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    addRunwalkActivity(body: CreateRunWalkRequest | undefined): Promise<Activity> {
        let url_ = this.baseUrl + "/api/activity/add-runwalk-activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddRunwalkActivity(_response);
        });
    }

    protected processAddRunwalkActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Activity.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = Activity.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }
}

export class AddWellnessStateEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    add(body: CreateWellnessStateRequest | undefined): Promise<Activity> {
        let url_ = this.baseUrl + "/api/wellness/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Activity.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = Activity.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }
}

export class CreateEquipmentEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create(body: CreateEquipmentRequest | undefined): Promise<Equipment> {
        let url_ = this.baseUrl + "/api/equipment/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<Equipment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Equipment.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Equipment>(null as any);
    }
}

export class CreateMovementBaseEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create2(body: CreateMovementBaseRequest | undefined): Promise<MovementBase> {
        let url_ = this.baseUrl + "/api/movement-base/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate2(_response);
        });
    }

    protected processCreate2(response: Response): Promise<MovementBase> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MovementBase.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementBase>(null as any);
    }
}

export class CreateMovementEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create3(body: CreateMovementRequest | undefined): Promise<MovementDTO> {
        let url_ = this.baseUrl + "/api/movement/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate3(_response);
        });
    }

    protected processCreate3(response: Response): Promise<MovementDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MovementDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementDTO>(null as any);
    }
}

export class CreateProfileEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    createProfile(body: CreateProfileRequest | undefined): Promise<LionheartUser> {
        let url_ = this.baseUrl + "/api/user/create-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProfile(_response);
        });
    }

    protected processCreateProfile(response: Response): Promise<LionheartUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = LionheartUser.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LionheartUser>(null as any);
    }
}

export class CreateSetEntryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create4(body: CreateSetEntryRequest | undefined): Promise<SetEntryDTO> {
        let url_ = this.baseUrl + "/api/set-entry/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate4(_response);
        });
    }

    protected processCreate4(response: Response): Promise<SetEntryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SetEntryDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetEntryDTO>(null as any);
    }
}

export class CreateTrainingProgramEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create5(body: CreateTrainingProgramRequest | undefined): Promise<TrainingProgramDTO> {
        let url_ = this.baseUrl + "/api/training-program/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate5(_response);
        });
    }

    protected processCreate5(response: Response): Promise<TrainingProgramDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingProgramDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingProgramDTO>(null as any);
    }
}

export class CreateTrainingProgramFromJSONEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    createFromJson(body: TrainingProgramDTO | undefined): Promise<TrainingProgramDTO> {
        let url_ = this.baseUrl + "/api/training-program/create-from-json";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFromJson(_response);
        });
    }

    protected processCreateFromJson(response: Response): Promise<TrainingProgramDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingProgramDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingProgramDTO>(null as any);
    }
}

export class CreateTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create6(body: CreateTrainingSessionRequest | undefined): Promise<TrainingSessionDTO> {
        let url_ = this.baseUrl + "/api/training-session/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate6(_response);
        });
    }

    protected processCreate6(response: Response): Promise<TrainingSessionDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingSessionDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO>(null as any);
    }
}

export class CreateTrainingSessionFromJSONEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    createFromJson2(body: TrainingSessionDTO | undefined): Promise<TrainingSessionDTO> {
        let url_ = this.baseUrl + "/api/training-session/create-from-json";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFromJson2(_response);
        });
    }

    protected processCreateFromJson2(response: Response): Promise<TrainingSessionDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingSessionDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO>(null as any);
    }
}

export class DeleteEquipmentEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete(equipmentId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/equipment/delete/{equipmentId}";
        if (equipmentId === undefined || equipmentId === null)
            throw new Error("The parameter 'equipmentId' must be defined.");
        url_ = url_.replace("{equipmentId}", encodeURIComponent("" + equipmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteMovementBaseEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete2(movementBaseId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/movement-base/delete/{movementBaseId}";
        if (movementBaseId === undefined || movementBaseId === null)
            throw new Error("The parameter 'movementBaseId' must be defined.");
        url_ = url_.replace("{movementBaseId}", encodeURIComponent("" + movementBaseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete2(_response);
        });
    }

    protected processDelete2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteMovementEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete3(movementId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/movement/delete/{movementId}";
        if (movementId === undefined || movementId === null)
            throw new Error("The parameter 'movementId' must be defined.");
        url_ = url_.replace("{movementId}", encodeURIComponent("" + movementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete3(_response);
        });
    }

    protected processDelete3(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteSetEntryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete4(setEntryId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/set-entry/delete/{setEntryId}";
        if (setEntryId === undefined || setEntryId === null)
            throw new Error("The parameter 'setEntryId' must be defined.");
        url_ = url_.replace("{setEntryId}", encodeURIComponent("" + setEntryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete4(_response);
        });
    }

    protected processDelete4(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteTrainingProgramEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete5(programId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/training-program/delete/{programId}";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete5(_response);
        });
    }

    protected processDelete5(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete6(trainingSessionId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/training-session/delete/{trainingSessionId}";
        if (trainingSessionId === undefined || trainingSessionId === null)
            throw new Error("The parameter 'trainingSessionId' must be defined.");
        url_ = url_.replace("{trainingSessionId}", encodeURIComponent("" + trainingSessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete6(_response);
        });
    }

    protected processDelete6(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DuplicateTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    duplicate(trainingSessionId: string): Promise<TrainingSessionDTO> {
        let url_ = this.baseUrl + "/api/training-session/duplicate/{trainingSessionId}";
        if (trainingSessionId === undefined || trainingSessionId === null)
            throw new Error("The parameter 'trainingSessionId' must be defined.");
        url_ = url_.replace("{trainingSessionId}", encodeURIComponent("" + trainingSessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDuplicate(_response);
        });
    }

    protected processDuplicate(response: Response): Promise<TrainingSessionDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSessionDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO>(null as any);
    }
}

export class GenerateProgramFirstWeekEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    firstWeek(body: FirstWeekGenerationDTO | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/ai/program/first-week";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFirstWeek(_response);
        });
    }

    protected processFirstWeek(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class GenerateProgramPreferencesEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    preferences(body: ProgramPreferencesDTO | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ai/program/preferences";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPreferences(_response);
        });
    }

    protected processPreferences(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class GenerateProgramRemainingWeeksEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    continueWeeks(body: RemainingWeeksGenerationDTO | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/ai/program/continue-weeks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContinueWeeks(_response);
        });
    }

    protected processContinueWeeks(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class GetActivitiesEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getActivities(startDate: Date, endDate: Date): Promise<Activity[]> {
        let url_ = this.baseUrl + "/api/activity/get-activities?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivities(_response);
        });
    }

    protected processGetActivities(response: Response): Promise<Activity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Activity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData401)) {
                result401 = [] as any;
                for (let item of resultData401)
                    result401!.push(Activity.fromJS(item));
            }
            else {
                result401 = <any>null;
            }
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity[]>(null as any);
    }
}

export class GetActivityMinutesEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getActivityMinutes(startDate: Date, endDate: Date): Promise<number> {
        let url_ = this.baseUrl + "/api/activity/get-activity-minutes?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivityMinutes(_response);
        });
    }

    protected processGetActivityMinutes(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }
}

export class GetActivityTypeRatioEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getActivityTypeRatio(startDate: Date, endDate: Date): Promise<ActivityTypeRatioDto> {
        let url_ = this.baseUrl + "/api/activity/get-activity-type-ratio?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivityTypeRatio(_response);
        });
    }

    protected processGetActivityTypeRatio(response: Response): Promise<ActivityTypeRatioDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityTypeRatioDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ProblemDetails.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ActivityTypeRatioDto>(null as any);
    }
}

export class GetDailyOuraDataEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param request (optional) 
     * @return OK
     */
    getDailyOuraData(request: Date | undefined): Promise<DailyOuraDataDTO> {
        let url_ = this.baseUrl + "/api/oura/get-daily-oura-data?";
        if (request === null)
            throw new Error("The parameter 'request' cannot be null.");
        else if (request !== undefined)
            url_ += "request=" + encodeURIComponent(request ? "" + request.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDailyOuraData(_response);
        });
    }

    protected processGetDailyOuraData(response: Response): Promise<DailyOuraDataDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DailyOuraDataDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyOuraDataDTO>(null as any);
    }
}

export class GetEquipmentsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getAll(): Promise<Equipment[]> {
        let url_ = this.baseUrl + "/api/equipment/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<Equipment[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Equipment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Equipment[]>(null as any);
    }
}

export class GetMovementBasesEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getAll2(): Promise<MovementBase[]> {
        let url_ = this.baseUrl + "/api/movement-base/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll2(_response);
        });
    }

    protected processGetAll2(response: Response): Promise<MovementBase[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MovementBase.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementBase[]>(null as any);
    }
}

export class GetMovementsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getAll3(sessionID: string): Promise<Movement[]> {
        let url_ = this.baseUrl + "/api/movement/get-all/{sessionId}";
        if (sessionID === undefined || sessionID === null)
            throw new Error("The parameter 'sessionID' must be defined.");
        url_ = url_.replace("{sessionID}", encodeURIComponent("" + sessionID));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll3(_response);
        });
    }

    protected processGetAll3(response: Response): Promise<Movement[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Movement.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Movement[]>(null as any);
    }
}

export class GetMuscleSetsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getMuscleSets(startDate: Date, endDate: Date): Promise<MuscleSetsDto> {
        let url_ = this.baseUrl + "/api/activity/get-muscle-sets?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMuscleSets(_response);
        });
    }

    protected processGetMuscleSets(response: Response): Promise<MuscleSetsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MuscleSetsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = MuscleSetsDto.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MuscleSetsDto>(null as any);
    }
}

export class GetTrainingProgramEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(programId: string): Promise<TrainingProgramDTO> {
        let url_ = this.baseUrl + "/api/training-program/get/{programId}";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TrainingProgramDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingProgramDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingProgramDTO>(null as any);
    }
}

export class GetTrainingProgramsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getAll4(): Promise<TrainingProgramDTO[]> {
        let url_ = this.baseUrl + "/api/training-program/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll4(_response);
        });
    }

    protected processGetAll4(response: Response): Promise<TrainingProgramDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingProgramDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingProgramDTO[]>(null as any);
    }
}

export class GetTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get2(programId: string, sessionId: string): Promise<TrainingSessionDTO> {
        let url_ = this.baseUrl + "/api/training-session/get/{programId}/{sessionId}";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<TrainingSessionDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSessionDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO>(null as any);
    }
}

export class GetTrainingSessionsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getAll5(trainingProgramId: string): Promise<TrainingSessionDTO[]> {
        let url_ = this.baseUrl + "/api/training-session/get-all/{trainingProgramId}";
        if (trainingProgramId === undefined || trainingProgramId === null)
            throw new Error("The parameter 'trainingProgramId' must be defined.");
        url_ = url_.replace("{trainingProgramId}", encodeURIComponent("" + trainingProgramId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll5(_response);
        });
    }

    protected processGetAll5(response: Response): Promise<TrainingSessionDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingSessionDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO[]>(null as any);
    }
}

export class GetWellnessStateEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param date (optional) 
     * @return OK
     */
    get3(date: Date | undefined): Promise<WellnessState> {
        let url_ = this.baseUrl + "/api/wellness/get?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet3(_response);
        });
    }

    protected processGet3(response: Response): Promise<WellnessState> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WellnessState.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WellnessState.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WellnessState>(null as any);
    }
}

export class GetWellnessStatesEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getRange(startDate: Date, endDate: Date): Promise<WellnessState[]> {
        let url_ = this.baseUrl + "/api/wellness/get-range?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRange(_response);
        });
    }

    protected processGetRange(response: Response): Promise<WellnessState[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WellnessState.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData401)) {
                result401 = [] as any;
                for (let item of resultData401)
                    result401!.push(WellnessState.fromJS(item));
            }
            else {
                result401 = <any>null;
            }
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WellnessState[]>(null as any);
    }
}

export class HasCreatedProfileEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    hasCreatedProfile(): Promise<BootUserDTO> {
        let url_ = this.baseUrl + "/api/user/has-created-profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHasCreatedProfile(_response);
        });
    }

    protected processHasCreatedProfile(response: Response): Promise<BootUserDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BootUserDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BootUserDTO>(null as any);
    }
}

export class LionheartClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    register(body: RegisterRequest): Promise<void> {
        let url_ = this.baseUrl + "/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param useCookies (optional) 
     * @param useSessionCookies (optional) 
     * @return OK
     */
    login(useCookies: boolean | undefined, useSessionCookies: boolean | undefined, body: LoginRequest): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/login?";
        if (useCookies === null)
            throw new Error("The parameter 'useCookies' cannot be null.");
        else if (useCookies !== undefined)
            url_ += "useCookies=" + encodeURIComponent("" + useCookies) + "&";
        if (useSessionCookies === null)
            throw new Error("The parameter 'useSessionCookies' cannot be null.");
        else if (useSessionCookies !== undefined)
            url_ += "useSessionCookies=" + encodeURIComponent("" + useSessionCookies) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<AccessTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    /**
     * @return OK
     */
    refresh(body: RefreshRequest): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: Response): Promise<AccessTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    /**
     * @param changedEmail (optional) 
     * @return OK
     */
    mapIdentityApi_confirmEmail(userId: string, code: string, changedEmail: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/confirmEmail?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined and cannot be null.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (changedEmail === null)
            throw new Error("The parameter 'changedEmail' cannot be null.");
        else if (changedEmail !== undefined)
            url_ += "changedEmail=" + encodeURIComponent("" + changedEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMapIdentityApi_confirmEmail(_response);
        });
    }

    protected processMapIdentityApi_confirmEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    resendConfirmationEmail(body: ResendConfirmationEmailRequest): Promise<void> {
        let url_ = this.baseUrl + "/resendConfirmationEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResendConfirmationEmail(_response);
        });
    }

    protected processResendConfirmationEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    forgotPassword(body: ForgotPasswordRequest): Promise<void> {
        let url_ = this.baseUrl + "/forgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    resetPassword(body: ResetPasswordRequest): Promise<void> {
        let url_ = this.baseUrl + "/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    _2fa(body: TwoFactorRequest): Promise<TwoFactorResponse> {
        let url_ = this.baseUrl + "/manage/2fa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process_2fa(_response);
        });
    }

    protected process_2fa(response: Response): Promise<TwoFactorResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwoFactorResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TwoFactorResponse>(null as any);
    }

    /**
     * @return OK
     */
    infoGET(): Promise<InfoResponse> {
        let url_ = this.baseUrl + "/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInfoGET(_response);
        });
    }

    protected processInfoGET(response: Response): Promise<InfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InfoResponse>(null as any);
    }

    /**
     * @return OK
     */
    infoPOST(body: InfoRequest): Promise<InfoResponse> {
        let url_ = this.baseUrl + "/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInfoPOST(_response);
        });
    }

    protected processInfoPOST(response: Response): Promise<InfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InfoResponse>(null as any);
    }
}

export class LogoutUserEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param request (optional) 
     * @return No Content
     */
    logout(request: any | undefined): Promise<BootUserDTO> {
        let url_ = this.baseUrl + "/api/user/logout?";
        if (request === null)
            throw new Error("The parameter 'request' cannot be null.");
        else if (request !== undefined)
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<BootUserDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = BootUserDTO.fromJS(resultData204);
            return result204;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BootUserDTO>(null as any);
    }
}

export class ModifyTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    modifyTrainingSession(): Promise<string> {
        let url_ = this.baseUrl + "/api/ai/modify-training-session";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processModifyTrainingSession(_response);
        });
    }

    protected processModifyTrainingSession(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class SetPersonalApiAccessTokenEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setPersonalApiAccessToken(body: CreatePersonalApiAccessTokenRequest | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/user/set-personal-api-access-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPersonalApiAccessToken(_response);
        });
    }

    protected processSetPersonalApiAccessToken(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return result201;
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class SyncOuraApiEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    sync(body: DateRangeRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/oura/sync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSync(_response);
        });
    }

    protected processSync(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UpdateMovementEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UpdateMovementRequest | undefined): Promise<Movement> {
        let url_ = this.baseUrl + "/api/movement/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Movement> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Movement.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Movement>(null as any);
    }
}

export class UpdateMovementOrderEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateOrder(body: UpdateMovementOrderRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/movement/update-order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateOrder(_response);
        });
    }

    protected processUpdateOrder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UpdateMovementsCompletionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateCompletion(body: UpdateMovementsCompletionRequest | undefined): Promise<Movement> {
        let url_ = this.baseUrl + "/api/movement/update-completion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCompletion(_response);
        });
    }

    protected processUpdateCompletion(response: Response): Promise<Movement> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Movement.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Movement>(null as any);
    }
}

export class UpdateSetEntryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update2(body: UpdateSetEntryRequest | undefined): Promise<SetEntryDTO> {
        let url_ = this.baseUrl + "/api/set-entry/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate2(_response);
        });
    }

    protected processUpdate2(response: Response): Promise<SetEntryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SetEntryDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SetEntryDTO>(null as any);
    }
}

export class UpdateTrainingProgramEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update3(body: UpdateTrainingProgramRequest | undefined): Promise<TrainingProgramDTO> {
        let url_ = this.baseUrl + "/api/training-program/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate3(_response);
        });
    }

    protected processUpdate3(response: Response): Promise<TrainingProgramDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingProgramDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingProgramDTO>(null as any);
    }
}

export class UpdateTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update4(body: UpdateTrainingSessionRequest | undefined): Promise<TrainingSessionDTO> {
        let url_ = this.baseUrl + "/api/training-session/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate4(_response);
        });
    }

    protected processUpdate4(response: Response): Promise<TrainingSessionDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSessionDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO>(null as any);
    }
}

export class AccessTokenResponse implements IAccessTokenResponse {
    readonly tokenType?: string | undefined;
    accessToken!: string | undefined;
    expiresIn!: number;
    refreshToken!: string | undefined;

    constructor(data?: IAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).tokenType = _data["tokenType"];
            this.accessToken = _data["accessToken"];
            this.expiresIn = _data["expiresIn"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenType"] = this.tokenType;
        data["accessToken"] = this.accessToken;
        data["expiresIn"] = this.expiresIn;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IAccessTokenResponse {
    tokenType?: string | undefined;
    accessToken: string | undefined;
    expiresIn: number;
    refreshToken: string | undefined;
}

export class Activity implements IActivity {
    activityID?: string;
    userID?: string;
    dateTime?: Date;
    timeInMinutes?: number;
    caloriesBurned?: number;
    name?: string | undefined;
    userSummary?: string | undefined;
    accumulatedFatigue?: number;
    difficultyRating?: number;
    engagementRating?: number;
    externalVariablesRating?: number;
    runWalkDetails?: RunWalkDetails;
    liftDetails?: LiftDetails;
    rideDetails?: RideDetails;

    constructor(data?: IActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityID = _data["activityID"];
            this.userID = _data["userID"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.timeInMinutes = _data["timeInMinutes"];
            this.caloriesBurned = _data["caloriesBurned"];
            this.name = _data["name"];
            this.userSummary = _data["userSummary"];
            this.accumulatedFatigue = _data["accumulatedFatigue"];
            this.difficultyRating = _data["difficultyRating"];
            this.engagementRating = _data["engagementRating"];
            this.externalVariablesRating = _data["externalVariablesRating"];
            this.runWalkDetails = _data["runWalkDetails"] ? RunWalkDetails.fromJS(_data["runWalkDetails"]) : <any>undefined;
            this.liftDetails = _data["liftDetails"] ? LiftDetails.fromJS(_data["liftDetails"]) : <any>undefined;
            this.rideDetails = _data["rideDetails"] ? RideDetails.fromJS(_data["rideDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Activity {
        data = typeof data === 'object' ? data : {};
        let result = new Activity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityID"] = this.activityID;
        data["userID"] = this.userID;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["timeInMinutes"] = this.timeInMinutes;
        data["caloriesBurned"] = this.caloriesBurned;
        data["name"] = this.name;
        data["userSummary"] = this.userSummary;
        data["accumulatedFatigue"] = this.accumulatedFatigue;
        data["difficultyRating"] = this.difficultyRating;
        data["engagementRating"] = this.engagementRating;
        data["externalVariablesRating"] = this.externalVariablesRating;
        data["runWalkDetails"] = this.runWalkDetails ? this.runWalkDetails.toJSON() : <any>undefined;
        data["liftDetails"] = this.liftDetails ? this.liftDetails.toJSON() : <any>undefined;
        data["rideDetails"] = this.rideDetails ? this.rideDetails.toJSON() : <any>undefined;
        return data;
    }
}

export interface IActivity {
    activityID?: string;
    userID?: string;
    dateTime?: Date;
    timeInMinutes?: number;
    caloriesBurned?: number;
    name?: string | undefined;
    userSummary?: string | undefined;
    accumulatedFatigue?: number;
    difficultyRating?: number;
    engagementRating?: number;
    externalVariablesRating?: number;
    runWalkDetails?: RunWalkDetails;
    liftDetails?: LiftDetails;
    rideDetails?: RideDetails;
}

export class ActivityData implements IActivityData {
    activityScore?: number;
    steps?: number;
    activeCalories?: number;
    totalCalories?: number;
    targetCalories?: number;
    meetDailyTargets?: number;
    moveEveryHour?: number;
    recoveryTime?: number;
    stayActive?: number;
    trainingFrequency?: number;
    trainingVolume?: number;

    constructor(data?: IActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityScore = _data["activityScore"];
            this.steps = _data["steps"];
            this.activeCalories = _data["activeCalories"];
            this.totalCalories = _data["totalCalories"];
            this.targetCalories = _data["targetCalories"];
            this.meetDailyTargets = _data["meetDailyTargets"];
            this.moveEveryHour = _data["moveEveryHour"];
            this.recoveryTime = _data["recoveryTime"];
            this.stayActive = _data["stayActive"];
            this.trainingFrequency = _data["trainingFrequency"];
            this.trainingVolume = _data["trainingVolume"];
        }
    }

    static fromJS(data: any): ActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityScore"] = this.activityScore;
        data["steps"] = this.steps;
        data["activeCalories"] = this.activeCalories;
        data["totalCalories"] = this.totalCalories;
        data["targetCalories"] = this.targetCalories;
        data["meetDailyTargets"] = this.meetDailyTargets;
        data["moveEveryHour"] = this.moveEveryHour;
        data["recoveryTime"] = this.recoveryTime;
        data["stayActive"] = this.stayActive;
        data["trainingFrequency"] = this.trainingFrequency;
        data["trainingVolume"] = this.trainingVolume;
        return data;
    }
}

export interface IActivityData {
    activityScore?: number;
    steps?: number;
    activeCalories?: number;
    totalCalories?: number;
    targetCalories?: number;
    meetDailyTargets?: number;
    moveEveryHour?: number;
    recoveryTime?: number;
    stayActive?: number;
    trainingFrequency?: number;
    trainingVolume?: number;
}

export class ActivityTypeRatioDto implements IActivityTypeRatioDto {
    numberLifts?: number;
    numberRunWalks?: number;
    numberRides?: number;

    constructor(data?: IActivityTypeRatioDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numberLifts = _data["numberLifts"];
            this.numberRunWalks = _data["numberRunWalks"];
            this.numberRides = _data["numberRides"];
        }
    }

    static fromJS(data: any): ActivityTypeRatioDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityTypeRatioDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberLifts"] = this.numberLifts;
        data["numberRunWalks"] = this.numberRunWalks;
        data["numberRides"] = this.numberRides;
        return data;
    }
}

export interface IActivityTypeRatioDto {
    numberLifts?: number;
    numberRunWalks?: number;
    numberRides?: number;
}

export class ApiAccessToken implements IApiAccessToken {
    objectID?: string;
    userID?: string;
    applicationName?: string | undefined;
    personalAccessToken?: string | undefined;

    constructor(data?: IApiAccessToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectID = _data["objectID"];
            this.userID = _data["userID"];
            this.applicationName = _data["applicationName"];
            this.personalAccessToken = _data["personalAccessToken"];
        }
    }

    static fromJS(data: any): ApiAccessToken {
        data = typeof data === 'object' ? data : {};
        let result = new ApiAccessToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectID"] = this.objectID;
        data["userID"] = this.userID;
        data["applicationName"] = this.applicationName;
        data["personalAccessToken"] = this.personalAccessToken;
        return data;
    }
}

export interface IApiAccessToken {
    objectID?: string;
    userID?: string;
    applicationName?: string | undefined;
    personalAccessToken?: string | undefined;
}

export class BootUserDTO implements IBootUserDTO {
    name?: string | undefined;
    hasCreatedProfile?: boolean;

    constructor(data?: IBootUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.hasCreatedProfile = _data["hasCreatedProfile"];
        }
    }

    static fromJS(data: any): BootUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BootUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["hasCreatedProfile"] = this.hasCreatedProfile;
        return data;
    }
}

export interface IBootUserDTO {
    name?: string | undefined;
    hasCreatedProfile?: boolean;
}

export class CreateActivityRequest implements ICreateActivityRequest {
    dateTime!: Date;
    timeInMinutes!: number;
    caloriesBurned!: number;
    name!: string;
    userSummary?: string | undefined;
    accumulatedFatigue!: number;
    difficultyRating!: number;
    engagementRating!: number;
    externalVariablesRating!: number;

    constructor(data?: ICreateActivityRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.timeInMinutes = _data["timeInMinutes"];
            this.caloriesBurned = _data["caloriesBurned"];
            this.name = _data["name"];
            this.userSummary = _data["userSummary"];
            this.accumulatedFatigue = _data["accumulatedFatigue"];
            this.difficultyRating = _data["difficultyRating"];
            this.engagementRating = _data["engagementRating"];
            this.externalVariablesRating = _data["externalVariablesRating"];
        }
    }

    static fromJS(data: any): CreateActivityRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["timeInMinutes"] = this.timeInMinutes;
        data["caloriesBurned"] = this.caloriesBurned;
        data["name"] = this.name;
        data["userSummary"] = this.userSummary;
        data["accumulatedFatigue"] = this.accumulatedFatigue;
        data["difficultyRating"] = this.difficultyRating;
        data["engagementRating"] = this.engagementRating;
        data["externalVariablesRating"] = this.externalVariablesRating;
        return data;
    }
}

export interface ICreateActivityRequest {
    dateTime: Date;
    timeInMinutes: number;
    caloriesBurned: number;
    name: string;
    userSummary?: string | undefined;
    accumulatedFatigue: number;
    difficultyRating: number;
    engagementRating: number;
    externalVariablesRating: number;
}

export class CreateEquipmentRequest implements ICreateEquipmentRequest {
    name!: string;

    constructor(data?: ICreateEquipmentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateEquipmentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEquipmentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateEquipmentRequest {
    name: string;
}

export class CreateLiftRequest implements ICreateLiftRequest {
    dateTime!: Date;
    timeInMinutes!: number;
    caloriesBurned!: number;
    name!: string;
    userSummary?: string | undefined;
    accumulatedFatigue!: number;
    difficultyRating!: number;
    engagementRating!: number;
    externalVariablesRating!: number;
    tonnage!: number;
    liftType?: string | undefined;
    liftFocus?: string | undefined;
    quadSets!: number;
    hamstringSets!: number;
    bicepSets!: number;
    tricepSets!: number;
    shoulderSets!: number;
    backSets!: number;
    chestSets!: number;

    constructor(data?: ICreateLiftRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.timeInMinutes = _data["timeInMinutes"];
            this.caloriesBurned = _data["caloriesBurned"];
            this.name = _data["name"];
            this.userSummary = _data["userSummary"];
            this.accumulatedFatigue = _data["accumulatedFatigue"];
            this.difficultyRating = _data["difficultyRating"];
            this.engagementRating = _data["engagementRating"];
            this.externalVariablesRating = _data["externalVariablesRating"];
            this.tonnage = _data["tonnage"];
            this.liftType = _data["liftType"];
            this.liftFocus = _data["liftFocus"];
            this.quadSets = _data["quadSets"];
            this.hamstringSets = _data["hamstringSets"];
            this.bicepSets = _data["bicepSets"];
            this.tricepSets = _data["tricepSets"];
            this.shoulderSets = _data["shoulderSets"];
            this.backSets = _data["backSets"];
            this.chestSets = _data["chestSets"];
        }
    }

    static fromJS(data: any): CreateLiftRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLiftRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["timeInMinutes"] = this.timeInMinutes;
        data["caloriesBurned"] = this.caloriesBurned;
        data["name"] = this.name;
        data["userSummary"] = this.userSummary;
        data["accumulatedFatigue"] = this.accumulatedFatigue;
        data["difficultyRating"] = this.difficultyRating;
        data["engagementRating"] = this.engagementRating;
        data["externalVariablesRating"] = this.externalVariablesRating;
        data["tonnage"] = this.tonnage;
        data["liftType"] = this.liftType;
        data["liftFocus"] = this.liftFocus;
        data["quadSets"] = this.quadSets;
        data["hamstringSets"] = this.hamstringSets;
        data["bicepSets"] = this.bicepSets;
        data["tricepSets"] = this.tricepSets;
        data["shoulderSets"] = this.shoulderSets;
        data["backSets"] = this.backSets;
        data["chestSets"] = this.chestSets;
        return data;
    }
}

export interface ICreateLiftRequest {
    dateTime: Date;
    timeInMinutes: number;
    caloriesBurned: number;
    name: string;
    userSummary?: string | undefined;
    accumulatedFatigue: number;
    difficultyRating: number;
    engagementRating: number;
    externalVariablesRating: number;
    tonnage: number;
    liftType?: string | undefined;
    liftFocus?: string | undefined;
    quadSets: number;
    hamstringSets: number;
    bicepSets: number;
    tricepSets: number;
    shoulderSets: number;
    backSets: number;
    chestSets: number;
}

export class CreateMovementBaseRequest implements ICreateMovementBaseRequest {
    name!: string;

    constructor(data?: ICreateMovementBaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateMovementBaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMovementBaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateMovementBaseRequest {
    name: string;
}

export class CreateMovementRequest implements ICreateMovementRequest {
    movementBaseID!: string;
    movementModifier!: MovementModifier;
    notes!: string;
    trainingSessionID!: string;
    weightUnit!: WeightUnit;

    constructor(data?: ICreateMovementRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.movementModifier = new MovementModifier();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementBaseID = _data["movementBaseID"];
            this.movementModifier = _data["movementModifier"] ? MovementModifier.fromJS(_data["movementModifier"]) : new MovementModifier();
            this.notes = _data["notes"];
            this.trainingSessionID = _data["trainingSessionID"];
            this.weightUnit = _data["weightUnit"];
        }
    }

    static fromJS(data: any): CreateMovementRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMovementRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementBaseID"] = this.movementBaseID;
        data["movementModifier"] = this.movementModifier ? this.movementModifier.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        data["trainingSessionID"] = this.trainingSessionID;
        data["weightUnit"] = this.weightUnit;
        return data;
    }
}

export interface ICreateMovementRequest {
    movementBaseID: string;
    movementModifier: MovementModifier;
    notes: string;
    trainingSessionID: string;
    weightUnit: WeightUnit;
}

export class CreatePersonalApiAccessTokenRequest implements ICreatePersonalApiAccessTokenRequest {
    applicationName!: string;
    accessToken!: string;

    constructor(data?: ICreatePersonalApiAccessTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationName = _data["applicationName"];
            this.accessToken = _data["accessToken"];
        }
    }

    static fromJS(data: any): CreatePersonalApiAccessTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePersonalApiAccessTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationName"] = this.applicationName;
        data["accessToken"] = this.accessToken;
        return data;
    }
}

export interface ICreatePersonalApiAccessTokenRequest {
    applicationName: string;
    accessToken: string;
}

export class CreateProfileRequest implements ICreateProfileRequest {
    displayName!: string;
    age!: number;
    weight!: number;

    constructor(data?: ICreateProfileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.age = _data["age"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): CreateProfileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProfileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["age"] = this.age;
        data["weight"] = this.weight;
        return data;
    }
}

export interface ICreateProfileRequest {
    displayName: string;
    age: number;
    weight: number;
}

export class CreateRideRequest implements ICreateRideRequest {
    dateTime!: Date;
    timeInMinutes!: number;
    caloriesBurned!: number;
    name!: string;
    userSummary?: string | undefined;
    accumulatedFatigue!: number;
    difficultyRating!: number;
    engagementRating!: number;
    externalVariablesRating!: number;
    distance!: number;
    elevationGain!: number;
    averagePower!: number;
    averageSpeed!: number;
    rideType?: string | undefined;

    constructor(data?: ICreateRideRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.timeInMinutes = _data["timeInMinutes"];
            this.caloriesBurned = _data["caloriesBurned"];
            this.name = _data["name"];
            this.userSummary = _data["userSummary"];
            this.accumulatedFatigue = _data["accumulatedFatigue"];
            this.difficultyRating = _data["difficultyRating"];
            this.engagementRating = _data["engagementRating"];
            this.externalVariablesRating = _data["externalVariablesRating"];
            this.distance = _data["distance"];
            this.elevationGain = _data["elevationGain"];
            this.averagePower = _data["averagePower"];
            this.averageSpeed = _data["averageSpeed"];
            this.rideType = _data["rideType"];
        }
    }

    static fromJS(data: any): CreateRideRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRideRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["timeInMinutes"] = this.timeInMinutes;
        data["caloriesBurned"] = this.caloriesBurned;
        data["name"] = this.name;
        data["userSummary"] = this.userSummary;
        data["accumulatedFatigue"] = this.accumulatedFatigue;
        data["difficultyRating"] = this.difficultyRating;
        data["engagementRating"] = this.engagementRating;
        data["externalVariablesRating"] = this.externalVariablesRating;
        data["distance"] = this.distance;
        data["elevationGain"] = this.elevationGain;
        data["averagePower"] = this.averagePower;
        data["averageSpeed"] = this.averageSpeed;
        data["rideType"] = this.rideType;
        return data;
    }
}

export interface ICreateRideRequest {
    dateTime: Date;
    timeInMinutes: number;
    caloriesBurned: number;
    name: string;
    userSummary?: string | undefined;
    accumulatedFatigue: number;
    difficultyRating: number;
    engagementRating: number;
    externalVariablesRating: number;
    distance: number;
    elevationGain: number;
    averagePower: number;
    averageSpeed: number;
    rideType?: string | undefined;
}

export class CreateRunWalkRequest implements ICreateRunWalkRequest {
    dateTime!: Date;
    timeInMinutes!: number;
    caloriesBurned!: number;
    name!: string;
    userSummary?: string | undefined;
    accumulatedFatigue!: number;
    difficultyRating!: number;
    engagementRating!: number;
    externalVariablesRating!: number;
    distance!: number;
    elevationGain!: number;
    averagePaceInSeconds!: number;
    mileSplitsInSeconds!: number[];
    runType?: string | undefined;

    constructor(data?: ICreateRunWalkRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.mileSplitsInSeconds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.timeInMinutes = _data["timeInMinutes"];
            this.caloriesBurned = _data["caloriesBurned"];
            this.name = _data["name"];
            this.userSummary = _data["userSummary"];
            this.accumulatedFatigue = _data["accumulatedFatigue"];
            this.difficultyRating = _data["difficultyRating"];
            this.engagementRating = _data["engagementRating"];
            this.externalVariablesRating = _data["externalVariablesRating"];
            this.distance = _data["distance"];
            this.elevationGain = _data["elevationGain"];
            this.averagePaceInSeconds = _data["averagePaceInSeconds"];
            if (Array.isArray(_data["mileSplitsInSeconds"])) {
                this.mileSplitsInSeconds = [] as any;
                for (let item of _data["mileSplitsInSeconds"])
                    this.mileSplitsInSeconds!.push(item);
            }
            this.runType = _data["runType"];
        }
    }

    static fromJS(data: any): CreateRunWalkRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRunWalkRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["timeInMinutes"] = this.timeInMinutes;
        data["caloriesBurned"] = this.caloriesBurned;
        data["name"] = this.name;
        data["userSummary"] = this.userSummary;
        data["accumulatedFatigue"] = this.accumulatedFatigue;
        data["difficultyRating"] = this.difficultyRating;
        data["engagementRating"] = this.engagementRating;
        data["externalVariablesRating"] = this.externalVariablesRating;
        data["distance"] = this.distance;
        data["elevationGain"] = this.elevationGain;
        data["averagePaceInSeconds"] = this.averagePaceInSeconds;
        if (Array.isArray(this.mileSplitsInSeconds)) {
            data["mileSplitsInSeconds"] = [];
            for (let item of this.mileSplitsInSeconds)
                data["mileSplitsInSeconds"].push(item);
        }
        data["runType"] = this.runType;
        return data;
    }
}

export interface ICreateRunWalkRequest {
    dateTime: Date;
    timeInMinutes: number;
    caloriesBurned: number;
    name: string;
    userSummary?: string | undefined;
    accumulatedFatigue: number;
    difficultyRating: number;
    engagementRating: number;
    externalVariablesRating: number;
    distance: number;
    elevationGain: number;
    averagePaceInSeconds: number;
    mileSplitsInSeconds: number[];
    runType?: string | undefined;
}

export class CreateSetEntryRequest implements ICreateSetEntryRequest {
    recommendedReps!: number;
    recommendedWeight!: number;
    recommendedRPE!: number;
    actualReps!: number;
    actualWeight!: number;
    actualRPE!: number;
    movementID!: string;

    constructor(data?: ICreateSetEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recommendedReps = _data["recommendedReps"];
            this.recommendedWeight = _data["recommendedWeight"];
            this.recommendedRPE = _data["recommendedRPE"];
            this.actualReps = _data["actualReps"];
            this.actualWeight = _data["actualWeight"];
            this.actualRPE = _data["actualRPE"];
            this.movementID = _data["movementID"];
        }
    }

    static fromJS(data: any): CreateSetEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSetEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recommendedReps"] = this.recommendedReps;
        data["recommendedWeight"] = this.recommendedWeight;
        data["recommendedRPE"] = this.recommendedRPE;
        data["actualReps"] = this.actualReps;
        data["actualWeight"] = this.actualWeight;
        data["actualRPE"] = this.actualRPE;
        data["movementID"] = this.movementID;
        return data;
    }
}

export interface ICreateSetEntryRequest {
    recommendedReps: number;
    recommendedWeight: number;
    recommendedRPE: number;
    actualReps: number;
    actualWeight: number;
    actualRPE: number;
    movementID: string;
}

export class CreateTrainingProgramRequest implements ICreateTrainingProgramRequest {
    title!: string;
    startDate!: Date;
    endDate!: Date;
    tags!: string[];

    constructor(data?: ICreateTrainingProgramRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tags = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateTrainingProgramRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTrainingProgramRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface ICreateTrainingProgramRequest {
    title: string;
    startDate: Date;
    endDate: Date;
    tags: string[];
}

export class CreateTrainingSessionRequest implements ICreateTrainingSessionRequest {
    date!: Date;
    trainingProgramID!: string;

    constructor(data?: ICreateTrainingSessionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.trainingProgramID = _data["trainingProgramID"];
        }
    }

    static fromJS(data: any): CreateTrainingSessionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTrainingSessionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["trainingProgramID"] = this.trainingProgramID;
        return data;
    }
}

export interface ICreateTrainingSessionRequest {
    date: Date;
    trainingProgramID: string;
}

export class CreateWellnessStateRequest implements ICreateWellnessStateRequest {
    date!: string;
    energy!: number;
    motivation!: number;
    mood!: number;
    stress!: number;

    constructor(data?: ICreateWellnessStateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.energy = _data["energy"];
            this.motivation = _data["motivation"];
            this.mood = _data["mood"];
            this.stress = _data["stress"];
        }
    }

    static fromJS(data: any): CreateWellnessStateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWellnessStateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["energy"] = this.energy;
        data["motivation"] = this.motivation;
        data["mood"] = this.mood;
        data["stress"] = this.stress;
        return data;
    }
}

export interface ICreateWellnessStateRequest {
    date: string;
    energy: number;
    motivation: number;
    mood: number;
    stress: number;
}

export class DailyOuraDataDTO implements IDailyOuraDataDTO {
    objectID?: string;
    date?: Date;
    resilienceData?: ResilienceData;
    activityData?: ActivityData;
    sleepData?: SleepData;
    readinessData?: ReadinessData;

    constructor(data?: IDailyOuraDataDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectID = _data["objectID"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.resilienceData = _data["resilienceData"] ? ResilienceData.fromJS(_data["resilienceData"]) : <any>undefined;
            this.activityData = _data["activityData"] ? ActivityData.fromJS(_data["activityData"]) : <any>undefined;
            this.sleepData = _data["sleepData"] ? SleepData.fromJS(_data["sleepData"]) : <any>undefined;
            this.readinessData = _data["readinessData"] ? ReadinessData.fromJS(_data["readinessData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DailyOuraDataDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DailyOuraDataDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectID"] = this.objectID;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["resilienceData"] = this.resilienceData ? this.resilienceData.toJSON() : <any>undefined;
        data["activityData"] = this.activityData ? this.activityData.toJSON() : <any>undefined;
        data["sleepData"] = this.sleepData ? this.sleepData.toJSON() : <any>undefined;
        data["readinessData"] = this.readinessData ? this.readinessData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDailyOuraDataDTO {
    objectID?: string;
    date?: Date;
    resilienceData?: ResilienceData;
    activityData?: ActivityData;
    sleepData?: SleepData;
    readinessData?: ReadinessData;
}

export class DailyOuraInfo implements IDailyOuraInfo {
    objectID?: string;
    userID?: string;
    date?: Date;
    syncDate?: Date;
    resilienceData!: ResilienceData;
    activityData!: ActivityData;
    sleepData!: SleepData;
    readinessData!: ReadinessData;
    activityJson?: string | undefined;
    resilienceJson?: string | undefined;
    sleepJson?: string | undefined;
    readinessJson?: string | undefined;

    constructor(data?: IDailyOuraInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.resilienceData = new ResilienceData();
            this.activityData = new ActivityData();
            this.sleepData = new SleepData();
            this.readinessData = new ReadinessData();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectID = _data["objectID"];
            this.userID = _data["userID"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.syncDate = _data["syncDate"] ? new Date(_data["syncDate"].toString()) : <any>undefined;
            this.resilienceData = _data["resilienceData"] ? ResilienceData.fromJS(_data["resilienceData"]) : new ResilienceData();
            this.activityData = _data["activityData"] ? ActivityData.fromJS(_data["activityData"]) : new ActivityData();
            this.sleepData = _data["sleepData"] ? SleepData.fromJS(_data["sleepData"]) : new SleepData();
            this.readinessData = _data["readinessData"] ? ReadinessData.fromJS(_data["readinessData"]) : new ReadinessData();
            this.activityJson = _data["activityJson"];
            this.resilienceJson = _data["resilienceJson"];
            this.sleepJson = _data["sleepJson"];
            this.readinessJson = _data["readinessJson"];
        }
    }

    static fromJS(data: any): DailyOuraInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DailyOuraInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectID"] = this.objectID;
        data["userID"] = this.userID;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["syncDate"] = this.syncDate ? formatDate(this.syncDate) : <any>undefined;
        data["resilienceData"] = this.resilienceData ? this.resilienceData.toJSON() : <any>undefined;
        data["activityData"] = this.activityData ? this.activityData.toJSON() : <any>undefined;
        data["sleepData"] = this.sleepData ? this.sleepData.toJSON() : <any>undefined;
        data["readinessData"] = this.readinessData ? this.readinessData.toJSON() : <any>undefined;
        data["activityJson"] = this.activityJson;
        data["resilienceJson"] = this.resilienceJson;
        data["sleepJson"] = this.sleepJson;
        data["readinessJson"] = this.readinessJson;
        return data;
    }
}

export interface IDailyOuraInfo {
    objectID?: string;
    userID?: string;
    date?: Date;
    syncDate?: Date;
    resilienceData: ResilienceData;
    activityData: ActivityData;
    sleepData: SleepData;
    readinessData: ReadinessData;
    activityJson?: string | undefined;
    resilienceJson?: string | undefined;
    sleepJson?: string | undefined;
    readinessJson?: string | undefined;
}

export class DateRangeRequest implements IDateRangeRequest {
    startDate!: Date;
    endDate!: Date;

    constructor(data?: IDateRangeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateRangeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        return data;
    }
}

export interface IDateRangeRequest {
    startDate: Date;
    endDate: Date;
}

export class Equipment implements IEquipment {
    equipmentID?: string;
    name?: string | undefined;
    userID?: string;

    constructor(data?: IEquipment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentID = _data["equipmentID"];
            this.name = _data["name"];
            this.userID = _data["userID"];
        }
    }

    static fromJS(data: any): Equipment {
        data = typeof data === 'object' ? data : {};
        let result = new Equipment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentID"] = this.equipmentID;
        data["name"] = this.name;
        data["userID"] = this.userID;
        return data;
    }
}

export interface IEquipment {
    equipmentID?: string;
    name?: string | undefined;
    userID?: string;
}

export class FirstWeekGenerationDTO implements IFirstWeekGenerationDTO {
    trainingProgramID!: string;

    constructor(data?: IFirstWeekGenerationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingProgramID = _data["trainingProgramID"];
        }
    }

    static fromJS(data: any): FirstWeekGenerationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FirstWeekGenerationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramID"] = this.trainingProgramID;
        return data;
    }
}

export interface IFirstWeekGenerationDTO {
    trainingProgramID: string;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email!: string | undefined;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email: string | undefined;
}

export class HttpValidationProblemDetails implements IHttpValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IHttpValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;
}

export class IdentityUser implements IIdentityUser {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;

    constructor(data?: IIdentityUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): IdentityUser {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IIdentityUser {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export class InfoRequest implements IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;

    constructor(data?: IInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newEmail = _data["newEmail"];
            this.newPassword = _data["newPassword"];
            this.oldPassword = _data["oldPassword"];
        }
    }

    static fromJS(data: any): InfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newEmail"] = this.newEmail;
        data["newPassword"] = this.newPassword;
        data["oldPassword"] = this.oldPassword;
        return data;
    }
}

export interface IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;
}

export class InfoResponse implements IInfoResponse {
    email!: string | undefined;
    isEmailConfirmed!: boolean;

    constructor(data?: IInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
        }
    }

    static fromJS(data: any): InfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        return data;
    }
}

export interface IInfoResponse {
    email: string | undefined;
    isEmailConfirmed: boolean;
}

export class LiftDetails implements ILiftDetails {
    activityID?: string;
    tonnage?: number;
    liftType?: string | undefined;
    liftFocus?: string | undefined;
    quadSets?: number;
    hamstringSets?: number;
    bicepSets?: number;
    tricepSets?: number;
    shoulderSets?: number;
    chestSets?: number;
    backSets?: number;

    constructor(data?: ILiftDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityID = _data["activityID"];
            this.tonnage = _data["tonnage"];
            this.liftType = _data["liftType"];
            this.liftFocus = _data["liftFocus"];
            this.quadSets = _data["quadSets"];
            this.hamstringSets = _data["hamstringSets"];
            this.bicepSets = _data["bicepSets"];
            this.tricepSets = _data["tricepSets"];
            this.shoulderSets = _data["shoulderSets"];
            this.chestSets = _data["chestSets"];
            this.backSets = _data["backSets"];
        }
    }

    static fromJS(data: any): LiftDetails {
        data = typeof data === 'object' ? data : {};
        let result = new LiftDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityID"] = this.activityID;
        data["tonnage"] = this.tonnage;
        data["liftType"] = this.liftType;
        data["liftFocus"] = this.liftFocus;
        data["quadSets"] = this.quadSets;
        data["hamstringSets"] = this.hamstringSets;
        data["bicepSets"] = this.bicepSets;
        data["tricepSets"] = this.tricepSets;
        data["shoulderSets"] = this.shoulderSets;
        data["chestSets"] = this.chestSets;
        data["backSets"] = this.backSets;
        return data;
    }
}

export interface ILiftDetails {
    activityID?: string;
    tonnage?: number;
    liftType?: string | undefined;
    liftFocus?: string | undefined;
    quadSets?: number;
    hamstringSets?: number;
    bicepSets?: number;
    tricepSets?: number;
    shoulderSets?: number;
    chestSets?: number;
    backSets?: number;
}

export class LionheartUser implements ILionheartUser {
    userID?: string;
    identityUser?: IdentityUser;
    name?: string | undefined;
    age?: number;
    weight?: number;
    wellnessStates?: WellnessState[] | undefined;
    activities?: Activity[] | undefined;
    apiAccessTokens?: ApiAccessToken[] | undefined;
    dailyOuraInfos?: DailyOuraInfo[] | undefined;
    trainingPrograms?: TrainingProgram[] | undefined;
    movementBases?: MovementBase[] | undefined;
    equipments?: Equipment[] | undefined;

    constructor(data?: ILionheartUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userID = _data["userID"];
            this.identityUser = _data["identityUser"] ? IdentityUser.fromJS(_data["identityUser"]) : <any>undefined;
            this.name = _data["name"];
            this.age = _data["age"];
            this.weight = _data["weight"];
            if (Array.isArray(_data["wellnessStates"])) {
                this.wellnessStates = [] as any;
                for (let item of _data["wellnessStates"])
                    this.wellnessStates!.push(WellnessState.fromJS(item));
            }
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(Activity.fromJS(item));
            }
            if (Array.isArray(_data["apiAccessTokens"])) {
                this.apiAccessTokens = [] as any;
                for (let item of _data["apiAccessTokens"])
                    this.apiAccessTokens!.push(ApiAccessToken.fromJS(item));
            }
            if (Array.isArray(_data["dailyOuraInfos"])) {
                this.dailyOuraInfos = [] as any;
                for (let item of _data["dailyOuraInfos"])
                    this.dailyOuraInfos!.push(DailyOuraInfo.fromJS(item));
            }
            if (Array.isArray(_data["trainingPrograms"])) {
                this.trainingPrograms = [] as any;
                for (let item of _data["trainingPrograms"])
                    this.trainingPrograms!.push(TrainingProgram.fromJS(item));
            }
            if (Array.isArray(_data["movementBases"])) {
                this.movementBases = [] as any;
                for (let item of _data["movementBases"])
                    this.movementBases!.push(MovementBase.fromJS(item));
            }
            if (Array.isArray(_data["equipments"])) {
                this.equipments = [] as any;
                for (let item of _data["equipments"])
                    this.equipments!.push(Equipment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LionheartUser {
        data = typeof data === 'object' ? data : {};
        let result = new LionheartUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userID"] = this.userID;
        data["identityUser"] = this.identityUser ? this.identityUser.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["age"] = this.age;
        data["weight"] = this.weight;
        if (Array.isArray(this.wellnessStates)) {
            data["wellnessStates"] = [];
            for (let item of this.wellnessStates)
                data["wellnessStates"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.apiAccessTokens)) {
            data["apiAccessTokens"] = [];
            for (let item of this.apiAccessTokens)
                data["apiAccessTokens"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.dailyOuraInfos)) {
            data["dailyOuraInfos"] = [];
            for (let item of this.dailyOuraInfos)
                data["dailyOuraInfos"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.trainingPrograms)) {
            data["trainingPrograms"] = [];
            for (let item of this.trainingPrograms)
                data["trainingPrograms"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.movementBases)) {
            data["movementBases"] = [];
            for (let item of this.movementBases)
                data["movementBases"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.equipments)) {
            data["equipments"] = [];
            for (let item of this.equipments)
                data["equipments"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ILionheartUser {
    userID?: string;
    identityUser?: IdentityUser;
    name?: string | undefined;
    age?: number;
    weight?: number;
    wellnessStates?: WellnessState[] | undefined;
    activities?: Activity[] | undefined;
    apiAccessTokens?: ApiAccessToken[] | undefined;
    dailyOuraInfos?: DailyOuraInfo[] | undefined;
    trainingPrograms?: TrainingProgram[] | undefined;
    movementBases?: MovementBase[] | undefined;
    equipments?: Equipment[] | undefined;
}

export class LoginRequest implements ILoginRequest {
    email!: string | undefined;
    password!: string | undefined;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.twoFactorRecoveryCode = _data["twoFactorRecoveryCode"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["twoFactorCode"] = this.twoFactorCode;
        data["twoFactorRecoveryCode"] = this.twoFactorRecoveryCode;
        return data;
    }
}

export interface ILoginRequest {
    email: string | undefined;
    password: string | undefined;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;
}

export class Movement implements IMovement {
    movementID?: string;
    trainingSessionID?: string;
    trainingSession?: TrainingSession;
    movementBaseID?: string;
    movementBase?: MovementBase;
    movementModifier!: MovementModifier;
    sets?: SetEntry[] | undefined;
    notes?: string | undefined;
    isCompleted?: boolean;
    ordering!: number;
    weightUnit?: WeightUnit;

    constructor(data?: IMovement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.movementModifier = new MovementModifier();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementID = _data["movementID"];
            this.trainingSessionID = _data["trainingSessionID"];
            this.trainingSession = _data["trainingSession"] ? TrainingSession.fromJS(_data["trainingSession"]) : <any>undefined;
            this.movementBaseID = _data["movementBaseID"];
            this.movementBase = _data["movementBase"] ? MovementBase.fromJS(_data["movementBase"]) : <any>undefined;
            this.movementModifier = _data["movementModifier"] ? MovementModifier.fromJS(_data["movementModifier"]) : new MovementModifier();
            if (Array.isArray(_data["sets"])) {
                this.sets = [] as any;
                for (let item of _data["sets"])
                    this.sets!.push(SetEntry.fromJS(item));
            }
            this.notes = _data["notes"];
            this.isCompleted = _data["isCompleted"];
            this.ordering = _data["ordering"];
            this.weightUnit = _data["weightUnit"];
        }
    }

    static fromJS(data: any): Movement {
        data = typeof data === 'object' ? data : {};
        let result = new Movement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementID"] = this.movementID;
        data["trainingSessionID"] = this.trainingSessionID;
        data["trainingSession"] = this.trainingSession ? this.trainingSession.toJSON() : <any>undefined;
        data["movementBaseID"] = this.movementBaseID;
        data["movementBase"] = this.movementBase ? this.movementBase.toJSON() : <any>undefined;
        data["movementModifier"] = this.movementModifier ? this.movementModifier.toJSON() : <any>undefined;
        if (Array.isArray(this.sets)) {
            data["sets"] = [];
            for (let item of this.sets)
                data["sets"].push(item ? item.toJSON() : <any>undefined);
        }
        data["notes"] = this.notes;
        data["isCompleted"] = this.isCompleted;
        data["ordering"] = this.ordering;
        data["weightUnit"] = this.weightUnit;
        return data;
    }
}

export interface IMovement {
    movementID?: string;
    trainingSessionID?: string;
    trainingSession?: TrainingSession;
    movementBaseID?: string;
    movementBase?: MovementBase;
    movementModifier: MovementModifier;
    sets?: SetEntry[] | undefined;
    notes?: string | undefined;
    isCompleted?: boolean;
    ordering: number;
    weightUnit?: WeightUnit;
}

export class MovementBase implements IMovementBase {
    movementBaseID?: string;
    name?: string | undefined;
    userID?: string;

    constructor(data?: IMovementBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementBaseID = _data["movementBaseID"];
            this.name = _data["name"];
            this.userID = _data["userID"];
        }
    }

    static fromJS(data: any): MovementBase {
        data = typeof data === 'object' ? data : {};
        let result = new MovementBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementBaseID"] = this.movementBaseID;
        data["name"] = this.name;
        data["userID"] = this.userID;
        return data;
    }
}

export interface IMovementBase {
    movementBaseID?: string;
    name?: string | undefined;
    userID?: string;
}

export class MovementDTO implements IMovementDTO {
    movementID!: string;
    trainingSessionID!: string;
    movementBaseID!: string;
    movementBase!: MovementBase;
    movementModifier!: MovementModifier;
    weightUnit!: WeightUnit;
    sets!: SetEntryDTO[];
    notes!: string | undefined;
    isCompleted!: boolean;
    ordering!: number;

    constructor(data?: IMovementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.movementBase = new MovementBase();
            this.movementModifier = new MovementModifier();
            this.sets = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementID = _data["movementID"];
            this.trainingSessionID = _data["trainingSessionID"];
            this.movementBaseID = _data["movementBaseID"];
            this.movementBase = _data["movementBase"] ? MovementBase.fromJS(_data["movementBase"]) : new MovementBase();
            this.movementModifier = _data["movementModifier"] ? MovementModifier.fromJS(_data["movementModifier"]) : new MovementModifier();
            this.weightUnit = _data["weightUnit"];
            if (Array.isArray(_data["sets"])) {
                this.sets = [] as any;
                for (let item of _data["sets"])
                    this.sets!.push(SetEntryDTO.fromJS(item));
            }
            this.notes = _data["notes"];
            this.isCompleted = _data["isCompleted"];
            this.ordering = _data["ordering"];
        }
    }

    static fromJS(data: any): MovementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MovementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementID"] = this.movementID;
        data["trainingSessionID"] = this.trainingSessionID;
        data["movementBaseID"] = this.movementBaseID;
        data["movementBase"] = this.movementBase ? this.movementBase.toJSON() : <any>undefined;
        data["movementModifier"] = this.movementModifier ? this.movementModifier.toJSON() : <any>undefined;
        data["weightUnit"] = this.weightUnit;
        if (Array.isArray(this.sets)) {
            data["sets"] = [];
            for (let item of this.sets)
                data["sets"].push(item ? item.toJSON() : <any>undefined);
        }
        data["notes"] = this.notes;
        data["isCompleted"] = this.isCompleted;
        data["ordering"] = this.ordering;
        return data;
    }
}

export interface IMovementDTO {
    movementID: string;
    trainingSessionID: string;
    movementBaseID: string;
    movementBase: MovementBase;
    movementModifier: MovementModifier;
    weightUnit: WeightUnit;
    sets: SetEntryDTO[];
    notes: string | undefined;
    isCompleted: boolean;
    ordering: number;
}

export class MovementModifier implements IMovementModifier {
    name?: string | undefined;
    equipmentID?: string;
    equipment!: Equipment;
    duration?: number;

    constructor(data?: IMovementModifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.equipment = new Equipment();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.equipmentID = _data["equipmentID"];
            this.equipment = _data["equipment"] ? Equipment.fromJS(_data["equipment"]) : new Equipment();
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): MovementModifier {
        data = typeof data === 'object' ? data : {};
        let result = new MovementModifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["equipmentID"] = this.equipmentID;
        data["equipment"] = this.equipment ? this.equipment.toJSON() : <any>undefined;
        data["duration"] = this.duration;
        return data;
    }
}

export interface IMovementModifier {
    name?: string | undefined;
    equipmentID?: string;
    equipment: Equipment;
    duration?: number;
}

export class MovementOrderUpdate implements IMovementOrderUpdate {
    movementID?: string;
    ordering?: number;

    constructor(data?: IMovementOrderUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementID = _data["movementID"];
            this.ordering = _data["ordering"];
        }
    }

    static fromJS(data: any): MovementOrderUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new MovementOrderUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementID"] = this.movementID;
        data["ordering"] = this.ordering;
        return data;
    }
}

export interface IMovementOrderUpdate {
    movementID?: string;
    ordering?: number;
}

export class MuscleSetsDto implements IMuscleSetsDto {
    quadSets?: number;
    hamstringSets?: number;
    bicepSets?: number;
    tricepSets?: number;
    shoulderSets?: number;
    chestSets?: number;
    backSets?: number;

    constructor(data?: IMuscleSetsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quadSets = _data["quadSets"];
            this.hamstringSets = _data["hamstringSets"];
            this.bicepSets = _data["bicepSets"];
            this.tricepSets = _data["tricepSets"];
            this.shoulderSets = _data["shoulderSets"];
            this.chestSets = _data["chestSets"];
            this.backSets = _data["backSets"];
        }
    }

    static fromJS(data: any): MuscleSetsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MuscleSetsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quadSets"] = this.quadSets;
        data["hamstringSets"] = this.hamstringSets;
        data["bicepSets"] = this.bicepSets;
        data["tricepSets"] = this.tricepSets;
        data["shoulderSets"] = this.shoulderSets;
        data["chestSets"] = this.chestSets;
        data["backSets"] = this.backSets;
        return data;
    }
}

export interface IMuscleSetsDto {
    quadSets?: number;
    hamstringSets?: number;
    bicepSets?: number;
    tricepSets?: number;
    shoulderSets?: number;
    chestSets?: number;
    backSets?: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class ProgramPreferencesDTO implements IProgramPreferencesDTO {
    daysPerWeek!: number;
    preferredDays!: string;
    squatDays?: number;
    benchDays?: number;
    deadliftDays?: number;
    favoriteMovements?: string | undefined;

    constructor(data?: IProgramPreferencesDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.daysPerWeek = _data["daysPerWeek"];
            this.preferredDays = _data["preferredDays"];
            this.squatDays = _data["squatDays"];
            this.benchDays = _data["benchDays"];
            this.deadliftDays = _data["deadliftDays"];
            this.favoriteMovements = _data["favoriteMovements"];
        }
    }

    static fromJS(data: any): ProgramPreferencesDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramPreferencesDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["daysPerWeek"] = this.daysPerWeek;
        data["preferredDays"] = this.preferredDays;
        data["squatDays"] = this.squatDays;
        data["benchDays"] = this.benchDays;
        data["deadliftDays"] = this.deadliftDays;
        data["favoriteMovements"] = this.favoriteMovements;
        return data;
    }
}

export interface IProgramPreferencesDTO {
    daysPerWeek: number;
    preferredDays: string;
    squatDays?: number;
    benchDays?: number;
    deadliftDays?: number;
    favoriteMovements?: string | undefined;
}

export class ReadinessData implements IReadinessData {
    readinessScore?: number;
    temperatureDeviation?: number;
    activityBalance?: number;
    bodyTemperature?: number;
    hrvBalance?: number;
    previousDayActivity?: number;
    previousNight?: number;
    recoveryIndex?: number;
    restingHeartRate?: number;
    sleepBalance?: number;

    constructor(data?: IReadinessData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.readinessScore = _data["readinessScore"];
            this.temperatureDeviation = _data["temperatureDeviation"];
            this.activityBalance = _data["activityBalance"];
            this.bodyTemperature = _data["bodyTemperature"];
            this.hrvBalance = _data["hrvBalance"];
            this.previousDayActivity = _data["previousDayActivity"];
            this.previousNight = _data["previousNight"];
            this.recoveryIndex = _data["recoveryIndex"];
            this.restingHeartRate = _data["restingHeartRate"];
            this.sleepBalance = _data["sleepBalance"];
        }
    }

    static fromJS(data: any): ReadinessData {
        data = typeof data === 'object' ? data : {};
        let result = new ReadinessData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["readinessScore"] = this.readinessScore;
        data["temperatureDeviation"] = this.temperatureDeviation;
        data["activityBalance"] = this.activityBalance;
        data["bodyTemperature"] = this.bodyTemperature;
        data["hrvBalance"] = this.hrvBalance;
        data["previousDayActivity"] = this.previousDayActivity;
        data["previousNight"] = this.previousNight;
        data["recoveryIndex"] = this.recoveryIndex;
        data["restingHeartRate"] = this.restingHeartRate;
        data["sleepBalance"] = this.sleepBalance;
        return data;
    }
}

export interface IReadinessData {
    readinessScore?: number;
    temperatureDeviation?: number;
    activityBalance?: number;
    bodyTemperature?: number;
    hrvBalance?: number;
    previousDayActivity?: number;
    previousNight?: number;
    recoveryIndex?: number;
    restingHeartRate?: number;
    sleepBalance?: number;
}

export class RefreshRequest implements IRefreshRequest {
    refreshToken!: string | undefined;

    constructor(data?: IRefreshRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshRequest {
    refreshToken: string | undefined;
}

export class RegisterRequest implements IRegisterRequest {
    email!: string | undefined;
    password!: string | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterRequest {
    email: string | undefined;
    password: string | undefined;
}

export class RemainingWeeksGenerationDTO implements IRemainingWeeksGenerationDTO {

    constructor(data?: IRemainingWeeksGenerationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): RemainingWeeksGenerationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RemainingWeeksGenerationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IRemainingWeeksGenerationDTO {
}

export class ResendConfirmationEmailRequest implements IResendConfirmationEmailRequest {
    email!: string | undefined;

    constructor(data?: IResendConfirmationEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResendConfirmationEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResendConfirmationEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IResendConfirmationEmailRequest {
    email: string | undefined;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    email!: string | undefined;
    resetCode!: string | undefined;
    newPassword!: string | undefined;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.resetCode = _data["resetCode"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["resetCode"] = this.resetCode;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordRequest {
    email: string | undefined;
    resetCode: string | undefined;
    newPassword: string | undefined;
}

export class ResilienceData implements IResilienceData {
    sleepRecovery?: number;
    daytimeRecovery?: number;
    stress?: number;
    resilienceLevel?: string | undefined;

    constructor(data?: IResilienceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sleepRecovery = _data["sleepRecovery"];
            this.daytimeRecovery = _data["daytimeRecovery"];
            this.stress = _data["stress"];
            this.resilienceLevel = _data["resilienceLevel"];
        }
    }

    static fromJS(data: any): ResilienceData {
        data = typeof data === 'object' ? data : {};
        let result = new ResilienceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sleepRecovery"] = this.sleepRecovery;
        data["daytimeRecovery"] = this.daytimeRecovery;
        data["stress"] = this.stress;
        data["resilienceLevel"] = this.resilienceLevel;
        return data;
    }
}

export interface IResilienceData {
    sleepRecovery?: number;
    daytimeRecovery?: number;
    stress?: number;
    resilienceLevel?: string | undefined;
}

export class RideDetails implements IRideDetails {
    activityID?: string;
    distance?: number;
    elevationGain?: number;
    averagePower?: number;
    averageSpeed?: number;
    rideType?: string | undefined;

    constructor(data?: IRideDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityID = _data["activityID"];
            this.distance = _data["distance"];
            this.elevationGain = _data["elevationGain"];
            this.averagePower = _data["averagePower"];
            this.averageSpeed = _data["averageSpeed"];
            this.rideType = _data["rideType"];
        }
    }

    static fromJS(data: any): RideDetails {
        data = typeof data === 'object' ? data : {};
        let result = new RideDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityID"] = this.activityID;
        data["distance"] = this.distance;
        data["elevationGain"] = this.elevationGain;
        data["averagePower"] = this.averagePower;
        data["averageSpeed"] = this.averageSpeed;
        data["rideType"] = this.rideType;
        return data;
    }
}

export interface IRideDetails {
    activityID?: string;
    distance?: number;
    elevationGain?: number;
    averagePower?: number;
    averageSpeed?: number;
    rideType?: string | undefined;
}

export class RunWalkDetails implements IRunWalkDetails {
    activityID?: string;
    distance?: number;
    elevationGain?: number;
    averagePaceInSeconds?: number;
    mileSplitsInSeconds?: number[] | undefined;
    runType?: string | undefined;

    constructor(data?: IRunWalkDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityID = _data["activityID"];
            this.distance = _data["distance"];
            this.elevationGain = _data["elevationGain"];
            this.averagePaceInSeconds = _data["averagePaceInSeconds"];
            if (Array.isArray(_data["mileSplitsInSeconds"])) {
                this.mileSplitsInSeconds = [] as any;
                for (let item of _data["mileSplitsInSeconds"])
                    this.mileSplitsInSeconds!.push(item);
            }
            this.runType = _data["runType"];
        }
    }

    static fromJS(data: any): RunWalkDetails {
        data = typeof data === 'object' ? data : {};
        let result = new RunWalkDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityID"] = this.activityID;
        data["distance"] = this.distance;
        data["elevationGain"] = this.elevationGain;
        data["averagePaceInSeconds"] = this.averagePaceInSeconds;
        if (Array.isArray(this.mileSplitsInSeconds)) {
            data["mileSplitsInSeconds"] = [];
            for (let item of this.mileSplitsInSeconds)
                data["mileSplitsInSeconds"].push(item);
        }
        data["runType"] = this.runType;
        return data;
    }
}

export interface IRunWalkDetails {
    activityID?: string;
    distance?: number;
    elevationGain?: number;
    averagePaceInSeconds?: number;
    mileSplitsInSeconds?: number[] | undefined;
    runType?: string | undefined;
}

export class SetEntry implements ISetEntry {
    setEntryID?: string;
    movementID?: string;
    movement?: Movement;
    recommendedReps?: number;
    recommendedWeight?: number;
    recommendedRPE?: number;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;

    constructor(data?: ISetEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryID = _data["setEntryID"];
            this.movementID = _data["movementID"];
            this.movement = _data["movement"] ? Movement.fromJS(_data["movement"]) : <any>undefined;
            this.recommendedReps = _data["recommendedReps"];
            this.recommendedWeight = _data["recommendedWeight"];
            this.recommendedRPE = _data["recommendedRPE"];
            this.actualReps = _data["actualReps"];
            this.actualWeight = _data["actualWeight"];
            this.actualRPE = _data["actualRPE"];
        }
    }

    static fromJS(data: any): SetEntry {
        data = typeof data === 'object' ? data : {};
        let result = new SetEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryID"] = this.setEntryID;
        data["movementID"] = this.movementID;
        data["movement"] = this.movement ? this.movement.toJSON() : <any>undefined;
        data["recommendedReps"] = this.recommendedReps;
        data["recommendedWeight"] = this.recommendedWeight;
        data["recommendedRPE"] = this.recommendedRPE;
        data["actualReps"] = this.actualReps;
        data["actualWeight"] = this.actualWeight;
        data["actualRPE"] = this.actualRPE;
        return data;
    }
}

export interface ISetEntry {
    setEntryID?: string;
    movementID?: string;
    movement?: Movement;
    recommendedReps?: number;
    recommendedWeight?: number;
    recommendedRPE?: number;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
}

export class SetEntryDTO implements ISetEntryDTO {
    setEntryID!: string;
    movementID!: string;
    recommendedReps!: number;
    recommendedWeight!: number;
    recommendedRPE!: number;
    actualReps!: number;
    actualWeight!: number;
    actualRPE!: number;

    constructor(data?: ISetEntryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryID = _data["setEntryID"];
            this.movementID = _data["movementID"];
            this.recommendedReps = _data["recommendedReps"];
            this.recommendedWeight = _data["recommendedWeight"];
            this.recommendedRPE = _data["recommendedRPE"];
            this.actualReps = _data["actualReps"];
            this.actualWeight = _data["actualWeight"];
            this.actualRPE = _data["actualRPE"];
        }
    }

    static fromJS(data: any): SetEntryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SetEntryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryID"] = this.setEntryID;
        data["movementID"] = this.movementID;
        data["recommendedReps"] = this.recommendedReps;
        data["recommendedWeight"] = this.recommendedWeight;
        data["recommendedRPE"] = this.recommendedRPE;
        data["actualReps"] = this.actualReps;
        data["actualWeight"] = this.actualWeight;
        data["actualRPE"] = this.actualRPE;
        return data;
    }
}

export interface ISetEntryDTO {
    setEntryID: string;
    movementID: string;
    recommendedReps: number;
    recommendedWeight: number;
    recommendedRPE: number;
    actualReps: number;
    actualWeight: number;
    actualRPE: number;
}

export class SleepData implements ISleepData {
    sleepScore?: number;
    deepSleep?: number;
    efficiency?: number;
    latency?: number;
    remSleep?: number;
    restfulness?: number;
    timing?: number;
    totalSleep?: number;

    constructor(data?: ISleepData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sleepScore = _data["sleepScore"];
            this.deepSleep = _data["deepSleep"];
            this.efficiency = _data["efficiency"];
            this.latency = _data["latency"];
            this.remSleep = _data["remSleep"];
            this.restfulness = _data["restfulness"];
            this.timing = _data["timing"];
            this.totalSleep = _data["totalSleep"];
        }
    }

    static fromJS(data: any): SleepData {
        data = typeof data === 'object' ? data : {};
        let result = new SleepData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sleepScore"] = this.sleepScore;
        data["deepSleep"] = this.deepSleep;
        data["efficiency"] = this.efficiency;
        data["latency"] = this.latency;
        data["remSleep"] = this.remSleep;
        data["restfulness"] = this.restfulness;
        data["timing"] = this.timing;
        data["totalSleep"] = this.totalSleep;
        return data;
    }
}

export interface ISleepData {
    sleepScore?: number;
    deepSleep?: number;
    efficiency?: number;
    latency?: number;
    remSleep?: number;
    restfulness?: number;
    timing?: number;
    totalSleep?: number;
}

export class TrainingProgram implements ITrainingProgram {
    trainingProgramID?: string;
    userID?: string;
    title?: string | undefined;
    startDate?: Date;
    nextTrainingSessionDate?: Date;
    endDate?: Date;
    isCompleted?: boolean;
    trainingSessions?: TrainingSession[] | undefined;
    tags?: string[] | undefined;

    constructor(data?: ITrainingProgram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingProgramID = _data["trainingProgramID"];
            this.userID = _data["userID"];
            this.title = _data["title"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.nextTrainingSessionDate = _data["nextTrainingSessionDate"] ? new Date(_data["nextTrainingSessionDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.isCompleted = _data["isCompleted"];
            if (Array.isArray(_data["trainingSessions"])) {
                this.trainingSessions = [] as any;
                for (let item of _data["trainingSessions"])
                    this.trainingSessions!.push(TrainingSession.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): TrainingProgram {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingProgram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramID"] = this.trainingProgramID;
        data["userID"] = this.userID;
        data["title"] = this.title;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["nextTrainingSessionDate"] = this.nextTrainingSessionDate ? formatDate(this.nextTrainingSessionDate) : <any>undefined;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        data["isCompleted"] = this.isCompleted;
        if (Array.isArray(this.trainingSessions)) {
            data["trainingSessions"] = [];
            for (let item of this.trainingSessions)
                data["trainingSessions"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface ITrainingProgram {
    trainingProgramID?: string;
    userID?: string;
    title?: string | undefined;
    startDate?: Date;
    nextTrainingSessionDate?: Date;
    endDate?: Date;
    isCompleted?: boolean;
    trainingSessions?: TrainingSession[] | undefined;
    tags?: string[] | undefined;
}

export class TrainingProgramDTO implements ITrainingProgramDTO {
    trainingProgramID!: string;
    title!: string;
    startDate!: Date;
    nextTrainingSessionDate!: Date;
    endDate!: Date;
    trainingSessions!: TrainingSessionDTO[];
    tags!: string[];
    isCompleted!: boolean;

    constructor(data?: ITrainingProgramDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.trainingSessions = [];
            this.tags = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingProgramID = _data["trainingProgramID"];
            this.title = _data["title"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.nextTrainingSessionDate = _data["nextTrainingSessionDate"] ? new Date(_data["nextTrainingSessionDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["trainingSessions"])) {
                this.trainingSessions = [] as any;
                for (let item of _data["trainingSessions"])
                    this.trainingSessions!.push(TrainingSessionDTO.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.isCompleted = _data["isCompleted"];
        }
    }

    static fromJS(data: any): TrainingProgramDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingProgramDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramID"] = this.trainingProgramID;
        data["title"] = this.title;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["nextTrainingSessionDate"] = this.nextTrainingSessionDate ? formatDate(this.nextTrainingSessionDate) : <any>undefined;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        if (Array.isArray(this.trainingSessions)) {
            data["trainingSessions"] = [];
            for (let item of this.trainingSessions)
                data["trainingSessions"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["isCompleted"] = this.isCompleted;
        return data;
    }
}

export interface ITrainingProgramDTO {
    trainingProgramID: string;
    title: string;
    startDate: Date;
    nextTrainingSessionDate: Date;
    endDate: Date;
    trainingSessions: TrainingSessionDTO[];
    tags: string[];
    isCompleted: boolean;
}

export class TrainingSession implements ITrainingSession {
    trainingSessionID?: string;
    trainingProgramID?: string;
    trainingProgram?: TrainingProgram;
    date?: Date;
    status?: TrainingSessionStatus;
    movements?: Movement[] | undefined;
    creationTime?: Date;

    constructor(data?: ITrainingSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            this.trainingProgramID = _data["trainingProgramID"];
            this.trainingProgram = _data["trainingProgram"] ? TrainingProgram.fromJS(_data["trainingProgram"]) : <any>undefined;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            if (Array.isArray(_data["movements"])) {
                this.movements = [] as any;
                for (let item of _data["movements"])
                    this.movements!.push(Movement.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingSession {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        data["trainingProgramID"] = this.trainingProgramID;
        data["trainingProgram"] = this.trainingProgram ? this.trainingProgram.toJSON() : <any>undefined;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["status"] = this.status;
        if (Array.isArray(this.movements)) {
            data["movements"] = [];
            for (let item of this.movements)
                data["movements"].push(item ? item.toJSON() : <any>undefined);
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainingSession {
    trainingSessionID?: string;
    trainingProgramID?: string;
    trainingProgram?: TrainingProgram;
    date?: Date;
    status?: TrainingSessionStatus;
    movements?: Movement[] | undefined;
    creationTime?: Date;
}

export class TrainingSessionDTO implements ITrainingSessionDTO {
    trainingSessionID!: string;
    trainingProgramID!: string;
    sessionNumber!: number;
    date!: Date;
    status!: TrainingSessionStatus;
    movements!: MovementDTO[];

    constructor(data?: ITrainingSessionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.movements = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            this.trainingProgramID = _data["trainingProgramID"];
            this.sessionNumber = _data["sessionNumber"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            if (Array.isArray(_data["movements"])) {
                this.movements = [] as any;
                for (let item of _data["movements"])
                    this.movements!.push(MovementDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainingSessionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSessionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        data["trainingProgramID"] = this.trainingProgramID;
        data["sessionNumber"] = this.sessionNumber;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["status"] = this.status;
        if (Array.isArray(this.movements)) {
            data["movements"] = [];
            for (let item of this.movements)
                data["movements"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ITrainingSessionDTO {
    trainingSessionID: string;
    trainingProgramID: string;
    sessionNumber: number;
    date: Date;
    status: TrainingSessionStatus;
    movements: MovementDTO[];
}

export enum TrainingSessionStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TwoFactorRequest implements ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;

    constructor(data?: ITwoFactorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enable = _data["enable"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.resetSharedKey = _data["resetSharedKey"];
            this.resetRecoveryCodes = _data["resetRecoveryCodes"];
            this.forgetMachine = _data["forgetMachine"];
        }
    }

    static fromJS(data: any): TwoFactorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enable"] = this.enable;
        data["twoFactorCode"] = this.twoFactorCode;
        data["resetSharedKey"] = this.resetSharedKey;
        data["resetRecoveryCodes"] = this.resetRecoveryCodes;
        data["forgetMachine"] = this.forgetMachine;
        return data;
    }
}

export interface ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;
}

export class TwoFactorResponse implements ITwoFactorResponse {
    sharedKey!: string | undefined;
    recoveryCodesLeft!: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled!: boolean;
    isMachineRemembered!: boolean;

    constructor(data?: ITwoFactorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sharedKey = _data["sharedKey"];
            this.recoveryCodesLeft = _data["recoveryCodesLeft"];
            if (Array.isArray(_data["recoveryCodes"])) {
                this.recoveryCodes = [] as any;
                for (let item of _data["recoveryCodes"])
                    this.recoveryCodes!.push(item);
            }
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isMachineRemembered = _data["isMachineRemembered"];
        }
    }

    static fromJS(data: any): TwoFactorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sharedKey"] = this.sharedKey;
        data["recoveryCodesLeft"] = this.recoveryCodesLeft;
        if (Array.isArray(this.recoveryCodes)) {
            data["recoveryCodes"] = [];
            for (let item of this.recoveryCodes)
                data["recoveryCodes"].push(item);
        }
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isMachineRemembered"] = this.isMachineRemembered;
        return data;
    }
}

export interface ITwoFactorResponse {
    sharedKey: string | undefined;
    recoveryCodesLeft: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled: boolean;
    isMachineRemembered: boolean;
}

export class UpdateMovementOrderRequest implements IUpdateMovementOrderRequest {
    trainingSessionID?: string;
    movements?: MovementOrderUpdate[] | undefined;

    constructor(data?: IUpdateMovementOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            if (Array.isArray(_data["movements"])) {
                this.movements = [] as any;
                for (let item of _data["movements"])
                    this.movements!.push(MovementOrderUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateMovementOrderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMovementOrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        if (Array.isArray(this.movements)) {
            data["movements"] = [];
            for (let item of this.movements)
                data["movements"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IUpdateMovementOrderRequest {
    trainingSessionID?: string;
    movements?: MovementOrderUpdate[] | undefined;
}

export class UpdateMovementRequest implements IUpdateMovementRequest {
    movementID!: string;
    movementBaseID!: string;
    movementModifier!: MovementModifier;
    notes!: string;
    trainingSessionID!: string;
    isCompleted!: boolean;
    weightUnit!: WeightUnit;

    constructor(data?: IUpdateMovementRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.movementModifier = new MovementModifier();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementID = _data["movementID"];
            this.movementBaseID = _data["movementBaseID"];
            this.movementModifier = _data["movementModifier"] ? MovementModifier.fromJS(_data["movementModifier"]) : new MovementModifier();
            this.notes = _data["notes"];
            this.trainingSessionID = _data["trainingSessionID"];
            this.isCompleted = _data["isCompleted"];
            this.weightUnit = _data["weightUnit"];
        }
    }

    static fromJS(data: any): UpdateMovementRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMovementRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementID"] = this.movementID;
        data["movementBaseID"] = this.movementBaseID;
        data["movementModifier"] = this.movementModifier ? this.movementModifier.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        data["trainingSessionID"] = this.trainingSessionID;
        data["isCompleted"] = this.isCompleted;
        data["weightUnit"] = this.weightUnit;
        return data;
    }
}

export interface IUpdateMovementRequest {
    movementID: string;
    movementBaseID: string;
    movementModifier: MovementModifier;
    notes: string;
    trainingSessionID: string;
    isCompleted: boolean;
    weightUnit: WeightUnit;
}

export class UpdateMovementsCompletionRequest implements IUpdateMovementsCompletionRequest {
    trainingSessionID!: string;
    complete!: boolean;

    constructor(data?: IUpdateMovementsCompletionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            this.complete = _data["complete"];
        }
    }

    static fromJS(data: any): UpdateMovementsCompletionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMovementsCompletionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        data["complete"] = this.complete;
        return data;
    }
}

export interface IUpdateMovementsCompletionRequest {
    trainingSessionID: string;
    complete: boolean;
}

export class UpdateSetEntryRequest implements IUpdateSetEntryRequest {
    setEntryID!: string;
    recommendedReps!: number;
    recommendedWeight!: number;
    recommendedRPE!: number;
    actualReps!: number;
    actualWeight!: number;
    actualRPE!: number;
    movementID!: string;

    constructor(data?: IUpdateSetEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryID = _data["setEntryID"];
            this.recommendedReps = _data["recommendedReps"];
            this.recommendedWeight = _data["recommendedWeight"];
            this.recommendedRPE = _data["recommendedRPE"];
            this.actualReps = _data["actualReps"];
            this.actualWeight = _data["actualWeight"];
            this.actualRPE = _data["actualRPE"];
            this.movementID = _data["movementID"];
        }
    }

    static fromJS(data: any): UpdateSetEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSetEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryID"] = this.setEntryID;
        data["recommendedReps"] = this.recommendedReps;
        data["recommendedWeight"] = this.recommendedWeight;
        data["recommendedRPE"] = this.recommendedRPE;
        data["actualReps"] = this.actualReps;
        data["actualWeight"] = this.actualWeight;
        data["actualRPE"] = this.actualRPE;
        data["movementID"] = this.movementID;
        return data;
    }
}

export interface IUpdateSetEntryRequest {
    setEntryID: string;
    recommendedReps: number;
    recommendedWeight: number;
    recommendedRPE: number;
    actualReps: number;
    actualWeight: number;
    actualRPE: number;
    movementID: string;
}

export class UpdateTrainingProgramRequest implements IUpdateTrainingProgramRequest {
    trainingProgramID!: string;
    title!: string;
    startDate!: Date;
    endDate!: Date;
    tags!: string[];
    isCompleted!: boolean;

    constructor(data?: IUpdateTrainingProgramRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tags = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingProgramID = _data["trainingProgramID"];
            this.title = _data["title"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.isCompleted = _data["isCompleted"];
        }
    }

    static fromJS(data: any): UpdateTrainingProgramRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTrainingProgramRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramID"] = this.trainingProgramID;
        data["title"] = this.title;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["isCompleted"] = this.isCompleted;
        return data;
    }
}

export interface IUpdateTrainingProgramRequest {
    trainingProgramID: string;
    title: string;
    startDate: Date;
    endDate: Date;
    tags: string[];
    isCompleted: boolean;
}

export class UpdateTrainingSessionRequest implements IUpdateTrainingSessionRequest {
    trainingProgramID!: string;
    date!: Date;
    status!: TrainingSessionStatus;
    trainingSessionID?: string;

    constructor(data?: IUpdateTrainingSessionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingProgramID = _data["trainingProgramID"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.trainingSessionID = _data["trainingSessionID"];
        }
    }

    static fromJS(data: any): UpdateTrainingSessionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTrainingSessionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramID"] = this.trainingProgramID;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["status"] = this.status;
        data["trainingSessionID"] = this.trainingSessionID;
        return data;
    }
}

export interface IUpdateTrainingSessionRequest {
    trainingProgramID: string;
    date: Date;
    status: TrainingSessionStatus;
    trainingSessionID?: string;
}

export enum WeightUnit {
    _0 = 0,
    _1 = 1,
}

export class WellnessState implements IWellnessState {
    stateID?: string;
    userID?: string;
    date?: Date;
    motivationScore?: number;
    stressScore?: number;
    moodScore?: number;
    energyScore?: number;
    overallScore?: number;

    constructor(data?: IWellnessState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stateID = _data["stateID"];
            this.userID = _data["userID"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.motivationScore = _data["motivationScore"];
            this.stressScore = _data["stressScore"];
            this.moodScore = _data["moodScore"];
            this.energyScore = _data["energyScore"];
            this.overallScore = _data["overallScore"];
        }
    }

    static fromJS(data: any): WellnessState {
        data = typeof data === 'object' ? data : {};
        let result = new WellnessState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stateID"] = this.stateID;
        data["userID"] = this.userID;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["motivationScore"] = this.motivationScore;
        data["stressScore"] = this.stressScore;
        data["moodScore"] = this.moodScore;
        data["energyScore"] = this.energyScore;
        data["overallScore"] = this.overallScore;
        return data;
    }
}

export interface IWellnessState {
    stateID?: string;
    userID?: string;
    date?: Date;
    motivationScore?: number;
    stressScore?: number;
    moodScore?: number;
    energyScore?: number;
    overallScore?: number;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}