//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AddActivityEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    addActivity(body: CreateActivityRequest | undefined): Promise<Activity> {
        let url_ = this.baseUrl + "/api/activity/add-activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddActivity(_response);
        });
    }

    protected processAddActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Activity.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = Activity.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }
}

export class AddAIReviewEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addAiReview(body: AddAIReviewRequest | undefined): Promise<SessionReportDTO> {
        let url_ = this.baseUrl + "/api/session-report/add-ai-review";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddAiReview(_response);
        });
    }

    protected processAddAiReview(response: Response): Promise<SessionReportDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionReportDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SessionReportDTO>(null as any);
    }
}

export class AddDailyRundownAIInsightsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    aiInsights(body: AddDailyRundownAIInsightsRequest | undefined): Promise<DailyRundownDTO> {
        let url_ = this.baseUrl + "/api/daily-report/rundown/ai-insights";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAiInsights(_response);
        });
    }

    protected processAiInsights(response: Response): Promise<DailyRundownDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DailyRundownDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyRundownDTO>(null as any);
    }
}

export class AddLiftActivityEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    addLiftActivity(body: CreateLiftRequest | undefined): Promise<Activity> {
        let url_ = this.baseUrl + "/api/activity/add-lift-activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddLiftActivity(_response);
        });
    }

    protected processAddLiftActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Activity.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = Activity.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }
}

export class AddNightlyBreakdownAIReviewEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    aiReview(body: AddNightlyBreakdownAIReviewRequest | undefined): Promise<NightlyBreakdownDTO> {
        let url_ = this.baseUrl + "/api/daily-report/breakdown/ai-review";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAiReview(_response);
        });
    }

    protected processAiReview(response: Response): Promise<NightlyBreakdownDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NightlyBreakdownDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NightlyBreakdownDTO>(null as any);
    }
}

export class AddRideActivityEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    addRideActivity(body: CreateRideRequest | undefined): Promise<Activity> {
        let url_ = this.baseUrl + "/api/activity/add-ride-activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddRideActivity(_response);
        });
    }

    protected processAddRideActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Activity.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = Activity.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }
}

export class AddRunWalkActivityEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    addRunwalkActivity(body: CreateRunWalkRequest | undefined): Promise<Activity> {
        let url_ = this.baseUrl + "/api/activity/add-runwalk-activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddRunwalkActivity(_response);
        });
    }

    protected processAddRunwalkActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Activity.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = Activity.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }
}

export class AddWellnessStateEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    add(body: CreateWellnessStateRequest | undefined): Promise<Activity> {
        let url_ = this.baseUrl + "/api/wellness/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Activity.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = Activity.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }
}

export class CreateDTSetEntryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create(body: CreateDTSetEntryRequest | undefined): Promise<DTSetEntryDTO> {
        let url_ = this.baseUrl + "/api/dt-set-entry/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<DTSetEntryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DTSetEntryDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DTSetEntryDTO>(null as any);
    }
}

export class CreateEquipmentEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create2(body: CreateEquipmentRequest | undefined): Promise<Equipment> {
        let url_ = this.baseUrl + "/api/equipment/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate2(_response);
        });
    }

    protected processCreate2(response: Response): Promise<Equipment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Equipment.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Equipment>(null as any);
    }
}

export class CreateInjuryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create3(body: CreateInjuryRequest | undefined): Promise<InjuryDTO> {
        let url_ = this.baseUrl + "/api/injury/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate3(_response);
        });
    }

    protected processCreate3(response: Response): Promise<InjuryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = InjuryDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InjuryDTO>(null as any);
    }
}

export class CreateInjuryEventEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addEvent(body: CreateInjuryEventRequest | undefined): Promise<InjuryDTO> {
        let url_ = this.baseUrl + "/api/injury/add-event";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddEvent(_response);
        });
    }

    protected processAddEvent(response: Response): Promise<InjuryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InjuryDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InjuryDTO>(null as any);
    }
}

export class CreateLiftSetEntryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create4(body: CreateLiftSetEntryRequest | undefined): Promise<LiftSetEntryDTO> {
        let url_ = this.baseUrl + "/api/lift-set-entry/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate4(_response);
        });
    }

    protected processCreate4(response: Response): Promise<LiftSetEntryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = LiftSetEntryDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LiftSetEntryDTO>(null as any);
    }
}

export class CreateMovementBaseEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create5(body: CreateMovementBaseRequest | undefined): Promise<MovementBase> {
        let url_ = this.baseUrl + "/api/movement-base/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate5(_response);
        });
    }

    protected processCreate5(response: Response): Promise<MovementBase> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MovementBase.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementBase>(null as any);
    }
}

export class CreateMovementEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create6(body: CreateMovementRequest | undefined): Promise<MovementDTO> {
        let url_ = this.baseUrl + "/api/movement/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate6(_response);
        });
    }

    protected processCreate6(response: Response): Promise<MovementDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MovementDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementDTO>(null as any);
    }
}

export class CreateProfileEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    createProfile(body: CreateProfileRequest | undefined): Promise<LionheartUser> {
        let url_ = this.baseUrl + "/api/user/create-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProfile(_response);
        });
    }

    protected processCreateProfile(response: Response): Promise<LionheartUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = LionheartUser.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LionheartUser>(null as any);
    }
}

export class CreateSessionFromParsedDataEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createFromParsed(body: CreateSessionFromParsedDataRequest | undefined): Promise<TrainingSessionDTO> {
        let url_ = this.baseUrl + "/api/session/create-from-parsed";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFromParsed(_response);
        });
    }

    protected processCreateFromParsed(response: Response): Promise<TrainingSessionDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSessionDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO>(null as any);
    }
}

export class CreateTrainingProgramEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create7(body: CreateTrainingProgramRequest | undefined): Promise<TrainingProgramDTO> {
        let url_ = this.baseUrl + "/api/training-program/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate7(_response);
        });
    }

    protected processCreate7(response: Response): Promise<TrainingProgramDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingProgramDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingProgramDTO>(null as any);
    }
}

export class CreateTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create8(body: CreateTrainingSessionRequest | undefined): Promise<TrainingSessionDTO> {
        let url_ = this.baseUrl + "/api/training-session/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate8(_response);
        });
    }

    protected processCreate8(response: Response): Promise<TrainingSessionDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TrainingSessionDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO>(null as any);
    }
}

export class DeleteDailyRundownEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    rundownDELETE(dailyRundownId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/daily-report/rundown/{dailyRundownId}";
        if (dailyRundownId === undefined || dailyRundownId === null)
            throw new Error("The parameter 'dailyRundownId' must be defined.");
        url_ = url_.replace("{dailyRundownId}", encodeURIComponent("" + dailyRundownId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRundownDELETE(_response);
        });
    }

    protected processRundownDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class GetDailyRundownEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    rundownGET(dailyRundownId: string): Promise<DailyRundownDTO> {
        let url_ = this.baseUrl + "/api/daily-report/rundown/{dailyRundownId}";
        if (dailyRundownId === undefined || dailyRundownId === null)
            throw new Error("The parameter 'dailyRundownId' must be defined.");
        url_ = url_.replace("{dailyRundownId}", encodeURIComponent("" + dailyRundownId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRundownGET(_response);
        });
    }

    protected processRundownGET(response: Response): Promise<DailyRundownDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DailyRundownDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyRundownDTO>(null as any);
    }
}

export class DeleteDTSetEntryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete(setEntryId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/dt-set-entry/delete/{setEntryId}";
        if (setEntryId === undefined || setEntryId === null)
            throw new Error("The parameter 'setEntryId' must be defined.");
        url_ = url_.replace("{setEntryId}", encodeURIComponent("" + setEntryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteEquipmentEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete2(equipmentId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/equipment/delete/{equipmentId}";
        if (equipmentId === undefined || equipmentId === null)
            throw new Error("The parameter 'equipmentId' must be defined.");
        url_ = url_.replace("{equipmentId}", encodeURIComponent("" + equipmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete2(_response);
        });
    }

    protected processDelete2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteInjuryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete3(injuryId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/injury/delete/{injuryId}";
        if (injuryId === undefined || injuryId === null)
            throw new Error("The parameter 'injuryId' must be defined.");
        url_ = url_.replace("{injuryId}", encodeURIComponent("" + injuryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete3(_response);
        });
    }

    protected processDelete3(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteInjuryEventEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    eventDELETE(injuryEventId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/injury/event/{injuryEventId}";
        if (injuryEventId === undefined || injuryEventId === null)
            throw new Error("The parameter 'injuryEventId' must be defined.");
        url_ = url_.replace("{injuryEventId}", encodeURIComponent("" + injuryEventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEventDELETE(_response);
        });
    }

    protected processEventDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteLiftSetEntryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete4(setEntryId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/lift-set-entry/delete/{setEntryId}";
        if (setEntryId === undefined || setEntryId === null)
            throw new Error("The parameter 'setEntryId' must be defined.");
        url_ = url_.replace("{setEntryId}", encodeURIComponent("" + setEntryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete4(_response);
        });
    }

    protected processDelete4(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteMovementBaseEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete5(movementBaseId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/movement-base/delete/{movementBaseId}";
        if (movementBaseId === undefined || movementBaseId === null)
            throw new Error("The parameter 'movementBaseId' must be defined.");
        url_ = url_.replace("{movementBaseId}", encodeURIComponent("" + movementBaseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete5(_response);
        });
    }

    protected processDelete5(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteMovementEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete6(movementId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/movement/delete/{movementId}";
        if (movementId === undefined || movementId === null)
            throw new Error("The parameter 'movementId' must be defined.");
        url_ = url_.replace("{movementId}", encodeURIComponent("" + movementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete6(_response);
        });
    }

    protected processDelete6(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteNightlyBreakdownEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    breakdownDELETE(nightlyBreakdownId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/daily-report/breakdown/{nightlyBreakdownId}";
        if (nightlyBreakdownId === undefined || nightlyBreakdownId === null)
            throw new Error("The parameter 'nightlyBreakdownId' must be defined.");
        url_ = url_.replace("{nightlyBreakdownId}", encodeURIComponent("" + nightlyBreakdownId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBreakdownDELETE(_response);
        });
    }

    protected processBreakdownDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class GetNightlyBreakdownEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    breakdownGET(nightlyBreakdownId: string): Promise<NightlyBreakdownDTO> {
        let url_ = this.baseUrl + "/api/daily-report/breakdown/{nightlyBreakdownId}";
        if (nightlyBreakdownId === undefined || nightlyBreakdownId === null)
            throw new Error("The parameter 'nightlyBreakdownId' must be defined.");
        url_ = url_.replace("{nightlyBreakdownId}", encodeURIComponent("" + nightlyBreakdownId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBreakdownGET(_response);
        });
    }

    protected processBreakdownGET(response: Response): Promise<NightlyBreakdownDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NightlyBreakdownDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NightlyBreakdownDTO>(null as any);
    }
}

export class DeleteSessionReportEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    sessionReportDELETE(sessionReportID: string): Promise<void> {
        let url_ = this.baseUrl + "/api/session-report/{sessionReportID}";
        if (sessionReportID === undefined || sessionReportID === null)
            throw new Error("The parameter 'sessionReportID' must be defined.");
        url_ = url_.replace("{sessionReportID}", encodeURIComponent("" + sessionReportID));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSessionReportDELETE(_response);
        });
    }

    protected processSessionReportDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class GetSessionReportEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    sessionReportGET(sessionReportID: string): Promise<SessionReportDTO> {
        let url_ = this.baseUrl + "/api/session-report/{sessionReportID}";
        if (sessionReportID === undefined || sessionReportID === null)
            throw new Error("The parameter 'sessionReportID' must be defined.");
        url_ = url_.replace("{sessionReportID}", encodeURIComponent("" + sessionReportID));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSessionReportGET(_response);
        });
    }

    protected processSessionReportGET(response: Response): Promise<SessionReportDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionReportDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SessionReportDTO>(null as any);
    }
}

export class DeleteTrainingProgramEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete7(programId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/training-program/delete/{programId}";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete7(_response);
        });
    }

    protected processDelete7(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeleteTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return No Content
     */
    delete8(trainingSessionId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/training-session/delete/{trainingSessionId}";
        if (trainingSessionId === undefined || trainingSessionId === null)
            throw new Error("The parameter 'trainingSessionId' must be defined.");
        url_ = url_.replace("{trainingSessionId}", encodeURIComponent("" + trainingSessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete8(_response);
        });
    }

    protected processDelete8(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DuplicateTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    duplicate(trainingSessionId: string): Promise<TrainingSessionDTO> {
        let url_ = this.baseUrl + "/api/training-session/duplicate/{trainingSessionId}";
        if (trainingSessionId === undefined || trainingSessionId === null)
            throw new Error("The parameter 'trainingSessionId' must be defined.");
        url_ = url_.replace("{trainingSessionId}", encodeURIComponent("" + trainingSessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDuplicate(_response);
        });
    }

    protected processDuplicate(response: Response): Promise<TrainingSessionDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSessionDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO>(null as any);
    }
}

export class GenerateDailyRundownEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    generate(body: GenerateDailyRundownRequest | undefined): Promise<DailyRundownDTO> {
        let url_ = this.baseUrl + "/api/daily-report/rundown/generate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerate(_response);
        });
    }

    protected processGenerate(response: Response): Promise<DailyRundownDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DailyRundownDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyRundownDTO>(null as any);
    }
}

export class GenerateNightlyBreakdownEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    generate2(body: GenerateNightlyBreakdownRequest | undefined): Promise<NightlyBreakdownDTO> {
        let url_ = this.baseUrl + "/api/daily-report/breakdown/generate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerate2(_response);
        });
    }

    protected processGenerate2(response: Response): Promise<NightlyBreakdownDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = NightlyBreakdownDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NightlyBreakdownDTO>(null as any);
    }
}

export class GenerateSessionReportEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    generate3(body: GenerateSessionReportRequest | undefined): Promise<SessionReportDTO> {
        let url_ = this.baseUrl + "/api/session-report/generate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerate3(_response);
        });
    }

    protected processGenerate3(response: Response): Promise<SessionReportDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SessionReportDTO.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SessionReportDTO>(null as any);
    }
}

export class GetActivitiesEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getActivities(startDate: Date, endDate: Date): Promise<Activity[]> {
        let url_ = this.baseUrl + "/api/activity/get-activities?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivities(_response);
        });
    }

    protected processGetActivities(response: Response): Promise<Activity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Activity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData401)) {
                result401 = [] as any;
                for (let item of resultData401)
                    result401!.push(Activity.fromJS(item));
            }
            else {
                result401 = <any>null;
            }
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity[]>(null as any);
    }
}

export class GetActivityMinutesEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getActivityMinutes(startDate: Date, endDate: Date): Promise<number> {
        let url_ = this.baseUrl + "/api/activity/get-activity-minutes?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivityMinutes(_response);
        });
    }

    protected processGetActivityMinutes(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }
}

export class GetActivityTypeRatioEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getActivityTypeRatio(startDate: Date, endDate: Date): Promise<ActivityTypeRatioDto> {
        let url_ = this.baseUrl + "/api/activity/get-activity-type-ratio?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivityTypeRatio(_response);
        });
    }

    protected processGetActivityTypeRatio(response: Response): Promise<ActivityTypeRatioDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityTypeRatioDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ProblemDetails.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ActivityTypeRatioDto>(null as any);
    }
}

export class GetDailyOuraDataEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param request (optional) 
     * @return OK
     */
    getDailyOuraData(request: Date | undefined): Promise<DailyOuraDataDTO> {
        let url_ = this.baseUrl + "/api/oura/get-daily-oura-data?";
        if (request === null)
            throw new Error("The parameter 'request' cannot be null.");
        else if (request !== undefined)
            url_ += "request=" + encodeURIComponent(request ? "" + request.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDailyOuraData(_response);
        });
    }

    protected processGetDailyOuraData(response: Response): Promise<DailyOuraDataDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DailyOuraDataDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyOuraDataDTO>(null as any);
    }
}

export class GetDailyRundownByDateEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    date(date: Date): Promise<DailyRundownDTO> {
        let url_ = this.baseUrl + "/api/daily-report/rundown/date/{date}";
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent(date ? "" + date.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDate(_response);
        });
    }

    protected processDate(response: Response): Promise<DailyRundownDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DailyRundownDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyRundownDTO>(null as any);
    }
}

export class GetDailyRundownsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param limit (optional) 
     * @param offset (optional) 
     * @return OK
     */
    rundownAll(startDate: Date | undefined, endDate: Date | undefined, limit: number | undefined, offset: number | undefined): Promise<DailyRundownSummaryDTO[]> {
        let url_ = this.baseUrl + "/api/daily-report/rundown?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRundownAll(_response);
        });
    }

    protected processRundownAll(response: Response): Promise<DailyRundownSummaryDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DailyRundownSummaryDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyRundownSummaryDTO[]>(null as any);
    }
}

export class GetEquipmentsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getAll(): Promise<Equipment[]> {
        let url_ = this.baseUrl + "/api/equipment/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<Equipment[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Equipment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Equipment[]>(null as any);
    }
}

export class GetMovementBasesEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getAll2(): Promise<MovementBase[]> {
        let url_ = this.baseUrl + "/api/movement-base/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll2(_response);
        });
    }

    protected processGetAll2(response: Response): Promise<MovementBase[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MovementBase.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovementBase[]>(null as any);
    }
}

export class GetMovementsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getAll3(sessionID: string): Promise<Movement[]> {
        let url_ = this.baseUrl + "/api/movement/get-all/{sessionId}";
        if (sessionID === undefined || sessionID === null)
            throw new Error("The parameter 'sessionID' must be defined.");
        url_ = url_.replace("{sessionID}", encodeURIComponent("" + sessionID));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll3(_response);
        });
    }

    protected processGetAll3(response: Response): Promise<Movement[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Movement.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Movement[]>(null as any);
    }
}

export class GetMuscleSetsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getMuscleSets(startDate: Date, endDate: Date): Promise<MuscleSetsDto> {
        let url_ = this.baseUrl + "/api/activity/get-muscle-sets?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMuscleSets(_response);
        });
    }

    protected processGetMuscleSets(response: Response): Promise<MuscleSetsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MuscleSetsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = MuscleSetsDto.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MuscleSetsDto>(null as any);
    }
}

export class GetNightlyBreakdownByDateEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    date2(date: Date): Promise<NightlyBreakdownDTO> {
        let url_ = this.baseUrl + "/api/daily-report/breakdown/date/{date}";
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent(date ? "" + date.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDate2(_response);
        });
    }

    protected processDate2(response: Response): Promise<NightlyBreakdownDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NightlyBreakdownDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NightlyBreakdownDTO>(null as any);
    }
}

export class GetNightlyBreakdownsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param limit (optional) 
     * @param offset (optional) 
     * @return OK
     */
    breakdownAll(startDate: Date | undefined, endDate: Date | undefined, limit: number | undefined, offset: number | undefined): Promise<NightlyBreakdownSummaryDTO[]> {
        let url_ = this.baseUrl + "/api/daily-report/breakdown?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBreakdownAll(_response);
        });
    }

    protected processBreakdownAll(response: Response): Promise<NightlyBreakdownSummaryDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NightlyBreakdownSummaryDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NightlyBreakdownSummaryDTO[]>(null as any);
    }
}

export class GetReportByTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    bySession(trainingSessionID: string): Promise<SessionReportDTO> {
        let url_ = this.baseUrl + "/api/session-report/by-session/{trainingSessionID}";
        if (trainingSessionID === undefined || trainingSessionID === null)
            throw new Error("The parameter 'trainingSessionID' must be defined.");
        url_ = url_.replace("{trainingSessionID}", encodeURIComponent("" + trainingSessionID));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBySession(_response);
        });
    }

    protected processBySession(response: Response): Promise<SessionReportDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionReportDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SessionReportDTO>(null as any);
    }
}

export class GetSessionReportsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param limit (optional) 
     * @param offset (optional) 
     * @return OK
     */
    list(startDate: Date | undefined, endDate: Date | undefined, limit: number | undefined, offset: number | undefined): Promise<SessionReportSummaryDTO[]> {
        let url_ = this.baseUrl + "/api/session-report/list?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<SessionReportSummaryDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SessionReportSummaryDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SessionReportSummaryDTO[]>(null as any);
    }
}

export class GetTrainingProgramEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get(programId: string): Promise<TrainingProgramDTO> {
        let url_ = this.baseUrl + "/api/training-program/get/{programId}";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TrainingProgramDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingProgramDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingProgramDTO>(null as any);
    }
}

export class GetTrainingProgramsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getAll4(): Promise<TrainingProgramDTO[]> {
        let url_ = this.baseUrl + "/api/training-program/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll4(_response);
        });
    }

    protected processGetAll4(response: Response): Promise<TrainingProgramDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingProgramDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingProgramDTO[]>(null as any);
    }
}

export class GetTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    get2(sessionId: string, programId: string): Promise<TrainingSessionDTO> {
        let url_ = this.baseUrl + "/api/training-session/get/{programId}/{sessionId}";
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<TrainingSessionDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSessionDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO>(null as any);
    }
}

export class GetTrainingSessionsEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getAll5(trainingProgramId: string): Promise<TrainingSessionDTO[]> {
        let url_ = this.baseUrl + "/api/training-session/get-all/{trainingProgramId}";
        if (trainingProgramId === undefined || trainingProgramId === null)
            throw new Error("The parameter 'trainingProgramId' must be defined.");
        url_ = url_.replace("{trainingProgramId}", encodeURIComponent("" + trainingProgramId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll5(_response);
        });
    }

    protected processGetAll5(response: Response): Promise<TrainingSessionDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingSessionDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO[]>(null as any);
    }
}

export class GetUserInjuriesEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getUserInjuries(): Promise<InjuryDTO[]> {
        let url_ = this.baseUrl + "/api/injury/get-user-injuries";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserInjuries(_response);
        });
    }

    protected processGetUserInjuries(response: Response): Promise<InjuryDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InjuryDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InjuryDTO[]>(null as any);
    }
}

export class GetWellnessStateEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param date (optional) 
     * @return OK
     */
    get3(date: Date | undefined): Promise<WellnessState> {
        let url_ = this.baseUrl + "/api/wellness/get?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet3(_response);
        });
    }

    protected processGet3(response: Response): Promise<WellnessState> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WellnessState.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WellnessState.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WellnessState>(null as any);
    }
}

export class GetWellnessStatesEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getRange(startDate: Date, endDate: Date): Promise<WellnessState[]> {
        let url_ = this.baseUrl + "/api/wellness/get-range?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRange(_response);
        });
    }

    protected processGetRange(response: Response): Promise<WellnessState[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WellnessState.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData401)) {
                result401 = [] as any;
                for (let item of resultData401)
                    result401!.push(WellnessState.fromJS(item));
            }
            else {
                result401 = <any>null;
            }
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WellnessState[]>(null as any);
    }
}

export class HasCreatedProfileEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    hasCreatedProfile(): Promise<BootUserDTO> {
        let url_ = this.baseUrl + "/api/user/has-created-profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHasCreatedProfile(_response);
        });
    }

    protected processHasCreatedProfile(response: Response): Promise<BootUserDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BootUserDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BootUserDTO>(null as any);
    }
}

export class LionheartClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    register(body: RegisterRequest): Promise<void> {
        let url_ = this.baseUrl + "/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param useCookies (optional) 
     * @param useSessionCookies (optional) 
     * @return OK
     */
    login(useCookies: boolean | undefined, useSessionCookies: boolean | undefined, body: LoginRequest): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/login?";
        if (useCookies === null)
            throw new Error("The parameter 'useCookies' cannot be null.");
        else if (useCookies !== undefined)
            url_ += "useCookies=" + encodeURIComponent("" + useCookies) + "&";
        if (useSessionCookies === null)
            throw new Error("The parameter 'useSessionCookies' cannot be null.");
        else if (useSessionCookies !== undefined)
            url_ += "useSessionCookies=" + encodeURIComponent("" + useSessionCookies) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<AccessTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    /**
     * @return OK
     */
    refresh(body: RefreshRequest): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: Response): Promise<AccessTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    /**
     * @param changedEmail (optional) 
     * @return OK
     */
    mapIdentityApi_confirmEmail(userId: string, code: string, changedEmail: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/confirmEmail?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined and cannot be null.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (changedEmail === null)
            throw new Error("The parameter 'changedEmail' cannot be null.");
        else if (changedEmail !== undefined)
            url_ += "changedEmail=" + encodeURIComponent("" + changedEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMapIdentityApi_confirmEmail(_response);
        });
    }

    protected processMapIdentityApi_confirmEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    resendConfirmationEmail(body: ResendConfirmationEmailRequest): Promise<void> {
        let url_ = this.baseUrl + "/resendConfirmationEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResendConfirmationEmail(_response);
        });
    }

    protected processResendConfirmationEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    forgotPassword(body: ForgotPasswordRequest): Promise<void> {
        let url_ = this.baseUrl + "/forgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    resetPassword(body: ResetPasswordRequest): Promise<void> {
        let url_ = this.baseUrl + "/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    _2fa(body: TwoFactorRequest): Promise<TwoFactorResponse> {
        let url_ = this.baseUrl + "/manage/2fa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process_2fa(_response);
        });
    }

    protected process_2fa(response: Response): Promise<TwoFactorResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwoFactorResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TwoFactorResponse>(null as any);
    }

    /**
     * @return OK
     */
    infoGET(): Promise<InfoResponse> {
        let url_ = this.baseUrl + "/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInfoGET(_response);
        });
    }

    protected processInfoGET(response: Response): Promise<InfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InfoResponse>(null as any);
    }

    /**
     * @return OK
     */
    infoPOST(body: InfoRequest): Promise<InfoResponse> {
        let url_ = this.baseUrl + "/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInfoPOST(_response);
        });
    }

    protected processInfoPOST(response: Response): Promise<InfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InfoResponse>(null as any);
    }
}

export class LogoutUserEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param request (optional) 
     * @return No Content
     */
    logout(request: any | undefined): Promise<BootUserDTO> {
        let url_ = this.baseUrl + "/api/user/logout?";
        if (request === null)
            throw new Error("The parameter 'request' cannot be null.");
        else if (request !== undefined)
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<BootUserDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = BootUserDTO.fromJS(resultData204);
            return result204;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BootUserDTO>(null as any);
    }
}

export class ParseSessionTextEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    parse(body: ParseSessionTextRequest | undefined): Promise<ParseSessionTextResponse> {
        let url_ = this.baseUrl + "/api/session/parse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParse(_response);
        });
    }

    protected processParse(response: Response): Promise<ParseSessionTextResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParseSessionTextResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParseSessionTextResponse>(null as any);
    }
}

export class SetPersonalApiAccessTokenEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setPersonalApiAccessToken(body: CreatePersonalApiAccessTokenRequest | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/user/set-personal-api-access-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPersonalApiAccessToken(_response);
        });
    }

    protected processSetPersonalApiAccessToken(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return result201;
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class SyncOuraApiEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    sync(body: DateRangeRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/oura/sync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSync(_response);
        });
    }

    protected processSync(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UpdateDTSetEntryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UpdateDTSetEntryRequest | undefined): Promise<DTSetEntryDTO> {
        let url_ = this.baseUrl + "/api/dt-set-entry/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<DTSetEntryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DTSetEntryDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DTSetEntryDTO>(null as any);
    }
}

export class UpdateInjuryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update2(body: UpdateInjuryRequest | undefined): Promise<InjuryDTO> {
        let url_ = this.baseUrl + "/api/injury/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate2(_response);
        });
    }

    protected processUpdate2(response: Response): Promise<InjuryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InjuryDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InjuryDTO>(null as any);
    }
}

export class UpdateInjuryEventEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    eventPUT(body: UpdateInjuryEventRequest | undefined): Promise<InjuryDTO> {
        let url_ = this.baseUrl + "/api/injury/event";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEventPUT(_response);
        });
    }

    protected processEventPUT(response: Response): Promise<InjuryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InjuryDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InjuryDTO>(null as any);
    }
}

export class UpdateLiftSetEntryEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update3(body: UpdateLiftSetEntryRequest | undefined): Promise<LiftSetEntryDTO> {
        let url_ = this.baseUrl + "/api/lift-set-entry/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate3(_response);
        });
    }

    protected processUpdate3(response: Response): Promise<LiftSetEntryDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LiftSetEntryDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LiftSetEntryDTO>(null as any);
    }
}

export class UpdateMovementEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update4(body: UpdateMovementRequest | undefined): Promise<Movement> {
        let url_ = this.baseUrl + "/api/movement/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate4(_response);
        });
    }

    protected processUpdate4(response: Response): Promise<Movement> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Movement.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Movement>(null as any);
    }
}

export class UpdateTrainingProgramEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update5(body: UpdateTrainingProgramRequest | undefined): Promise<TrainingProgramDTO> {
        let url_ = this.baseUrl + "/api/training-program/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate5(_response);
        });
    }

    protected processUpdate5(response: Response): Promise<TrainingProgramDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingProgramDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingProgramDTO>(null as any);
    }
}

export class UpdateTrainingSessionEndpointClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update6(body: UpdateTrainingSessionRequest | undefined): Promise<TrainingSessionDTO> {
        let url_ = this.baseUrl + "/api/training-session/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate6(_response);
        });
    }

    protected processUpdate6(response: Response): Promise<TrainingSessionDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSessionDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrainingSessionDTO>(null as any);
    }
}

export class AccessTokenResponse implements IAccessTokenResponse {
    readonly tokenType?: string | undefined;
    accessToken!: string | undefined;
    expiresIn!: number;
    refreshToken!: string | undefined;

    constructor(data?: IAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).tokenType = _data["tokenType"];
            this.accessToken = _data["accessToken"];
            this.expiresIn = _data["expiresIn"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenType"] = this.tokenType;
        data["accessToken"] = this.accessToken;
        data["expiresIn"] = this.expiresIn;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IAccessTokenResponse {
    tokenType?: string | undefined;
    accessToken: string | undefined;
    expiresIn: number;
    refreshToken: string | undefined;
}

export class ActiveInjuryDetailDTO implements IActiveInjuryDetailDTO {
    injuryName?: string | undefined;
    affectedArea?: string | undefined;
    severity?: string | undefined;
    daysSinceOnset?: number;
    status?: string | undefined;
    affectedMovements?: string[] | undefined;

    constructor(data?: IActiveInjuryDetailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.injuryName = _data["injuryName"];
            this.affectedArea = _data["affectedArea"];
            this.severity = _data["severity"];
            this.daysSinceOnset = _data["daysSinceOnset"];
            this.status = _data["status"];
            if (Array.isArray(_data["affectedMovements"])) {
                this.affectedMovements = [] as any;
                for (let item of _data["affectedMovements"])
                    this.affectedMovements!.push(item);
            }
        }
    }

    static fromJS(data: any): ActiveInjuryDetailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveInjuryDetailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["injuryName"] = this.injuryName;
        data["affectedArea"] = this.affectedArea;
        data["severity"] = this.severity;
        data["daysSinceOnset"] = this.daysSinceOnset;
        data["status"] = this.status;
        if (Array.isArray(this.affectedMovements)) {
            data["affectedMovements"] = [];
            for (let item of this.affectedMovements)
                data["affectedMovements"].push(item);
        }
        return data;
    }
}

export interface IActiveInjuryDetailDTO {
    injuryName?: string | undefined;
    affectedArea?: string | undefined;
    severity?: string | undefined;
    daysSinceOnset?: number;
    status?: string | undefined;
    affectedMovements?: string[] | undefined;
}

export class Activity implements IActivity {
    activityID?: string;
    userID?: string;
    dateTime?: Date;
    timeInMinutes?: number;
    caloriesBurned?: number;
    name?: string | undefined;
    userSummary?: string | undefined;
    accumulatedFatigue?: number;
    difficultyRating?: number;
    engagementRating?: number;
    externalVariablesRating?: number;
    runWalkDetails?: RunWalkDetails;
    liftDetails?: LiftDetails;
    rideDetails?: RideDetails;

    constructor(data?: IActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityID = _data["activityID"];
            this.userID = _data["userID"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.timeInMinutes = _data["timeInMinutes"];
            this.caloriesBurned = _data["caloriesBurned"];
            this.name = _data["name"];
            this.userSummary = _data["userSummary"];
            this.accumulatedFatigue = _data["accumulatedFatigue"];
            this.difficultyRating = _data["difficultyRating"];
            this.engagementRating = _data["engagementRating"];
            this.externalVariablesRating = _data["externalVariablesRating"];
            this.runWalkDetails = _data["runWalkDetails"] ? RunWalkDetails.fromJS(_data["runWalkDetails"]) : <any>undefined;
            this.liftDetails = _data["liftDetails"] ? LiftDetails.fromJS(_data["liftDetails"]) : <any>undefined;
            this.rideDetails = _data["rideDetails"] ? RideDetails.fromJS(_data["rideDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Activity {
        data = typeof data === 'object' ? data : {};
        let result = new Activity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityID"] = this.activityID;
        data["userID"] = this.userID;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["timeInMinutes"] = this.timeInMinutes;
        data["caloriesBurned"] = this.caloriesBurned;
        data["name"] = this.name;
        data["userSummary"] = this.userSummary;
        data["accumulatedFatigue"] = this.accumulatedFatigue;
        data["difficultyRating"] = this.difficultyRating;
        data["engagementRating"] = this.engagementRating;
        data["externalVariablesRating"] = this.externalVariablesRating;
        data["runWalkDetails"] = this.runWalkDetails ? this.runWalkDetails.toJSON() : <any>undefined;
        data["liftDetails"] = this.liftDetails ? this.liftDetails.toJSON() : <any>undefined;
        data["rideDetails"] = this.rideDetails ? this.rideDetails.toJSON() : <any>undefined;
        return data;
    }
}

export interface IActivity {
    activityID?: string;
    userID?: string;
    dateTime?: Date;
    timeInMinutes?: number;
    caloriesBurned?: number;
    name?: string | undefined;
    userSummary?: string | undefined;
    accumulatedFatigue?: number;
    difficultyRating?: number;
    engagementRating?: number;
    externalVariablesRating?: number;
    runWalkDetails?: RunWalkDetails;
    liftDetails?: LiftDetails;
    rideDetails?: RideDetails;
}

export class ActivityData implements IActivityData {
    activityScore?: number;
    steps?: number;
    activeCalories?: number;
    totalCalories?: number;
    targetCalories?: number;
    meetDailyTargets?: number;
    moveEveryHour?: number;
    recoveryTime?: number;
    stayActive?: number;
    trainingFrequency?: number;
    trainingVolume?: number;

    constructor(data?: IActivityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityScore = _data["activityScore"];
            this.steps = _data["steps"];
            this.activeCalories = _data["activeCalories"];
            this.totalCalories = _data["totalCalories"];
            this.targetCalories = _data["targetCalories"];
            this.meetDailyTargets = _data["meetDailyTargets"];
            this.moveEveryHour = _data["moveEveryHour"];
            this.recoveryTime = _data["recoveryTime"];
            this.stayActive = _data["stayActive"];
            this.trainingFrequency = _data["trainingFrequency"];
            this.trainingVolume = _data["trainingVolume"];
        }
    }

    static fromJS(data: any): ActivityData {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityScore"] = this.activityScore;
        data["steps"] = this.steps;
        data["activeCalories"] = this.activeCalories;
        data["totalCalories"] = this.totalCalories;
        data["targetCalories"] = this.targetCalories;
        data["meetDailyTargets"] = this.meetDailyTargets;
        data["moveEveryHour"] = this.moveEveryHour;
        data["recoveryTime"] = this.recoveryTime;
        data["stayActive"] = this.stayActive;
        data["trainingFrequency"] = this.trainingFrequency;
        data["trainingVolume"] = this.trainingVolume;
        return data;
    }
}

export interface IActivityData {
    activityScore?: number;
    steps?: number;
    activeCalories?: number;
    totalCalories?: number;
    targetCalories?: number;
    meetDailyTargets?: number;
    moveEveryHour?: number;
    recoveryTime?: number;
    stayActive?: number;
    trainingFrequency?: number;
    trainingVolume?: number;
}

export class ActivityDaySummaryDTO implements IActivityDaySummaryDTO {
    totalActivities?: number;
    runWalkCount?: number;
    rideCount?: number;
    liftActivityCount?: number;
    totalDistance?: number;
    totalDurationMinutes?: number;
    totalCalories?: number;
    activitySummary?: string | undefined;

    constructor(data?: IActivityDaySummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalActivities = _data["totalActivities"];
            this.runWalkCount = _data["runWalkCount"];
            this.rideCount = _data["rideCount"];
            this.liftActivityCount = _data["liftActivityCount"];
            this.totalDistance = _data["totalDistance"];
            this.totalDurationMinutes = _data["totalDurationMinutes"];
            this.totalCalories = _data["totalCalories"];
            this.activitySummary = _data["activitySummary"];
        }
    }

    static fromJS(data: any): ActivityDaySummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDaySummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalActivities"] = this.totalActivities;
        data["runWalkCount"] = this.runWalkCount;
        data["rideCount"] = this.rideCount;
        data["liftActivityCount"] = this.liftActivityCount;
        data["totalDistance"] = this.totalDistance;
        data["totalDurationMinutes"] = this.totalDurationMinutes;
        data["totalCalories"] = this.totalCalories;
        data["activitySummary"] = this.activitySummary;
        return data;
    }
}

export interface IActivityDaySummaryDTO {
    totalActivities?: number;
    runWalkCount?: number;
    rideCount?: number;
    liftActivityCount?: number;
    totalDistance?: number;
    totalDurationMinutes?: number;
    totalCalories?: number;
    activitySummary?: string | undefined;
}

export class ActivityTypeRatioDto implements IActivityTypeRatioDto {
    numberLifts?: number;
    numberRunWalks?: number;
    numberRides?: number;

    constructor(data?: IActivityTypeRatioDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numberLifts = _data["numberLifts"];
            this.numberRunWalks = _data["numberRunWalks"];
            this.numberRides = _data["numberRides"];
        }
    }

    static fromJS(data: any): ActivityTypeRatioDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityTypeRatioDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberLifts"] = this.numberLifts;
        data["numberRunWalks"] = this.numberRunWalks;
        data["numberRides"] = this.numberRides;
        return data;
    }
}

export interface IActivityTypeRatioDto {
    numberLifts?: number;
    numberRunWalks?: number;
    numberRides?: number;
}

export class AddAIReviewRequest implements IAddAIReviewRequest {
    sessionReportID!: string;
    aiReview!: string;

    constructor(data?: IAddAIReviewRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionReportID = _data["sessionReportID"];
            this.aiReview = _data["aiReview"];
        }
    }

    static fromJS(data: any): AddAIReviewRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddAIReviewRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionReportID"] = this.sessionReportID;
        data["aiReview"] = this.aiReview;
        return data;
    }
}

export interface IAddAIReviewRequest {
    sessionReportID: string;
    aiReview: string;
}

export class AddDailyRundownAIInsightsRequest implements IAddDailyRundownAIInsightsRequest {
    dailyRundownID!: string;
    aiInsights!: string;

    constructor(data?: IAddDailyRundownAIInsightsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dailyRundownID = _data["dailyRundownID"];
            this.aiInsights = _data["aiInsights"];
        }
    }

    static fromJS(data: any): AddDailyRundownAIInsightsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddDailyRundownAIInsightsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dailyRundownID"] = this.dailyRundownID;
        data["aiInsights"] = this.aiInsights;
        return data;
    }
}

export interface IAddDailyRundownAIInsightsRequest {
    dailyRundownID: string;
    aiInsights: string;
}

export class AddNightlyBreakdownAIReviewRequest implements IAddNightlyBreakdownAIReviewRequest {
    nightlyBreakdownID!: string;
    aiReview!: string;

    constructor(data?: IAddNightlyBreakdownAIReviewRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nightlyBreakdownID = _data["nightlyBreakdownID"];
            this.aiReview = _data["aiReview"];
        }
    }

    static fromJS(data: any): AddNightlyBreakdownAIReviewRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddNightlyBreakdownAIReviewRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nightlyBreakdownID"] = this.nightlyBreakdownID;
        data["aiReview"] = this.aiReview;
        return data;
    }
}

export interface IAddNightlyBreakdownAIReviewRequest {
    nightlyBreakdownID: string;
    aiReview: string;
}

export class ApiAccessToken implements IApiAccessToken {
    objectID?: string;
    userID?: string;
    applicationName?: string | undefined;
    personalAccessToken?: string | undefined;

    constructor(data?: IApiAccessToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectID = _data["objectID"];
            this.userID = _data["userID"];
            this.applicationName = _data["applicationName"];
            this.personalAccessToken = _data["personalAccessToken"];
        }
    }

    static fromJS(data: any): ApiAccessToken {
        data = typeof data === 'object' ? data : {};
        let result = new ApiAccessToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectID"] = this.objectID;
        data["userID"] = this.userID;
        data["applicationName"] = this.applicationName;
        data["personalAccessToken"] = this.personalAccessToken;
        return data;
    }
}

export interface IApiAccessToken {
    objectID?: string;
    userID?: string;
    applicationName?: string | undefined;
    personalAccessToken?: string | undefined;
}

export class BinaryData implements IBinaryData {
    readonly length?: number;
    readonly isEmpty?: boolean;
    readonly mediaType?: string | undefined;

    constructor(data?: IBinaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).length = _data["length"];
            (<any>this).isEmpty = _data["isEmpty"];
            (<any>this).mediaType = _data["mediaType"];
        }
    }

    static fromJS(data: any): BinaryData {
        data = typeof data === 'object' ? data : {};
        let result = new BinaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["length"] = this.length;
        data["isEmpty"] = this.isEmpty;
        data["mediaType"] = this.mediaType;
        return data;
    }
}

export interface IBinaryData {
    length?: number;
    isEmpty?: boolean;
    mediaType?: string | undefined;
}

export class BootUserDTO implements IBootUserDTO {
    name?: string | undefined;
    hasCreatedProfile?: boolean;

    constructor(data?: IBootUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.hasCreatedProfile = _data["hasCreatedProfile"];
        }
    }

    static fromJS(data: any): BootUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BootUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["hasCreatedProfile"] = this.hasCreatedProfile;
        return data;
    }
}

export interface IBootUserDTO {
    name?: string | undefined;
    hasCreatedProfile?: boolean;
}

export class ChatConversation implements IChatConversation {
    chatConversationId?: string;
    userID?: string;
    createdAt?: Date;
    name?: string | undefined;
    messages?: ChatMessageItem[] | undefined;

    constructor(data?: IChatConversation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatConversationId = _data["chatConversationId"];
            this.userID = _data["userID"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ChatMessageItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChatConversation {
        data = typeof data === 'object' ? data : {};
        let result = new ChatConversation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatConversationId"] = this.chatConversationId;
        data["userID"] = this.userID;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IChatConversation {
    chatConversationId?: string;
    userID?: string;
    createdAt?: Date;
    name?: string | undefined;
    messages?: ChatMessageItem[] | undefined;
}

export class ChatImageDetailLevel implements IChatImageDetailLevel {

    constructor(data?: IChatImageDetailLevel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ChatImageDetailLevel {
        data = typeof data === 'object' ? data : {};
        let result = new ChatImageDetailLevel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IChatImageDetailLevel {
}

export class ChatInputAudioFormat implements IChatInputAudioFormat {

    constructor(data?: IChatInputAudioFormat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ChatInputAudioFormat {
        data = typeof data === 'object' ? data : {};
        let result = new ChatInputAudioFormat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IChatInputAudioFormat {
}

export class ChatMessage implements IChatMessage {
    readonly content?: ChatMessageContentPart[] | undefined;

    constructor(data?: IChatMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(ChatMessageContentPart.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChatMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IChatMessage {
    content?: ChatMessageContentPart[] | undefined;
}

export class ChatMessageContentPart implements IChatMessageContentPart {
    kind?: ChatMessageContentPartKind;
    readonly text?: string | undefined;
    readonly imageUri?: string | undefined;
    imageBytes?: BinaryData;
    readonly imageBytesMediaType?: string | undefined;
    inputAudioBytes?: BinaryData;
    inputAudioFormat?: ChatInputAudioFormat;
    readonly fileId?: string | undefined;
    fileBytes?: BinaryData;
    readonly fileBytesMediaType?: string | undefined;
    readonly filename?: string | undefined;
    imageDetailLevel?: ChatImageDetailLevel;
    readonly refusal?: string | undefined;

    constructor(data?: IChatMessageContentPart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kind = _data["kind"];
            (<any>this).text = _data["text"];
            (<any>this).imageUri = _data["imageUri"];
            this.imageBytes = _data["imageBytes"] ? BinaryData.fromJS(_data["imageBytes"]) : <any>undefined;
            (<any>this).imageBytesMediaType = _data["imageBytesMediaType"];
            this.inputAudioBytes = _data["inputAudioBytes"] ? BinaryData.fromJS(_data["inputAudioBytes"]) : <any>undefined;
            this.inputAudioFormat = _data["inputAudioFormat"] ? ChatInputAudioFormat.fromJS(_data["inputAudioFormat"]) : <any>undefined;
            (<any>this).fileId = _data["fileId"];
            this.fileBytes = _data["fileBytes"] ? BinaryData.fromJS(_data["fileBytes"]) : <any>undefined;
            (<any>this).fileBytesMediaType = _data["fileBytesMediaType"];
            (<any>this).filename = _data["filename"];
            this.imageDetailLevel = _data["imageDetailLevel"] ? ChatImageDetailLevel.fromJS(_data["imageDetailLevel"]) : <any>undefined;
            (<any>this).refusal = _data["refusal"];
        }
    }

    static fromJS(data: any): ChatMessageContentPart {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageContentPart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind;
        data["text"] = this.text;
        data["imageUri"] = this.imageUri;
        data["imageBytes"] = this.imageBytes ? this.imageBytes.toJSON() : <any>undefined;
        data["imageBytesMediaType"] = this.imageBytesMediaType;
        data["inputAudioBytes"] = this.inputAudioBytes ? this.inputAudioBytes.toJSON() : <any>undefined;
        data["inputAudioFormat"] = this.inputAudioFormat ? this.inputAudioFormat.toJSON() : <any>undefined;
        data["fileId"] = this.fileId;
        data["fileBytes"] = this.fileBytes ? this.fileBytes.toJSON() : <any>undefined;
        data["fileBytesMediaType"] = this.fileBytesMediaType;
        data["filename"] = this.filename;
        data["imageDetailLevel"] = this.imageDetailLevel ? this.imageDetailLevel.toJSON() : <any>undefined;
        data["refusal"] = this.refusal;
        return data;
    }
}

export interface IChatMessageContentPart {
    kind?: ChatMessageContentPartKind;
    text?: string | undefined;
    imageUri?: string | undefined;
    imageBytes?: BinaryData;
    imageBytesMediaType?: string | undefined;
    inputAudioBytes?: BinaryData;
    inputAudioFormat?: ChatInputAudioFormat;
    fileId?: string | undefined;
    fileBytes?: BinaryData;
    fileBytesMediaType?: string | undefined;
    filename?: string | undefined;
    imageDetailLevel?: ChatImageDetailLevel;
    refusal?: string | undefined;
}

export enum ChatMessageContentPartKind {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class ChatMessageItem implements IChatMessageItem {
    chatMessageItemID?: string;
    chatConversationID?: string;
    chatConversation?: ChatConversation;
    chatMessageJson!: string | undefined;
    chatMessageRole!: ChatMessageRole;
    chatMessage?: ChatMessage;
    creationTime?: Date;

    constructor(data?: IChatMessageItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatMessageItemID = _data["chatMessageItemID"];
            this.chatConversationID = _data["chatConversationID"];
            this.chatConversation = _data["chatConversation"] ? ChatConversation.fromJS(_data["chatConversation"]) : <any>undefined;
            this.chatMessageJson = _data["chatMessageJson"];
            this.chatMessageRole = _data["chatMessageRole"];
            this.chatMessage = _data["chatMessage"] ? ChatMessage.fromJS(_data["chatMessage"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ChatMessageItem {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatMessageItemID"] = this.chatMessageItemID;
        data["chatConversationID"] = this.chatConversationID;
        data["chatConversation"] = this.chatConversation ? this.chatConversation.toJSON() : <any>undefined;
        data["chatMessageJson"] = this.chatMessageJson;
        data["chatMessageRole"] = this.chatMessageRole;
        data["chatMessage"] = this.chatMessage ? this.chatMessage.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IChatMessageItem {
    chatMessageItemID?: string;
    chatConversationID?: string;
    chatConversation?: ChatConversation;
    chatMessageJson: string | undefined;
    chatMessageRole: ChatMessageRole;
    chatMessage?: ChatMessage;
    creationTime?: Date;
}

export enum ChatMessageRole {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class CreateActivityRequest implements ICreateActivityRequest {
    dateTime!: Date;
    timeInMinutes!: number;
    caloriesBurned!: number;
    name!: string;
    userSummary?: string | undefined;
    accumulatedFatigue!: number;
    difficultyRating!: number;
    engagementRating!: number;
    externalVariablesRating!: number;

    constructor(data?: ICreateActivityRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.timeInMinutes = _data["timeInMinutes"];
            this.caloriesBurned = _data["caloriesBurned"];
            this.name = _data["name"];
            this.userSummary = _data["userSummary"];
            this.accumulatedFatigue = _data["accumulatedFatigue"];
            this.difficultyRating = _data["difficultyRating"];
            this.engagementRating = _data["engagementRating"];
            this.externalVariablesRating = _data["externalVariablesRating"];
        }
    }

    static fromJS(data: any): CreateActivityRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["timeInMinutes"] = this.timeInMinutes;
        data["caloriesBurned"] = this.caloriesBurned;
        data["name"] = this.name;
        data["userSummary"] = this.userSummary;
        data["accumulatedFatigue"] = this.accumulatedFatigue;
        data["difficultyRating"] = this.difficultyRating;
        data["engagementRating"] = this.engagementRating;
        data["externalVariablesRating"] = this.externalVariablesRating;
        return data;
    }
}

export interface ICreateActivityRequest {
    dateTime: Date;
    timeInMinutes: number;
    caloriesBurned: number;
    name: string;
    userSummary?: string | undefined;
    accumulatedFatigue: number;
    difficultyRating: number;
    engagementRating: number;
    externalVariablesRating: number;
}

export class CreateDTSetEntryRequest implements ICreateDTSetEntryRequest {
    movementID?: string;
    recommendedDistance?: number;
    actualDistance?: number;
    intervalDuration?: string;
    targetPace?: string;
    actualPace?: string;
    recommendedDuration?: string;
    actualDuration?: string;
    recommendedRest?: string;
    actualRest?: string;
    intervalType?: IntervalType;
    distanceUnit?: DistanceUnit;
    actualRPE?: number;

    constructor(data?: ICreateDTSetEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementID = _data["movementID"];
            this.recommendedDistance = _data["recommendedDistance"];
            this.actualDistance = _data["actualDistance"];
            this.intervalDuration = _data["intervalDuration"];
            this.targetPace = _data["targetPace"];
            this.actualPace = _data["actualPace"];
            this.recommendedDuration = _data["recommendedDuration"];
            this.actualDuration = _data["actualDuration"];
            this.recommendedRest = _data["recommendedRest"];
            this.actualRest = _data["actualRest"];
            this.intervalType = _data["intervalType"];
            this.distanceUnit = _data["distanceUnit"];
            this.actualRPE = _data["actualRPE"];
        }
    }

    static fromJS(data: any): CreateDTSetEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDTSetEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementID"] = this.movementID;
        data["recommendedDistance"] = this.recommendedDistance;
        data["actualDistance"] = this.actualDistance;
        data["intervalDuration"] = this.intervalDuration;
        data["targetPace"] = this.targetPace;
        data["actualPace"] = this.actualPace;
        data["recommendedDuration"] = this.recommendedDuration;
        data["actualDuration"] = this.actualDuration;
        data["recommendedRest"] = this.recommendedRest;
        data["actualRest"] = this.actualRest;
        data["intervalType"] = this.intervalType;
        data["distanceUnit"] = this.distanceUnit;
        data["actualRPE"] = this.actualRPE;
        return data;
    }
}

export interface ICreateDTSetEntryRequest {
    movementID?: string;
    recommendedDistance?: number;
    actualDistance?: number;
    intervalDuration?: string;
    targetPace?: string;
    actualPace?: string;
    recommendedDuration?: string;
    actualDuration?: string;
    recommendedRest?: string;
    actualRest?: string;
    intervalType?: IntervalType;
    distanceUnit?: DistanceUnit;
    actualRPE?: number;
}

export class CreateEquipmentRequest implements ICreateEquipmentRequest {
    name?: string | undefined;

    constructor(data?: ICreateEquipmentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateEquipmentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEquipmentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateEquipmentRequest {
    name?: string | undefined;
}

export class CreateInjuryEventRequest implements ICreateInjuryEventRequest {
    trainingSessionID?: string | undefined;
    injuryID!: string;
    notes!: string;
    painLevel!: number;
    injuryType!: InjuryEventType;

    constructor(data?: ICreateInjuryEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            this.injuryID = _data["injuryID"];
            this.notes = _data["notes"];
            this.painLevel = _data["painLevel"];
            this.injuryType = _data["injuryType"];
        }
    }

    static fromJS(data: any): CreateInjuryEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInjuryEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        data["injuryID"] = this.injuryID;
        data["notes"] = this.notes;
        data["painLevel"] = this.painLevel;
        data["injuryType"] = this.injuryType;
        return data;
    }
}

export interface ICreateInjuryEventRequest {
    trainingSessionID?: string | undefined;
    injuryID: string;
    notes: string;
    painLevel: number;
    injuryType: InjuryEventType;
}

export class CreateInjuryRequest implements ICreateInjuryRequest {
    name!: string;
    injuryDate!: Date;
    notes!: string;

    constructor(data?: ICreateInjuryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.injuryDate = _data["injuryDate"] ? new Date(_data["injuryDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): CreateInjuryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInjuryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["injuryDate"] = this.injuryDate ? formatDate(this.injuryDate) : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICreateInjuryRequest {
    name: string;
    injuryDate: Date;
    notes: string;
}

export class CreateLiftRequest implements ICreateLiftRequest {
    dateTime!: Date;
    timeInMinutes!: number;
    caloriesBurned!: number;
    name!: string;
    userSummary?: string | undefined;
    accumulatedFatigue!: number;
    difficultyRating!: number;
    engagementRating!: number;
    externalVariablesRating!: number;
    tonnage!: number;
    liftType?: string | undefined;
    liftFocus?: string | undefined;
    quadSets!: number;
    hamstringSets!: number;
    bicepSets!: number;
    tricepSets!: number;
    shoulderSets!: number;
    backSets!: number;
    chestSets!: number;

    constructor(data?: ICreateLiftRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.timeInMinutes = _data["timeInMinutes"];
            this.caloriesBurned = _data["caloriesBurned"];
            this.name = _data["name"];
            this.userSummary = _data["userSummary"];
            this.accumulatedFatigue = _data["accumulatedFatigue"];
            this.difficultyRating = _data["difficultyRating"];
            this.engagementRating = _data["engagementRating"];
            this.externalVariablesRating = _data["externalVariablesRating"];
            this.tonnage = _data["tonnage"];
            this.liftType = _data["liftType"];
            this.liftFocus = _data["liftFocus"];
            this.quadSets = _data["quadSets"];
            this.hamstringSets = _data["hamstringSets"];
            this.bicepSets = _data["bicepSets"];
            this.tricepSets = _data["tricepSets"];
            this.shoulderSets = _data["shoulderSets"];
            this.backSets = _data["backSets"];
            this.chestSets = _data["chestSets"];
        }
    }

    static fromJS(data: any): CreateLiftRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLiftRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["timeInMinutes"] = this.timeInMinutes;
        data["caloriesBurned"] = this.caloriesBurned;
        data["name"] = this.name;
        data["userSummary"] = this.userSummary;
        data["accumulatedFatigue"] = this.accumulatedFatigue;
        data["difficultyRating"] = this.difficultyRating;
        data["engagementRating"] = this.engagementRating;
        data["externalVariablesRating"] = this.externalVariablesRating;
        data["tonnage"] = this.tonnage;
        data["liftType"] = this.liftType;
        data["liftFocus"] = this.liftFocus;
        data["quadSets"] = this.quadSets;
        data["hamstringSets"] = this.hamstringSets;
        data["bicepSets"] = this.bicepSets;
        data["tricepSets"] = this.tricepSets;
        data["shoulderSets"] = this.shoulderSets;
        data["backSets"] = this.backSets;
        data["chestSets"] = this.chestSets;
        return data;
    }
}

export interface ICreateLiftRequest {
    dateTime: Date;
    timeInMinutes: number;
    caloriesBurned: number;
    name: string;
    userSummary?: string | undefined;
    accumulatedFatigue: number;
    difficultyRating: number;
    engagementRating: number;
    externalVariablesRating: number;
    tonnage: number;
    liftType?: string | undefined;
    liftFocus?: string | undefined;
    quadSets: number;
    hamstringSets: number;
    bicepSets: number;
    tricepSets: number;
    shoulderSets: number;
    backSets: number;
    chestSets: number;
}

export class CreateLiftSetEntryRequest implements ICreateLiftSetEntryRequest {
    movementID?: string;
    recommendedReps?: number;
    recommendedWeight?: number;
    recommendedRPE?: number;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit?: WeightUnit;

    constructor(data?: ICreateLiftSetEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementID = _data["movementID"];
            this.recommendedReps = _data["recommendedReps"];
            this.recommendedWeight = _data["recommendedWeight"];
            this.recommendedRPE = _data["recommendedRPE"];
            this.actualReps = _data["actualReps"];
            this.actualWeight = _data["actualWeight"];
            this.actualRPE = _data["actualRPE"];
            this.weightUnit = _data["weightUnit"];
        }
    }

    static fromJS(data: any): CreateLiftSetEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLiftSetEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementID"] = this.movementID;
        data["recommendedReps"] = this.recommendedReps;
        data["recommendedWeight"] = this.recommendedWeight;
        data["recommendedRPE"] = this.recommendedRPE;
        data["actualReps"] = this.actualReps;
        data["actualWeight"] = this.actualWeight;
        data["actualRPE"] = this.actualRPE;
        data["weightUnit"] = this.weightUnit;
        return data;
    }
}

export interface ICreateLiftSetEntryRequest {
    movementID?: string;
    recommendedReps?: number;
    recommendedWeight?: number;
    recommendedRPE?: number;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit?: WeightUnit;
}

export class CreateMovementBaseRequest implements ICreateMovementBaseRequest {
    name?: string | undefined;
    description?: string | undefined;
    muscleGroups?: MuscleGroup[] | undefined;

    constructor(data?: ICreateMovementBaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["muscleGroups"])) {
                this.muscleGroups = [] as any;
                for (let item of _data["muscleGroups"])
                    this.muscleGroups!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateMovementBaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMovementBaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.muscleGroups)) {
            data["muscleGroups"] = [];
            for (let item of this.muscleGroups)
                data["muscleGroups"].push(item);
        }
        return data;
    }
}

export interface ICreateMovementBaseRequest {
    name?: string | undefined;
    description?: string | undefined;
    muscleGroups?: MuscleGroup[] | undefined;
}

export class CreateMovementRequest implements ICreateMovementRequest {
    trainingSessionID?: string;
    movementBaseID?: string;
    movementModifier?: MovementModifier;
    notes?: string | undefined;

    constructor(data?: ICreateMovementRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            this.movementBaseID = _data["movementBaseID"];
            this.movementModifier = _data["movementModifier"] ? MovementModifier.fromJS(_data["movementModifier"]) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): CreateMovementRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMovementRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        data["movementBaseID"] = this.movementBaseID;
        data["movementModifier"] = this.movementModifier ? this.movementModifier.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICreateMovementRequest {
    trainingSessionID?: string;
    movementBaseID?: string;
    movementModifier?: MovementModifier;
    notes?: string | undefined;
}

export class CreatePersonalApiAccessTokenRequest implements ICreatePersonalApiAccessTokenRequest {
    applicationName!: string;
    accessToken!: string;

    constructor(data?: ICreatePersonalApiAccessTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationName = _data["applicationName"];
            this.accessToken = _data["accessToken"];
        }
    }

    static fromJS(data: any): CreatePersonalApiAccessTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePersonalApiAccessTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationName"] = this.applicationName;
        data["accessToken"] = this.accessToken;
        return data;
    }
}

export interface ICreatePersonalApiAccessTokenRequest {
    applicationName: string;
    accessToken: string;
}

export class CreateProfileRequest implements ICreateProfileRequest {
    displayName!: string;
    age!: number;
    weight!: number;

    constructor(data?: ICreateProfileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.age = _data["age"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): CreateProfileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProfileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["age"] = this.age;
        data["weight"] = this.weight;
        return data;
    }
}

export interface ICreateProfileRequest {
    displayName: string;
    age: number;
    weight: number;
}

export class CreateRideRequest implements ICreateRideRequest {
    dateTime!: Date;
    timeInMinutes!: number;
    caloriesBurned!: number;
    name!: string;
    userSummary?: string | undefined;
    accumulatedFatigue!: number;
    difficultyRating!: number;
    engagementRating!: number;
    externalVariablesRating!: number;
    distance!: number;
    elevationGain!: number;
    averagePower!: number;
    averageSpeed!: number;
    rideType?: string | undefined;

    constructor(data?: ICreateRideRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.timeInMinutes = _data["timeInMinutes"];
            this.caloriesBurned = _data["caloriesBurned"];
            this.name = _data["name"];
            this.userSummary = _data["userSummary"];
            this.accumulatedFatigue = _data["accumulatedFatigue"];
            this.difficultyRating = _data["difficultyRating"];
            this.engagementRating = _data["engagementRating"];
            this.externalVariablesRating = _data["externalVariablesRating"];
            this.distance = _data["distance"];
            this.elevationGain = _data["elevationGain"];
            this.averagePower = _data["averagePower"];
            this.averageSpeed = _data["averageSpeed"];
            this.rideType = _data["rideType"];
        }
    }

    static fromJS(data: any): CreateRideRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRideRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["timeInMinutes"] = this.timeInMinutes;
        data["caloriesBurned"] = this.caloriesBurned;
        data["name"] = this.name;
        data["userSummary"] = this.userSummary;
        data["accumulatedFatigue"] = this.accumulatedFatigue;
        data["difficultyRating"] = this.difficultyRating;
        data["engagementRating"] = this.engagementRating;
        data["externalVariablesRating"] = this.externalVariablesRating;
        data["distance"] = this.distance;
        data["elevationGain"] = this.elevationGain;
        data["averagePower"] = this.averagePower;
        data["averageSpeed"] = this.averageSpeed;
        data["rideType"] = this.rideType;
        return data;
    }
}

export interface ICreateRideRequest {
    dateTime: Date;
    timeInMinutes: number;
    caloriesBurned: number;
    name: string;
    userSummary?: string | undefined;
    accumulatedFatigue: number;
    difficultyRating: number;
    engagementRating: number;
    externalVariablesRating: number;
    distance: number;
    elevationGain: number;
    averagePower: number;
    averageSpeed: number;
    rideType?: string | undefined;
}

export class CreateRunWalkRequest implements ICreateRunWalkRequest {
    dateTime!: Date;
    timeInMinutes!: number;
    caloriesBurned!: number;
    name!: string;
    userSummary?: string | undefined;
    accumulatedFatigue!: number;
    difficultyRating!: number;
    engagementRating!: number;
    externalVariablesRating!: number;
    distance!: number;
    elevationGain!: number;
    averagePaceInSeconds!: number;
    mileSplitsInSeconds!: number[];
    runType?: string | undefined;

    constructor(data?: ICreateRunWalkRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.mileSplitsInSeconds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.timeInMinutes = _data["timeInMinutes"];
            this.caloriesBurned = _data["caloriesBurned"];
            this.name = _data["name"];
            this.userSummary = _data["userSummary"];
            this.accumulatedFatigue = _data["accumulatedFatigue"];
            this.difficultyRating = _data["difficultyRating"];
            this.engagementRating = _data["engagementRating"];
            this.externalVariablesRating = _data["externalVariablesRating"];
            this.distance = _data["distance"];
            this.elevationGain = _data["elevationGain"];
            this.averagePaceInSeconds = _data["averagePaceInSeconds"];
            if (Array.isArray(_data["mileSplitsInSeconds"])) {
                this.mileSplitsInSeconds = [] as any;
                for (let item of _data["mileSplitsInSeconds"])
                    this.mileSplitsInSeconds!.push(item);
            }
            this.runType = _data["runType"];
        }
    }

    static fromJS(data: any): CreateRunWalkRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRunWalkRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["timeInMinutes"] = this.timeInMinutes;
        data["caloriesBurned"] = this.caloriesBurned;
        data["name"] = this.name;
        data["userSummary"] = this.userSummary;
        data["accumulatedFatigue"] = this.accumulatedFatigue;
        data["difficultyRating"] = this.difficultyRating;
        data["engagementRating"] = this.engagementRating;
        data["externalVariablesRating"] = this.externalVariablesRating;
        data["distance"] = this.distance;
        data["elevationGain"] = this.elevationGain;
        data["averagePaceInSeconds"] = this.averagePaceInSeconds;
        if (Array.isArray(this.mileSplitsInSeconds)) {
            data["mileSplitsInSeconds"] = [];
            for (let item of this.mileSplitsInSeconds)
                data["mileSplitsInSeconds"].push(item);
        }
        data["runType"] = this.runType;
        return data;
    }
}

export interface ICreateRunWalkRequest {
    dateTime: Date;
    timeInMinutes: number;
    caloriesBurned: number;
    name: string;
    userSummary?: string | undefined;
    accumulatedFatigue: number;
    difficultyRating: number;
    engagementRating: number;
    externalVariablesRating: number;
    distance: number;
    elevationGain: number;
    averagePaceInSeconds: number;
    mileSplitsInSeconds: number[];
    runType?: string | undefined;
}

export class CreateSessionFromParsedDataRequest implements ICreateSessionFromParsedDataRequest {
    trainingProgramID?: string;
    parsedSession?: ParsedSessionData;
    sessionDate?: Date;

    constructor(data?: ICreateSessionFromParsedDataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingProgramID = _data["trainingProgramID"];
            this.parsedSession = _data["parsedSession"] ? ParsedSessionData.fromJS(_data["parsedSession"]) : <any>undefined;
            this.sessionDate = _data["sessionDate"] ? new Date(_data["sessionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateSessionFromParsedDataRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSessionFromParsedDataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramID"] = this.trainingProgramID;
        data["parsedSession"] = this.parsedSession ? this.parsedSession.toJSON() : <any>undefined;
        data["sessionDate"] = this.sessionDate ? formatDate(this.sessionDate) : <any>undefined;
        return data;
    }
}

export interface ICreateSessionFromParsedDataRequest {
    trainingProgramID?: string;
    parsedSession?: ParsedSessionData;
    sessionDate?: Date;
}

export class CreateTrainingProgramRequest implements ICreateTrainingProgramRequest {
    trainingProgramID?: string;
    title?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    tags?: string[] | undefined;

    constructor(data?: ICreateTrainingProgramRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingProgramID = _data["trainingProgramID"];
            this.title = _data["title"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateTrainingProgramRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTrainingProgramRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramID"] = this.trainingProgramID;
        data["title"] = this.title;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface ICreateTrainingProgramRequest {
    trainingProgramID?: string;
    title?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    tags?: string[] | undefined;
}

export class CreateTrainingSessionRequest implements ICreateTrainingSessionRequest {
    date?: Date;
    trainingProgramID?: string;
    notes?: string | undefined;

    constructor(data?: ICreateTrainingSessionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.trainingProgramID = _data["trainingProgramID"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): CreateTrainingSessionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTrainingSessionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["trainingProgramID"] = this.trainingProgramID;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICreateTrainingSessionRequest {
    date?: Date;
    trainingProgramID?: string;
    notes?: string | undefined;
}

export class CreateWellnessStateRequest implements ICreateWellnessStateRequest {
    date!: string;
    energy!: number;
    motivation!: number;
    mood!: number;
    stress!: number;

    constructor(data?: ICreateWellnessStateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.energy = _data["energy"];
            this.motivation = _data["motivation"];
            this.mood = _data["mood"];
            this.stress = _data["stress"];
        }
    }

    static fromJS(data: any): CreateWellnessStateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWellnessStateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["energy"] = this.energy;
        data["motivation"] = this.motivation;
        data["mood"] = this.mood;
        data["stress"] = this.stress;
        return data;
    }
}

export interface ICreateWellnessStateRequest {
    date: string;
    energy: number;
    motivation: number;
    mood: number;
    stress: number;
}

export class DTSetEntry implements IDTSetEntry {
    setEntryID!: string;
    movementID!: string;
    movement?: Movement;
    recommendedDistance!: number;
    actualDistance!: number;
    intervalDuration!: string;
    targetPace!: string;
    actualPace!: string;
    recommendedDuration!: string;
    actualDuration!: string;
    recommendedRest!: string;
    actualRest!: string;
    intervalType!: IntervalType;
    distanceUnit!: DistanceUnit;
    actualRPE!: number;

    constructor(data?: IDTSetEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryID = _data["setEntryID"];
            this.movementID = _data["movementID"];
            this.movement = _data["movement"] ? Movement.fromJS(_data["movement"]) : <any>undefined;
            this.recommendedDistance = _data["recommendedDistance"];
            this.actualDistance = _data["actualDistance"];
            this.intervalDuration = _data["intervalDuration"];
            this.targetPace = _data["targetPace"];
            this.actualPace = _data["actualPace"];
            this.recommendedDuration = _data["recommendedDuration"];
            this.actualDuration = _data["actualDuration"];
            this.recommendedRest = _data["recommendedRest"];
            this.actualRest = _data["actualRest"];
            this.intervalType = _data["intervalType"];
            this.distanceUnit = _data["distanceUnit"];
            this.actualRPE = _data["actualRPE"];
        }
    }

    static fromJS(data: any): DTSetEntry {
        data = typeof data === 'object' ? data : {};
        let result = new DTSetEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryID"] = this.setEntryID;
        data["movementID"] = this.movementID;
        data["movement"] = this.movement ? this.movement.toJSON() : <any>undefined;
        data["recommendedDistance"] = this.recommendedDistance;
        data["actualDistance"] = this.actualDistance;
        data["intervalDuration"] = this.intervalDuration;
        data["targetPace"] = this.targetPace;
        data["actualPace"] = this.actualPace;
        data["recommendedDuration"] = this.recommendedDuration;
        data["actualDuration"] = this.actualDuration;
        data["recommendedRest"] = this.recommendedRest;
        data["actualRest"] = this.actualRest;
        data["intervalType"] = this.intervalType;
        data["distanceUnit"] = this.distanceUnit;
        data["actualRPE"] = this.actualRPE;
        return data;
    }
}

export interface IDTSetEntry {
    setEntryID: string;
    movementID: string;
    movement?: Movement;
    recommendedDistance: number;
    actualDistance: number;
    intervalDuration: string;
    targetPace: string;
    actualPace: string;
    recommendedDuration: string;
    actualDuration: string;
    recommendedRest: string;
    actualRest: string;
    intervalType: IntervalType;
    distanceUnit: DistanceUnit;
    actualRPE: number;
}

export class DTSetEntryDTO implements IDTSetEntryDTO {
    setEntryID?: string;
    movementID?: string;
    recommendedDistance?: number;
    actualDistance?: number;
    intervalDuration?: string;
    targetPace?: string;
    actualPace?: string;
    recommendedDuration?: string;
    actualDuration?: string;
    recommendedRest?: string;
    actualRest?: string;
    intervalType?: IntervalType;
    distanceUnit?: DistanceUnit;
    actualRPE?: number;

    constructor(data?: IDTSetEntryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryID = _data["setEntryID"];
            this.movementID = _data["movementID"];
            this.recommendedDistance = _data["recommendedDistance"];
            this.actualDistance = _data["actualDistance"];
            this.intervalDuration = _data["intervalDuration"];
            this.targetPace = _data["targetPace"];
            this.actualPace = _data["actualPace"];
            this.recommendedDuration = _data["recommendedDuration"];
            this.actualDuration = _data["actualDuration"];
            this.recommendedRest = _data["recommendedRest"];
            this.actualRest = _data["actualRest"];
            this.intervalType = _data["intervalType"];
            this.distanceUnit = _data["distanceUnit"];
            this.actualRPE = _data["actualRPE"];
        }
    }

    static fromJS(data: any): DTSetEntryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DTSetEntryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryID"] = this.setEntryID;
        data["movementID"] = this.movementID;
        data["recommendedDistance"] = this.recommendedDistance;
        data["actualDistance"] = this.actualDistance;
        data["intervalDuration"] = this.intervalDuration;
        data["targetPace"] = this.targetPace;
        data["actualPace"] = this.actualPace;
        data["recommendedDuration"] = this.recommendedDuration;
        data["actualDuration"] = this.actualDuration;
        data["recommendedRest"] = this.recommendedRest;
        data["actualRest"] = this.actualRest;
        data["intervalType"] = this.intervalType;
        data["distanceUnit"] = this.distanceUnit;
        data["actualRPE"] = this.actualRPE;
        return data;
    }
}

export interface IDTSetEntryDTO {
    setEntryID?: string;
    movementID?: string;
    recommendedDistance?: number;
    actualDistance?: number;
    intervalDuration?: string;
    targetPace?: string;
    actualPace?: string;
    recommendedDuration?: string;
    actualDuration?: string;
    recommendedRest?: string;
    actualRest?: string;
    intervalType?: IntervalType;
    distanceUnit?: DistanceUnit;
    actualRPE?: number;
}

export class DailyOuraDataDTO implements IDailyOuraDataDTO {
    objectID?: string;
    date?: Date;
    resilienceData?: ResilienceData;
    activityData?: ActivityData;
    sleepData?: SleepData;
    readinessData?: ReadinessData;

    constructor(data?: IDailyOuraDataDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectID = _data["objectID"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.resilienceData = _data["resilienceData"] ? ResilienceData.fromJS(_data["resilienceData"]) : <any>undefined;
            this.activityData = _data["activityData"] ? ActivityData.fromJS(_data["activityData"]) : <any>undefined;
            this.sleepData = _data["sleepData"] ? SleepData.fromJS(_data["sleepData"]) : <any>undefined;
            this.readinessData = _data["readinessData"] ? ReadinessData.fromJS(_data["readinessData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DailyOuraDataDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DailyOuraDataDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectID"] = this.objectID;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["resilienceData"] = this.resilienceData ? this.resilienceData.toJSON() : <any>undefined;
        data["activityData"] = this.activityData ? this.activityData.toJSON() : <any>undefined;
        data["sleepData"] = this.sleepData ? this.sleepData.toJSON() : <any>undefined;
        data["readinessData"] = this.readinessData ? this.readinessData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDailyOuraDataDTO {
    objectID?: string;
    date?: Date;
    resilienceData?: ResilienceData;
    activityData?: ActivityData;
    sleepData?: SleepData;
    readinessData?: ReadinessData;
}

export class DailyOuraInfo implements IDailyOuraInfo {
    objectID?: string;
    userID?: string;
    date?: Date;
    syncDate?: Date;
    resilienceData!: ResilienceData;
    activityData!: ActivityData;
    sleepData!: SleepData;
    readinessData!: ReadinessData;
    activityJson?: string | undefined;
    resilienceJson?: string | undefined;
    sleepJson?: string | undefined;
    readinessJson?: string | undefined;

    constructor(data?: IDailyOuraInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.resilienceData = new ResilienceData();
            this.activityData = new ActivityData();
            this.sleepData = new SleepData();
            this.readinessData = new ReadinessData();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectID = _data["objectID"];
            this.userID = _data["userID"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.syncDate = _data["syncDate"] ? new Date(_data["syncDate"].toString()) : <any>undefined;
            this.resilienceData = _data["resilienceData"] ? ResilienceData.fromJS(_data["resilienceData"]) : new ResilienceData();
            this.activityData = _data["activityData"] ? ActivityData.fromJS(_data["activityData"]) : new ActivityData();
            this.sleepData = _data["sleepData"] ? SleepData.fromJS(_data["sleepData"]) : new SleepData();
            this.readinessData = _data["readinessData"] ? ReadinessData.fromJS(_data["readinessData"]) : new ReadinessData();
            this.activityJson = _data["activityJson"];
            this.resilienceJson = _data["resilienceJson"];
            this.sleepJson = _data["sleepJson"];
            this.readinessJson = _data["readinessJson"];
        }
    }

    static fromJS(data: any): DailyOuraInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DailyOuraInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectID"] = this.objectID;
        data["userID"] = this.userID;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["syncDate"] = this.syncDate ? formatDate(this.syncDate) : <any>undefined;
        data["resilienceData"] = this.resilienceData ? this.resilienceData.toJSON() : <any>undefined;
        data["activityData"] = this.activityData ? this.activityData.toJSON() : <any>undefined;
        data["sleepData"] = this.sleepData ? this.sleepData.toJSON() : <any>undefined;
        data["readinessData"] = this.readinessData ? this.readinessData.toJSON() : <any>undefined;
        data["activityJson"] = this.activityJson;
        data["resilienceJson"] = this.resilienceJson;
        data["sleepJson"] = this.sleepJson;
        data["readinessJson"] = this.readinessJson;
        return data;
    }
}

export interface IDailyOuraInfo {
    objectID?: string;
    userID?: string;
    date?: Date;
    syncDate?: Date;
    resilienceData: ResilienceData;
    activityData: ActivityData;
    sleepData: SleepData;
    readinessData: ReadinessData;
    activityJson?: string | undefined;
    resilienceJson?: string | undefined;
    sleepJson?: string | undefined;
    readinessJson?: string | undefined;
}

export class DailyPredictionsDTO implements IDailyPredictionsDTO {
    expectedEnergyLevel?: ExpectedEnergyLevel;
    expectedPerformanceLevel?: ExpectedPerformanceLevel;
    expectedRecoveryCapacity?: ExpectedRecoveryCapacity;
    dayOutlook?: string | undefined;
    successFactors?: string[] | undefined;
    challengesFactors?: string[] | undefined;
    recommendations?: string[] | undefined;

    constructor(data?: IDailyPredictionsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expectedEnergyLevel = _data["expectedEnergyLevel"];
            this.expectedPerformanceLevel = _data["expectedPerformanceLevel"];
            this.expectedRecoveryCapacity = _data["expectedRecoveryCapacity"];
            this.dayOutlook = _data["dayOutlook"];
            if (Array.isArray(_data["successFactors"])) {
                this.successFactors = [] as any;
                for (let item of _data["successFactors"])
                    this.successFactors!.push(item);
            }
            if (Array.isArray(_data["challengesFactors"])) {
                this.challengesFactors = [] as any;
                for (let item of _data["challengesFactors"])
                    this.challengesFactors!.push(item);
            }
            if (Array.isArray(_data["recommendations"])) {
                this.recommendations = [] as any;
                for (let item of _data["recommendations"])
                    this.recommendations!.push(item);
            }
        }
    }

    static fromJS(data: any): DailyPredictionsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DailyPredictionsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expectedEnergyLevel"] = this.expectedEnergyLevel;
        data["expectedPerformanceLevel"] = this.expectedPerformanceLevel;
        data["expectedRecoveryCapacity"] = this.expectedRecoveryCapacity;
        data["dayOutlook"] = this.dayOutlook;
        if (Array.isArray(this.successFactors)) {
            data["successFactors"] = [];
            for (let item of this.successFactors)
                data["successFactors"].push(item);
        }
        if (Array.isArray(this.challengesFactors)) {
            data["challengesFactors"] = [];
            for (let item of this.challengesFactors)
                data["challengesFactors"].push(item);
        }
        if (Array.isArray(this.recommendations)) {
            data["recommendations"] = [];
            for (let item of this.recommendations)
                data["recommendations"].push(item);
        }
        return data;
    }
}

export interface IDailyPredictionsDTO {
    expectedEnergyLevel?: ExpectedEnergyLevel;
    expectedPerformanceLevel?: ExpectedPerformanceLevel;
    expectedRecoveryCapacity?: ExpectedRecoveryCapacity;
    dayOutlook?: string | undefined;
    successFactors?: string[] | undefined;
    challengesFactors?: string[] | undefined;
    recommendations?: string[] | undefined;
}

export class DailyRundownDTO implements IDailyRundownDTO {
    dailyRundownID?: string;
    userID?: string;
    reportDate?: Date;
    generatedAt?: Date;
    readinessAssessment?: ReadinessAssessmentDTO;
    sleepAnalysis?: SleepAnalysisDTO;
    trainingLoadAssessment?: TrainingLoadAssessmentDTO;
    healthTrends?: HealthTrendsDTO;
    injuryRiskAssessment?: InjuryRiskAssessmentDTO;
    trainingProgramGuidance?: TrainingProgramGuidanceDTO;
    dailyPredictions?: DailyPredictionsDTO;
    aiGeneratedInsights?: string | undefined;
    aiInsightsGeneratedAt?: Date | undefined;

    constructor(data?: IDailyRundownDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dailyRundownID = _data["dailyRundownID"];
            this.userID = _data["userID"];
            this.reportDate = _data["reportDate"] ? new Date(_data["reportDate"].toString()) : <any>undefined;
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.readinessAssessment = _data["readinessAssessment"] ? ReadinessAssessmentDTO.fromJS(_data["readinessAssessment"]) : <any>undefined;
            this.sleepAnalysis = _data["sleepAnalysis"] ? SleepAnalysisDTO.fromJS(_data["sleepAnalysis"]) : <any>undefined;
            this.trainingLoadAssessment = _data["trainingLoadAssessment"] ? TrainingLoadAssessmentDTO.fromJS(_data["trainingLoadAssessment"]) : <any>undefined;
            this.healthTrends = _data["healthTrends"] ? HealthTrendsDTO.fromJS(_data["healthTrends"]) : <any>undefined;
            this.injuryRiskAssessment = _data["injuryRiskAssessment"] ? InjuryRiskAssessmentDTO.fromJS(_data["injuryRiskAssessment"]) : <any>undefined;
            this.trainingProgramGuidance = _data["trainingProgramGuidance"] ? TrainingProgramGuidanceDTO.fromJS(_data["trainingProgramGuidance"]) : <any>undefined;
            this.dailyPredictions = _data["dailyPredictions"] ? DailyPredictionsDTO.fromJS(_data["dailyPredictions"]) : <any>undefined;
            this.aiGeneratedInsights = _data["aiGeneratedInsights"];
            this.aiInsightsGeneratedAt = _data["aiInsightsGeneratedAt"] ? new Date(_data["aiInsightsGeneratedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DailyRundownDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DailyRundownDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dailyRundownID"] = this.dailyRundownID;
        data["userID"] = this.userID;
        data["reportDate"] = this.reportDate ? formatDate(this.reportDate) : <any>undefined;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["readinessAssessment"] = this.readinessAssessment ? this.readinessAssessment.toJSON() : <any>undefined;
        data["sleepAnalysis"] = this.sleepAnalysis ? this.sleepAnalysis.toJSON() : <any>undefined;
        data["trainingLoadAssessment"] = this.trainingLoadAssessment ? this.trainingLoadAssessment.toJSON() : <any>undefined;
        data["healthTrends"] = this.healthTrends ? this.healthTrends.toJSON() : <any>undefined;
        data["injuryRiskAssessment"] = this.injuryRiskAssessment ? this.injuryRiskAssessment.toJSON() : <any>undefined;
        data["trainingProgramGuidance"] = this.trainingProgramGuidance ? this.trainingProgramGuidance.toJSON() : <any>undefined;
        data["dailyPredictions"] = this.dailyPredictions ? this.dailyPredictions.toJSON() : <any>undefined;
        data["aiGeneratedInsights"] = this.aiGeneratedInsights;
        data["aiInsightsGeneratedAt"] = this.aiInsightsGeneratedAt ? this.aiInsightsGeneratedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDailyRundownDTO {
    dailyRundownID?: string;
    userID?: string;
    reportDate?: Date;
    generatedAt?: Date;
    readinessAssessment?: ReadinessAssessmentDTO;
    sleepAnalysis?: SleepAnalysisDTO;
    trainingLoadAssessment?: TrainingLoadAssessmentDTO;
    healthTrends?: HealthTrendsDTO;
    injuryRiskAssessment?: InjuryRiskAssessmentDTO;
    trainingProgramGuidance?: TrainingProgramGuidanceDTO;
    dailyPredictions?: DailyPredictionsDTO;
    aiGeneratedInsights?: string | undefined;
    aiInsightsGeneratedAt?: Date | undefined;
}

export class DailyRundownSummaryDTO implements IDailyRundownSummaryDTO {
    dailyRundownID?: string;
    reportDate?: Date;
    generatedAt?: Date;
    overallReadiness?: ReadinessLevel;
    recoveryStatus?: RecoveryStatus;
    expectedPerformance?: ExpectedPerformanceLevel;
    hasAIInsights?: boolean;

    constructor(data?: IDailyRundownSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dailyRundownID = _data["dailyRundownID"];
            this.reportDate = _data["reportDate"] ? new Date(_data["reportDate"].toString()) : <any>undefined;
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.overallReadiness = _data["overallReadiness"];
            this.recoveryStatus = _data["recoveryStatus"];
            this.expectedPerformance = _data["expectedPerformance"];
            this.hasAIInsights = _data["hasAIInsights"];
        }
    }

    static fromJS(data: any): DailyRundownSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DailyRundownSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dailyRundownID"] = this.dailyRundownID;
        data["reportDate"] = this.reportDate ? formatDate(this.reportDate) : <any>undefined;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["overallReadiness"] = this.overallReadiness;
        data["recoveryStatus"] = this.recoveryStatus;
        data["expectedPerformance"] = this.expectedPerformance;
        data["hasAIInsights"] = this.hasAIInsights;
        return data;
    }
}

export interface IDailyRundownSummaryDTO {
    dailyRundownID?: string;
    reportDate?: Date;
    generatedAt?: Date;
    overallReadiness?: ReadinessLevel;
    recoveryStatus?: RecoveryStatus;
    expectedPerformance?: ExpectedPerformanceLevel;
    hasAIInsights?: boolean;
}

export class DateRangeRequest implements IDateRangeRequest {
    startDate!: Date;
    endDate!: Date;

    constructor(data?: IDateRangeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateRangeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        return data;
    }
}

export interface IDateRangeRequest {
    startDate: Date;
    endDate: Date;
}

export enum DayRating {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class DaySummaryDTO implements IDaySummaryDTO {
    overallDayRating?: DayRating;
    trainingSessionsCompleted?: number;
    activitiesCompleted?: number;
    totalActiveMinutes?: number;
    totalCaloriesBurned?: number;
    daySummaryText?: string | undefined;
    highlights?: string[] | undefined;

    constructor(data?: IDaySummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.overallDayRating = _data["overallDayRating"];
            this.trainingSessionsCompleted = _data["trainingSessionsCompleted"];
            this.activitiesCompleted = _data["activitiesCompleted"];
            this.totalActiveMinutes = _data["totalActiveMinutes"];
            this.totalCaloriesBurned = _data["totalCaloriesBurned"];
            this.daySummaryText = _data["daySummaryText"];
            if (Array.isArray(_data["highlights"])) {
                this.highlights = [] as any;
                for (let item of _data["highlights"])
                    this.highlights!.push(item);
            }
        }
    }

    static fromJS(data: any): DaySummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DaySummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["overallDayRating"] = this.overallDayRating;
        data["trainingSessionsCompleted"] = this.trainingSessionsCompleted;
        data["activitiesCompleted"] = this.activitiesCompleted;
        data["totalActiveMinutes"] = this.totalActiveMinutes;
        data["totalCaloriesBurned"] = this.totalCaloriesBurned;
        data["daySummaryText"] = this.daySummaryText;
        if (Array.isArray(this.highlights)) {
            data["highlights"] = [];
            for (let item of this.highlights)
                data["highlights"].push(item);
        }
        return data;
    }
}

export interface IDaySummaryDTO {
    overallDayRating?: DayRating;
    trainingSessionsCompleted?: number;
    activitiesCompleted?: number;
    totalActiveMinutes?: number;
    totalCaloriesBurned?: number;
    daySummaryText?: string | undefined;
    highlights?: string[] | undefined;
}

export enum DistanceUnit {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class Equipment implements IEquipment {
    equipmentID!: string;
    name!: string;
    userID!: string;

    constructor(data?: IEquipment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentID = _data["equipmentID"];
            this.name = _data["name"];
            this.userID = _data["userID"];
        }
    }

    static fromJS(data: any): Equipment {
        data = typeof data === 'object' ? data : {};
        let result = new Equipment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentID"] = this.equipmentID;
        data["name"] = this.name;
        data["userID"] = this.userID;
        return data;
    }
}

export interface IEquipment {
    equipmentID: string;
    name: string;
    userID: string;
}

export enum ExpectedEnergyLevel {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum ExpectedPerformanceLevel {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum ExpectedRecoveryCapacity {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum ExpectedRecoveryLevel {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class ExternalFactorsSummaryDTO implements IExternalFactorsSummaryDTO {
    wellnessOverallScore?: number | undefined;
    energyScore?: number | undefined;
    motivationScore?: number | undefined;
    moodScore?: number | undefined;
    stressScore?: number | undefined;
    sleepScore?: number | undefined;
    readinessScore?: number | undefined;
    activityScore?: number | undefined;
    sleepRecovery?: number | undefined;
    daytimeRecovery?: number | undefined;
    resilienceStress?: number | undefined;
    totalSleepMinutes?: number | undefined;
    deepSleepMinutes?: number | undefined;
    remSleepMinutes?: number | undefined;
    sleepEfficiency?: number | undefined;
    temperatureDeviation?: number | undefined;
    hrv?: number | undefined;
    restingHeartRate?: number | undefined;
    trainingSessionsLast7Days?: number | undefined;
    trainingSessionsLast30Days?: number | undefined;
    averageSessionDurationMinutes?: number | undefined;
    activitiesLast7Days?: number | undefined;
    totalCaloriesBurnedLast7Days?: number | undefined;
    activeInjuryCount?: number | undefined;
    activeInjuryNames?: string[] | undefined;
    recoveryStatus?: RecoveryStatus;
    factorsSummaryText?: string | undefined;

    constructor(data?: IExternalFactorsSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wellnessOverallScore = _data["wellnessOverallScore"];
            this.energyScore = _data["energyScore"];
            this.motivationScore = _data["motivationScore"];
            this.moodScore = _data["moodScore"];
            this.stressScore = _data["stressScore"];
            this.sleepScore = _data["sleepScore"];
            this.readinessScore = _data["readinessScore"];
            this.activityScore = _data["activityScore"];
            this.sleepRecovery = _data["sleepRecovery"];
            this.daytimeRecovery = _data["daytimeRecovery"];
            this.resilienceStress = _data["resilienceStress"];
            this.totalSleepMinutes = _data["totalSleepMinutes"];
            this.deepSleepMinutes = _data["deepSleepMinutes"];
            this.remSleepMinutes = _data["remSleepMinutes"];
            this.sleepEfficiency = _data["sleepEfficiency"];
            this.temperatureDeviation = _data["temperatureDeviation"];
            this.hrv = _data["hrv"];
            this.restingHeartRate = _data["restingHeartRate"];
            this.trainingSessionsLast7Days = _data["trainingSessionsLast7Days"];
            this.trainingSessionsLast30Days = _data["trainingSessionsLast30Days"];
            this.averageSessionDurationMinutes = _data["averageSessionDurationMinutes"];
            this.activitiesLast7Days = _data["activitiesLast7Days"];
            this.totalCaloriesBurnedLast7Days = _data["totalCaloriesBurnedLast7Days"];
            this.activeInjuryCount = _data["activeInjuryCount"];
            if (Array.isArray(_data["activeInjuryNames"])) {
                this.activeInjuryNames = [] as any;
                for (let item of _data["activeInjuryNames"])
                    this.activeInjuryNames!.push(item);
            }
            this.recoveryStatus = _data["recoveryStatus"];
            this.factorsSummaryText = _data["factorsSummaryText"];
        }
    }

    static fromJS(data: any): ExternalFactorsSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalFactorsSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wellnessOverallScore"] = this.wellnessOverallScore;
        data["energyScore"] = this.energyScore;
        data["motivationScore"] = this.motivationScore;
        data["moodScore"] = this.moodScore;
        data["stressScore"] = this.stressScore;
        data["sleepScore"] = this.sleepScore;
        data["readinessScore"] = this.readinessScore;
        data["activityScore"] = this.activityScore;
        data["sleepRecovery"] = this.sleepRecovery;
        data["daytimeRecovery"] = this.daytimeRecovery;
        data["resilienceStress"] = this.resilienceStress;
        data["totalSleepMinutes"] = this.totalSleepMinutes;
        data["deepSleepMinutes"] = this.deepSleepMinutes;
        data["remSleepMinutes"] = this.remSleepMinutes;
        data["sleepEfficiency"] = this.sleepEfficiency;
        data["temperatureDeviation"] = this.temperatureDeviation;
        data["hrv"] = this.hrv;
        data["restingHeartRate"] = this.restingHeartRate;
        data["trainingSessionsLast7Days"] = this.trainingSessionsLast7Days;
        data["trainingSessionsLast30Days"] = this.trainingSessionsLast30Days;
        data["averageSessionDurationMinutes"] = this.averageSessionDurationMinutes;
        data["activitiesLast7Days"] = this.activitiesLast7Days;
        data["totalCaloriesBurnedLast7Days"] = this.totalCaloriesBurnedLast7Days;
        data["activeInjuryCount"] = this.activeInjuryCount;
        if (Array.isArray(this.activeInjuryNames)) {
            data["activeInjuryNames"] = [];
            for (let item of this.activeInjuryNames)
                data["activeInjuryNames"].push(item);
        }
        data["recoveryStatus"] = this.recoveryStatus;
        data["factorsSummaryText"] = this.factorsSummaryText;
        return data;
    }
}

export interface IExternalFactorsSummaryDTO {
    wellnessOverallScore?: number | undefined;
    energyScore?: number | undefined;
    motivationScore?: number | undefined;
    moodScore?: number | undefined;
    stressScore?: number | undefined;
    sleepScore?: number | undefined;
    readinessScore?: number | undefined;
    activityScore?: number | undefined;
    sleepRecovery?: number | undefined;
    daytimeRecovery?: number | undefined;
    resilienceStress?: number | undefined;
    totalSleepMinutes?: number | undefined;
    deepSleepMinutes?: number | undefined;
    remSleepMinutes?: number | undefined;
    sleepEfficiency?: number | undefined;
    temperatureDeviation?: number | undefined;
    hrv?: number | undefined;
    restingHeartRate?: number | undefined;
    trainingSessionsLast7Days?: number | undefined;
    trainingSessionsLast30Days?: number | undefined;
    averageSessionDurationMinutes?: number | undefined;
    activitiesLast7Days?: number | undefined;
    totalCaloriesBurnedLast7Days?: number | undefined;
    activeInjuryCount?: number | undefined;
    activeInjuryNames?: string[] | undefined;
    recoveryStatus?: RecoveryStatus;
    factorsSummaryText?: string | undefined;
}

export enum FatigueLevel {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email!: string | undefined;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email: string | undefined;
}

export class GenerateDailyRundownRequest implements IGenerateDailyRundownRequest {
    date?: Date | undefined;

    constructor(data?: IGenerateDailyRundownRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GenerateDailyRundownRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateDailyRundownRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        return data;
    }
}

export interface IGenerateDailyRundownRequest {
    date?: Date | undefined;
}

export class GenerateNightlyBreakdownRequest implements IGenerateNightlyBreakdownRequest {
    date?: Date | undefined;

    constructor(data?: IGenerateNightlyBreakdownRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GenerateNightlyBreakdownRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateNightlyBreakdownRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        return data;
    }
}

export interface IGenerateNightlyBreakdownRequest {
    date?: Date | undefined;
}

export class GenerateSessionReportRequest implements IGenerateSessionReportRequest {
    trainingSessionID!: string;

    constructor(data?: IGenerateSessionReportRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
        }
    }

    static fromJS(data: any): GenerateSessionReportRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateSessionReportRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        return data;
    }
}

export interface IGenerateSessionReportRequest {
    trainingSessionID: string;
}

export class HealthTrendsDTO implements IHealthTrendsDTO {
    hrvTrend?: TrendDirection;
    restingHRTrend?: TrendDirection;
    sleepQualityTrend?: TrendDirection;
    stressTrend?: TrendDirection;
    energyTrend?: TrendDirection;
    trendsSummary?: string | undefined;
    positiveTrends?: string[] | undefined;
    concerningTrends?: string[] | undefined;

    constructor(data?: IHealthTrendsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hrvTrend = _data["hrvTrend"];
            this.restingHRTrend = _data["restingHRTrend"];
            this.sleepQualityTrend = _data["sleepQualityTrend"];
            this.stressTrend = _data["stressTrend"];
            this.energyTrend = _data["energyTrend"];
            this.trendsSummary = _data["trendsSummary"];
            if (Array.isArray(_data["positiveTrends"])) {
                this.positiveTrends = [] as any;
                for (let item of _data["positiveTrends"])
                    this.positiveTrends!.push(item);
            }
            if (Array.isArray(_data["concerningTrends"])) {
                this.concerningTrends = [] as any;
                for (let item of _data["concerningTrends"])
                    this.concerningTrends!.push(item);
            }
        }
    }

    static fromJS(data: any): HealthTrendsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new HealthTrendsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hrvTrend"] = this.hrvTrend;
        data["restingHRTrend"] = this.restingHRTrend;
        data["sleepQualityTrend"] = this.sleepQualityTrend;
        data["stressTrend"] = this.stressTrend;
        data["energyTrend"] = this.energyTrend;
        data["trendsSummary"] = this.trendsSummary;
        if (Array.isArray(this.positiveTrends)) {
            data["positiveTrends"] = [];
            for (let item of this.positiveTrends)
                data["positiveTrends"].push(item);
        }
        if (Array.isArray(this.concerningTrends)) {
            data["concerningTrends"] = [];
            for (let item of this.concerningTrends)
                data["concerningTrends"].push(item);
        }
        return data;
    }
}

export interface IHealthTrendsDTO {
    hrvTrend?: TrendDirection;
    restingHRTrend?: TrendDirection;
    sleepQualityTrend?: TrendDirection;
    stressTrend?: TrendDirection;
    energyTrend?: TrendDirection;
    trendsSummary?: string | undefined;
    positiveTrends?: string[] | undefined;
    concerningTrends?: string[] | undefined;
}

export class HttpValidationProblemDetails implements IHttpValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IHttpValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;
}

export class ISetEntryDTO implements IISetEntryDTO {

    constructor(data?: IISetEntryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ISetEntryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ISetEntryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IISetEntryDTO {
}

export class IdentityUser implements IIdentityUser {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;

    constructor(data?: IIdentityUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): IdentityUser {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IIdentityUser {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export class InfoRequest implements IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;

    constructor(data?: IInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newEmail = _data["newEmail"];
            this.newPassword = _data["newPassword"];
            this.oldPassword = _data["oldPassword"];
        }
    }

    static fromJS(data: any): InfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newEmail"] = this.newEmail;
        data["newPassword"] = this.newPassword;
        data["oldPassword"] = this.oldPassword;
        return data;
    }
}

export interface IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;
}

export class InfoResponse implements IInfoResponse {
    email!: string | undefined;
    isEmailConfirmed!: boolean;

    constructor(data?: IInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
        }
    }

    static fromJS(data: any): InfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        return data;
    }
}

export interface IInfoResponse {
    email: string | undefined;
    isEmailConfirmed: boolean;
}

export class Injury implements IInjury {
    injuryID?: string;
    userID!: string;
    name!: string;
    notes!: string;
    injuryDate!: Date;
    isActive?: boolean;
    injuryEvents?: InjuryEvent[] | undefined;

    constructor(data?: IInjury) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.injuryID = _data["injuryID"];
            this.userID = _data["userID"];
            this.name = _data["name"];
            this.notes = _data["notes"];
            this.injuryDate = _data["injuryDate"] ? new Date(_data["injuryDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["injuryEvents"])) {
                this.injuryEvents = [] as any;
                for (let item of _data["injuryEvents"])
                    this.injuryEvents!.push(InjuryEvent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Injury {
        data = typeof data === 'object' ? data : {};
        let result = new Injury();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["injuryID"] = this.injuryID;
        data["userID"] = this.userID;
        data["name"] = this.name;
        data["notes"] = this.notes;
        data["injuryDate"] = this.injuryDate ? formatDate(this.injuryDate) : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.injuryEvents)) {
            data["injuryEvents"] = [];
            for (let item of this.injuryEvents)
                data["injuryEvents"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IInjury {
    injuryID?: string;
    userID: string;
    name: string;
    notes: string;
    injuryDate: Date;
    isActive?: boolean;
    injuryEvents?: InjuryEvent[] | undefined;
}

export class InjuryDTO implements IInjuryDTO {
    injuryID!: string;
    name!: string;
    notes!: string;
    injuryDate!: Date;
    isActive!: boolean;
    injuryEvents!: InjuryEventDTO[];

    constructor(data?: IInjuryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.injuryEvents = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.injuryID = _data["injuryID"];
            this.name = _data["name"];
            this.notes = _data["notes"];
            this.injuryDate = _data["injuryDate"] ? new Date(_data["injuryDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["injuryEvents"])) {
                this.injuryEvents = [] as any;
                for (let item of _data["injuryEvents"])
                    this.injuryEvents!.push(InjuryEventDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InjuryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InjuryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["injuryID"] = this.injuryID;
        data["name"] = this.name;
        data["notes"] = this.notes;
        data["injuryDate"] = this.injuryDate ? formatDate(this.injuryDate) : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.injuryEvents)) {
            data["injuryEvents"] = [];
            for (let item of this.injuryEvents)
                data["injuryEvents"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IInjuryDTO {
    injuryID: string;
    name: string;
    notes: string;
    injuryDate: Date;
    isActive: boolean;
    injuryEvents: InjuryEventDTO[];
}

export class InjuryEvent implements IInjuryEvent {
    injuryEventID?: string;
    injuryID!: string;
    injury?: Injury;
    trainingSessionID!: string;
    notes?: string | undefined;
    painLevel?: number;
    injuryType?: InjuryEventType;
    creationTime?: Date;

    constructor(data?: IInjuryEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.injuryEventID = _data["injuryEventID"];
            this.injuryID = _data["injuryID"];
            this.injury = _data["injury"] ? Injury.fromJS(_data["injury"]) : <any>undefined;
            this.trainingSessionID = _data["trainingSessionID"];
            this.notes = _data["notes"];
            this.painLevel = _data["painLevel"];
            this.injuryType = _data["injuryType"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InjuryEvent {
        data = typeof data === 'object' ? data : {};
        let result = new InjuryEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["injuryEventID"] = this.injuryEventID;
        data["injuryID"] = this.injuryID;
        data["injury"] = this.injury ? this.injury.toJSON() : <any>undefined;
        data["trainingSessionID"] = this.trainingSessionID;
        data["notes"] = this.notes;
        data["painLevel"] = this.painLevel;
        data["injuryType"] = this.injuryType;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IInjuryEvent {
    injuryEventID?: string;
    injuryID: string;
    injury?: Injury;
    trainingSessionID: string;
    notes?: string | undefined;
    painLevel?: number;
    injuryType?: InjuryEventType;
    creationTime?: Date;
}

export class InjuryEventDTO implements IInjuryEventDTO {
    injuryEventID!: string;
    trainingSessionID?: string | undefined;
    notes!: string;
    painLevel!: number;
    injuryType!: InjuryEventType;
    creationTime!: Date;

    constructor(data?: IInjuryEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.injuryEventID = _data["injuryEventID"];
            this.trainingSessionID = _data["trainingSessionID"];
            this.notes = _data["notes"];
            this.painLevel = _data["painLevel"];
            this.injuryType = _data["injuryType"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InjuryEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InjuryEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["injuryEventID"] = this.injuryEventID;
        data["trainingSessionID"] = this.trainingSessionID;
        data["notes"] = this.notes;
        data["painLevel"] = this.painLevel;
        data["injuryType"] = this.injuryType;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IInjuryEventDTO {
    injuryEventID: string;
    trainingSessionID?: string | undefined;
    notes: string;
    painLevel: number;
    injuryType: InjuryEventType;
    creationTime: Date;
}

export enum InjuryEventType {
    _0 = 0,
    _1 = 1,
}

export class InjuryRiskAssessmentDTO implements IInjuryRiskAssessmentDTO {
    overallRiskLevel?: InjuryRiskLevel;
    activeInjuryCount?: number;
    activeInjuries?: ActiveInjuryDetailDTO[] | undefined;
    riskSummary?: string | undefined;
    riskFactors?: string[] | undefined;
    preventionRecommendations?: string[] | undefined;

    constructor(data?: IInjuryRiskAssessmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.overallRiskLevel = _data["overallRiskLevel"];
            this.activeInjuryCount = _data["activeInjuryCount"];
            if (Array.isArray(_data["activeInjuries"])) {
                this.activeInjuries = [] as any;
                for (let item of _data["activeInjuries"])
                    this.activeInjuries!.push(ActiveInjuryDetailDTO.fromJS(item));
            }
            this.riskSummary = _data["riskSummary"];
            if (Array.isArray(_data["riskFactors"])) {
                this.riskFactors = [] as any;
                for (let item of _data["riskFactors"])
                    this.riskFactors!.push(item);
            }
            if (Array.isArray(_data["preventionRecommendations"])) {
                this.preventionRecommendations = [] as any;
                for (let item of _data["preventionRecommendations"])
                    this.preventionRecommendations!.push(item);
            }
        }
    }

    static fromJS(data: any): InjuryRiskAssessmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InjuryRiskAssessmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["overallRiskLevel"] = this.overallRiskLevel;
        data["activeInjuryCount"] = this.activeInjuryCount;
        if (Array.isArray(this.activeInjuries)) {
            data["activeInjuries"] = [];
            for (let item of this.activeInjuries)
                data["activeInjuries"].push(item ? item.toJSON() : <any>undefined);
        }
        data["riskSummary"] = this.riskSummary;
        if (Array.isArray(this.riskFactors)) {
            data["riskFactors"] = [];
            for (let item of this.riskFactors)
                data["riskFactors"].push(item);
        }
        if (Array.isArray(this.preventionRecommendations)) {
            data["preventionRecommendations"] = [];
            for (let item of this.preventionRecommendations)
                data["preventionRecommendations"].push(item);
        }
        return data;
    }
}

export interface IInjuryRiskAssessmentDTO {
    overallRiskLevel?: InjuryRiskLevel;
    activeInjuryCount?: number;
    activeInjuries?: ActiveInjuryDetailDTO[] | undefined;
    riskSummary?: string | undefined;
    riskFactors?: string[] | undefined;
    preventionRecommendations?: string[] | undefined;
}

export enum InjuryRiskLevel {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum IntervalType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export class LiftDetails implements ILiftDetails {
    activityID?: string;
    tonnage?: number;
    liftType?: string | undefined;
    liftFocus?: string | undefined;
    quadSets?: number;
    hamstringSets?: number;
    bicepSets?: number;
    tricepSets?: number;
    shoulderSets?: number;
    chestSets?: number;
    backSets?: number;

    constructor(data?: ILiftDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityID = _data["activityID"];
            this.tonnage = _data["tonnage"];
            this.liftType = _data["liftType"];
            this.liftFocus = _data["liftFocus"];
            this.quadSets = _data["quadSets"];
            this.hamstringSets = _data["hamstringSets"];
            this.bicepSets = _data["bicepSets"];
            this.tricepSets = _data["tricepSets"];
            this.shoulderSets = _data["shoulderSets"];
            this.chestSets = _data["chestSets"];
            this.backSets = _data["backSets"];
        }
    }

    static fromJS(data: any): LiftDetails {
        data = typeof data === 'object' ? data : {};
        let result = new LiftDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityID"] = this.activityID;
        data["tonnage"] = this.tonnage;
        data["liftType"] = this.liftType;
        data["liftFocus"] = this.liftFocus;
        data["quadSets"] = this.quadSets;
        data["hamstringSets"] = this.hamstringSets;
        data["bicepSets"] = this.bicepSets;
        data["tricepSets"] = this.tricepSets;
        data["shoulderSets"] = this.shoulderSets;
        data["chestSets"] = this.chestSets;
        data["backSets"] = this.backSets;
        return data;
    }
}

export interface ILiftDetails {
    activityID?: string;
    tonnage?: number;
    liftType?: string | undefined;
    liftFocus?: string | undefined;
    quadSets?: number;
    hamstringSets?: number;
    bicepSets?: number;
    tricepSets?: number;
    shoulderSets?: number;
    chestSets?: number;
    backSets?: number;
}

export class LiftSetEntry implements ILiftSetEntry {
    setEntryID?: string;
    movementID?: string;
    movement?: Movement;
    recommendedReps?: number;
    recommendedWeight?: number;
    recommendedRPE?: number;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit!: WeightUnit;

    constructor(data?: ILiftSetEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryID = _data["setEntryID"];
            this.movementID = _data["movementID"];
            this.movement = _data["movement"] ? Movement.fromJS(_data["movement"]) : <any>undefined;
            this.recommendedReps = _data["recommendedReps"];
            this.recommendedWeight = _data["recommendedWeight"];
            this.recommendedRPE = _data["recommendedRPE"];
            this.actualReps = _data["actualReps"];
            this.actualWeight = _data["actualWeight"];
            this.actualRPE = _data["actualRPE"];
            this.weightUnit = _data["weightUnit"];
        }
    }

    static fromJS(data: any): LiftSetEntry {
        data = typeof data === 'object' ? data : {};
        let result = new LiftSetEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryID"] = this.setEntryID;
        data["movementID"] = this.movementID;
        data["movement"] = this.movement ? this.movement.toJSON() : <any>undefined;
        data["recommendedReps"] = this.recommendedReps;
        data["recommendedWeight"] = this.recommendedWeight;
        data["recommendedRPE"] = this.recommendedRPE;
        data["actualReps"] = this.actualReps;
        data["actualWeight"] = this.actualWeight;
        data["actualRPE"] = this.actualRPE;
        data["weightUnit"] = this.weightUnit;
        return data;
    }
}

export interface ILiftSetEntry {
    setEntryID?: string;
    movementID?: string;
    movement?: Movement;
    recommendedReps?: number;
    recommendedWeight?: number;
    recommendedRPE?: number;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit: WeightUnit;
}

export class LiftSetEntryDTO implements ILiftSetEntryDTO {
    setEntryID?: string;
    movementID?: string;
    recommendedReps?: number;
    recommendedWeight?: number;
    recommendedRPE?: number;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit?: WeightUnit;

    constructor(data?: ILiftSetEntryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryID = _data["setEntryID"];
            this.movementID = _data["movementID"];
            this.recommendedReps = _data["recommendedReps"];
            this.recommendedWeight = _data["recommendedWeight"];
            this.recommendedRPE = _data["recommendedRPE"];
            this.actualReps = _data["actualReps"];
            this.actualWeight = _data["actualWeight"];
            this.actualRPE = _data["actualRPE"];
            this.weightUnit = _data["weightUnit"];
        }
    }

    static fromJS(data: any): LiftSetEntryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LiftSetEntryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryID"] = this.setEntryID;
        data["movementID"] = this.movementID;
        data["recommendedReps"] = this.recommendedReps;
        data["recommendedWeight"] = this.recommendedWeight;
        data["recommendedRPE"] = this.recommendedRPE;
        data["actualReps"] = this.actualReps;
        data["actualWeight"] = this.actualWeight;
        data["actualRPE"] = this.actualRPE;
        data["weightUnit"] = this.weightUnit;
        return data;
    }
}

export interface ILiftSetEntryDTO {
    setEntryID?: string;
    movementID?: string;
    recommendedReps?: number;
    recommendedWeight?: number;
    recommendedRPE?: number;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit?: WeightUnit;
}

export class LionheartUser implements ILionheartUser {
    userID?: string;
    identityUser?: IdentityUser;
    name?: string | undefined;
    age?: number;
    weight?: number;
    wellnessStates?: WellnessState[] | undefined;
    activities?: Activity[] | undefined;
    apiAccessTokens?: ApiAccessToken[] | undefined;
    dailyOuraInfos?: DailyOuraInfo[] | undefined;
    trainingPrograms?: TrainingProgram[] | undefined;
    movementBases?: MovementBase[] | undefined;
    equipments?: Equipment[] | undefined;
    injuries?: Injury[] | undefined;
    chatConversations?: ChatConversation[] | undefined;

    constructor(data?: ILionheartUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userID = _data["userID"];
            this.identityUser = _data["identityUser"] ? IdentityUser.fromJS(_data["identityUser"]) : <any>undefined;
            this.name = _data["name"];
            this.age = _data["age"];
            this.weight = _data["weight"];
            if (Array.isArray(_data["wellnessStates"])) {
                this.wellnessStates = [] as any;
                for (let item of _data["wellnessStates"])
                    this.wellnessStates!.push(WellnessState.fromJS(item));
            }
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(Activity.fromJS(item));
            }
            if (Array.isArray(_data["apiAccessTokens"])) {
                this.apiAccessTokens = [] as any;
                for (let item of _data["apiAccessTokens"])
                    this.apiAccessTokens!.push(ApiAccessToken.fromJS(item));
            }
            if (Array.isArray(_data["dailyOuraInfos"])) {
                this.dailyOuraInfos = [] as any;
                for (let item of _data["dailyOuraInfos"])
                    this.dailyOuraInfos!.push(DailyOuraInfo.fromJS(item));
            }
            if (Array.isArray(_data["trainingPrograms"])) {
                this.trainingPrograms = [] as any;
                for (let item of _data["trainingPrograms"])
                    this.trainingPrograms!.push(TrainingProgram.fromJS(item));
            }
            if (Array.isArray(_data["movementBases"])) {
                this.movementBases = [] as any;
                for (let item of _data["movementBases"])
                    this.movementBases!.push(MovementBase.fromJS(item));
            }
            if (Array.isArray(_data["equipments"])) {
                this.equipments = [] as any;
                for (let item of _data["equipments"])
                    this.equipments!.push(Equipment.fromJS(item));
            }
            if (Array.isArray(_data["injuries"])) {
                this.injuries = [] as any;
                for (let item of _data["injuries"])
                    this.injuries!.push(Injury.fromJS(item));
            }
            if (Array.isArray(_data["chatConversations"])) {
                this.chatConversations = [] as any;
                for (let item of _data["chatConversations"])
                    this.chatConversations!.push(ChatConversation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LionheartUser {
        data = typeof data === 'object' ? data : {};
        let result = new LionheartUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userID"] = this.userID;
        data["identityUser"] = this.identityUser ? this.identityUser.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["age"] = this.age;
        data["weight"] = this.weight;
        if (Array.isArray(this.wellnessStates)) {
            data["wellnessStates"] = [];
            for (let item of this.wellnessStates)
                data["wellnessStates"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.apiAccessTokens)) {
            data["apiAccessTokens"] = [];
            for (let item of this.apiAccessTokens)
                data["apiAccessTokens"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.dailyOuraInfos)) {
            data["dailyOuraInfos"] = [];
            for (let item of this.dailyOuraInfos)
                data["dailyOuraInfos"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.trainingPrograms)) {
            data["trainingPrograms"] = [];
            for (let item of this.trainingPrograms)
                data["trainingPrograms"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.movementBases)) {
            data["movementBases"] = [];
            for (let item of this.movementBases)
                data["movementBases"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.equipments)) {
            data["equipments"] = [];
            for (let item of this.equipments)
                data["equipments"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.injuries)) {
            data["injuries"] = [];
            for (let item of this.injuries)
                data["injuries"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.chatConversations)) {
            data["chatConversations"] = [];
            for (let item of this.chatConversations)
                data["chatConversations"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ILionheartUser {
    userID?: string;
    identityUser?: IdentityUser;
    name?: string | undefined;
    age?: number;
    weight?: number;
    wellnessStates?: WellnessState[] | undefined;
    activities?: Activity[] | undefined;
    apiAccessTokens?: ApiAccessToken[] | undefined;
    dailyOuraInfos?: DailyOuraInfo[] | undefined;
    trainingPrograms?: TrainingProgram[] | undefined;
    movementBases?: MovementBase[] | undefined;
    equipments?: Equipment[] | undefined;
    injuries?: Injury[] | undefined;
    chatConversations?: ChatConversation[] | undefined;
}

export class LoginRequest implements ILoginRequest {
    email!: string | undefined;
    password!: string | undefined;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.twoFactorRecoveryCode = _data["twoFactorRecoveryCode"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["twoFactorCode"] = this.twoFactorCode;
        data["twoFactorRecoveryCode"] = this.twoFactorRecoveryCode;
        return data;
    }
}

export interface ILoginRequest {
    email: string | undefined;
    password: string | undefined;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;
}

export class Movement implements IMovement {
    movementID!: string;
    trainingSessionID!: string;
    trainingSession?: TrainingSession;
    movementBaseID!: string;
    movementBase!: MovementBase;
    movementModifier!: MovementModifier;
    liftSets!: LiftSetEntry[] | undefined;
    distanceTimeSets!: DTSetEntry[] | undefined;
    notes!: string | undefined;
    isCompleted!: boolean;
    ordering!: number;

    constructor(data?: IMovement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.movementBase = new MovementBase();
            this.movementModifier = new MovementModifier();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementID = _data["movementID"];
            this.trainingSessionID = _data["trainingSessionID"];
            this.trainingSession = _data["trainingSession"] ? TrainingSession.fromJS(_data["trainingSession"]) : <any>undefined;
            this.movementBaseID = _data["movementBaseID"];
            this.movementBase = _data["movementBase"] ? MovementBase.fromJS(_data["movementBase"]) : new MovementBase();
            this.movementModifier = _data["movementModifier"] ? MovementModifier.fromJS(_data["movementModifier"]) : new MovementModifier();
            if (Array.isArray(_data["liftSets"])) {
                this.liftSets = [] as any;
                for (let item of _data["liftSets"])
                    this.liftSets!.push(LiftSetEntry.fromJS(item));
            }
            if (Array.isArray(_data["distanceTimeSets"])) {
                this.distanceTimeSets = [] as any;
                for (let item of _data["distanceTimeSets"])
                    this.distanceTimeSets!.push(DTSetEntry.fromJS(item));
            }
            this.notes = _data["notes"];
            this.isCompleted = _data["isCompleted"];
            this.ordering = _data["ordering"];
        }
    }

    static fromJS(data: any): Movement {
        data = typeof data === 'object' ? data : {};
        let result = new Movement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementID"] = this.movementID;
        data["trainingSessionID"] = this.trainingSessionID;
        data["trainingSession"] = this.trainingSession ? this.trainingSession.toJSON() : <any>undefined;
        data["movementBaseID"] = this.movementBaseID;
        data["movementBase"] = this.movementBase ? this.movementBase.toJSON() : <any>undefined;
        data["movementModifier"] = this.movementModifier ? this.movementModifier.toJSON() : <any>undefined;
        if (Array.isArray(this.liftSets)) {
            data["liftSets"] = [];
            for (let item of this.liftSets)
                data["liftSets"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.distanceTimeSets)) {
            data["distanceTimeSets"] = [];
            for (let item of this.distanceTimeSets)
                data["distanceTimeSets"].push(item ? item.toJSON() : <any>undefined);
        }
        data["notes"] = this.notes;
        data["isCompleted"] = this.isCompleted;
        data["ordering"] = this.ordering;
        return data;
    }
}

export interface IMovement {
    movementID: string;
    trainingSessionID: string;
    trainingSession?: TrainingSession;
    movementBaseID: string;
    movementBase: MovementBase;
    movementModifier: MovementModifier;
    liftSets: LiftSetEntry[] | undefined;
    distanceTimeSets: DTSetEntry[] | undefined;
    notes: string | undefined;
    isCompleted: boolean;
    ordering: number;
}

export class MovementBase implements IMovementBase {
    movementBaseID!: string;
    name!: string | undefined;
    userID!: string;
    description!: string | undefined;
    muscleGroups!: MuscleGroup[] | undefined;

    constructor(data?: IMovementBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementBaseID = _data["movementBaseID"];
            this.name = _data["name"];
            this.userID = _data["userID"];
            this.description = _data["description"];
            if (Array.isArray(_data["muscleGroups"])) {
                this.muscleGroups = [] as any;
                for (let item of _data["muscleGroups"])
                    this.muscleGroups!.push(item);
            }
        }
    }

    static fromJS(data: any): MovementBase {
        data = typeof data === 'object' ? data : {};
        let result = new MovementBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementBaseID"] = this.movementBaseID;
        data["name"] = this.name;
        data["userID"] = this.userID;
        data["description"] = this.description;
        if (Array.isArray(this.muscleGroups)) {
            data["muscleGroups"] = [];
            for (let item of this.muscleGroups)
                data["muscleGroups"].push(item);
        }
        return data;
    }
}

export interface IMovementBase {
    movementBaseID: string;
    name: string | undefined;
    userID: string;
    description: string | undefined;
    muscleGroups: MuscleGroup[] | undefined;
}

export class MovementDTO implements IMovementDTO {
    movementID?: string;
    trainingSessionID?: string;
    movementBaseID?: string;
    movementBase?: MovementBase;
    movementModifier?: MovementModifier;
    sets?: ISetEntryDTO[] | undefined;
    notes?: string | undefined;
    isCompleted?: boolean;
    ordering?: number;

    constructor(data?: IMovementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementID = _data["movementID"];
            this.trainingSessionID = _data["trainingSessionID"];
            this.movementBaseID = _data["movementBaseID"];
            this.movementBase = _data["movementBase"] ? MovementBase.fromJS(_data["movementBase"]) : <any>undefined;
            this.movementModifier = _data["movementModifier"] ? MovementModifier.fromJS(_data["movementModifier"]) : <any>undefined;
            if (Array.isArray(_data["sets"])) {
                this.sets = [] as any;
                for (let item of _data["sets"])
                    this.sets!.push(ISetEntryDTO.fromJS(item));
            }
            this.notes = _data["notes"];
            this.isCompleted = _data["isCompleted"];
            this.ordering = _data["ordering"];
        }
    }

    static fromJS(data: any): MovementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MovementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementID"] = this.movementID;
        data["trainingSessionID"] = this.trainingSessionID;
        data["movementBaseID"] = this.movementBaseID;
        data["movementBase"] = this.movementBase ? this.movementBase.toJSON() : <any>undefined;
        data["movementModifier"] = this.movementModifier ? this.movementModifier.toJSON() : <any>undefined;
        if (Array.isArray(this.sets)) {
            data["sets"] = [];
            for (let item of this.sets)
                data["sets"].push(item ? item.toJSON() : <any>undefined);
        }
        data["notes"] = this.notes;
        data["isCompleted"] = this.isCompleted;
        data["ordering"] = this.ordering;
        return data;
    }
}

export interface IMovementDTO {
    movementID?: string;
    trainingSessionID?: string;
    movementBaseID?: string;
    movementBase?: MovementBase;
    movementModifier?: MovementModifier;
    sets?: ISetEntryDTO[] | undefined;
    notes?: string | undefined;
    isCompleted?: boolean;
    ordering?: number;
}

export class MovementModifier implements IMovementModifier {
    name!: string;
    equipmentID!: string;
    equipment!: Equipment;

    constructor(data?: IMovementModifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.equipment = new Equipment();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.equipmentID = _data["equipmentID"];
            this.equipment = _data["equipment"] ? Equipment.fromJS(_data["equipment"]) : new Equipment();
        }
    }

    static fromJS(data: any): MovementModifier {
        data = typeof data === 'object' ? data : {};
        let result = new MovementModifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["equipmentID"] = this.equipmentID;
        data["equipment"] = this.equipment ? this.equipment.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMovementModifier {
    name: string;
    equipmentID: string;
    equipment: Equipment;
}

export enum MuscleGroup {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
}

export class MuscleSetsDto implements IMuscleSetsDto {
    quadSets?: number;
    hamstringSets?: number;
    bicepSets?: number;
    tricepSets?: number;
    shoulderSets?: number;
    chestSets?: number;
    backSets?: number;

    constructor(data?: IMuscleSetsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quadSets = _data["quadSets"];
            this.hamstringSets = _data["hamstringSets"];
            this.bicepSets = _data["bicepSets"];
            this.tricepSets = _data["tricepSets"];
            this.shoulderSets = _data["shoulderSets"];
            this.chestSets = _data["chestSets"];
            this.backSets = _data["backSets"];
        }
    }

    static fromJS(data: any): MuscleSetsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MuscleSetsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quadSets"] = this.quadSets;
        data["hamstringSets"] = this.hamstringSets;
        data["bicepSets"] = this.bicepSets;
        data["tricepSets"] = this.tricepSets;
        data["shoulderSets"] = this.shoulderSets;
        data["chestSets"] = this.chestSets;
        data["backSets"] = this.backSets;
        return data;
    }
}

export interface IMuscleSetsDto {
    quadSets?: number;
    hamstringSets?: number;
    bicepSets?: number;
    tricepSets?: number;
    shoulderSets?: number;
    chestSets?: number;
    backSets?: number;
}

export class NightlyBreakdownDTO implements INightlyBreakdownDTO {
    nightlyBreakdownID?: string;
    userID?: string;
    reportDate?: Date;
    generatedAt?: Date;
    daySummary?: DaySummaryDTO;
    trainingDayReview?: TrainingDayReviewDTO;
    activityDaySummary?: ActivityDaySummaryDTO;
    wellnessReview?: WellnessReviewDTO;
    recoveryRecommendations?: RecoveryRecommendationsDTO;
    tomorrowOutlook?: TomorrowOutlookDTO;
    aiGeneratedReview?: string | undefined;
    aiReviewGeneratedAt?: Date | undefined;

    constructor(data?: INightlyBreakdownDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nightlyBreakdownID = _data["nightlyBreakdownID"];
            this.userID = _data["userID"];
            this.reportDate = _data["reportDate"] ? new Date(_data["reportDate"].toString()) : <any>undefined;
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.daySummary = _data["daySummary"] ? DaySummaryDTO.fromJS(_data["daySummary"]) : <any>undefined;
            this.trainingDayReview = _data["trainingDayReview"] ? TrainingDayReviewDTO.fromJS(_data["trainingDayReview"]) : <any>undefined;
            this.activityDaySummary = _data["activityDaySummary"] ? ActivityDaySummaryDTO.fromJS(_data["activityDaySummary"]) : <any>undefined;
            this.wellnessReview = _data["wellnessReview"] ? WellnessReviewDTO.fromJS(_data["wellnessReview"]) : <any>undefined;
            this.recoveryRecommendations = _data["recoveryRecommendations"] ? RecoveryRecommendationsDTO.fromJS(_data["recoveryRecommendations"]) : <any>undefined;
            this.tomorrowOutlook = _data["tomorrowOutlook"] ? TomorrowOutlookDTO.fromJS(_data["tomorrowOutlook"]) : <any>undefined;
            this.aiGeneratedReview = _data["aiGeneratedReview"];
            this.aiReviewGeneratedAt = _data["aiReviewGeneratedAt"] ? new Date(_data["aiReviewGeneratedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NightlyBreakdownDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NightlyBreakdownDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nightlyBreakdownID"] = this.nightlyBreakdownID;
        data["userID"] = this.userID;
        data["reportDate"] = this.reportDate ? formatDate(this.reportDate) : <any>undefined;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["daySummary"] = this.daySummary ? this.daySummary.toJSON() : <any>undefined;
        data["trainingDayReview"] = this.trainingDayReview ? this.trainingDayReview.toJSON() : <any>undefined;
        data["activityDaySummary"] = this.activityDaySummary ? this.activityDaySummary.toJSON() : <any>undefined;
        data["wellnessReview"] = this.wellnessReview ? this.wellnessReview.toJSON() : <any>undefined;
        data["recoveryRecommendations"] = this.recoveryRecommendations ? this.recoveryRecommendations.toJSON() : <any>undefined;
        data["tomorrowOutlook"] = this.tomorrowOutlook ? this.tomorrowOutlook.toJSON() : <any>undefined;
        data["aiGeneratedReview"] = this.aiGeneratedReview;
        data["aiReviewGeneratedAt"] = this.aiReviewGeneratedAt ? this.aiReviewGeneratedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface INightlyBreakdownDTO {
    nightlyBreakdownID?: string;
    userID?: string;
    reportDate?: Date;
    generatedAt?: Date;
    daySummary?: DaySummaryDTO;
    trainingDayReview?: TrainingDayReviewDTO;
    activityDaySummary?: ActivityDaySummaryDTO;
    wellnessReview?: WellnessReviewDTO;
    recoveryRecommendations?: RecoveryRecommendationsDTO;
    tomorrowOutlook?: TomorrowOutlookDTO;
    aiGeneratedReview?: string | undefined;
    aiReviewGeneratedAt?: Date | undefined;
}

export class NightlyBreakdownSummaryDTO implements INightlyBreakdownSummaryDTO {
    nightlyBreakdownID?: string;
    reportDate?: Date;
    generatedAt?: Date;
    overallDayRating?: DayRating;
    trainingSessionsCompleted?: number;
    trainingPerformance?: SessionPerformanceRating;
    hasAIReview?: boolean;

    constructor(data?: INightlyBreakdownSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nightlyBreakdownID = _data["nightlyBreakdownID"];
            this.reportDate = _data["reportDate"] ? new Date(_data["reportDate"].toString()) : <any>undefined;
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.overallDayRating = _data["overallDayRating"];
            this.trainingSessionsCompleted = _data["trainingSessionsCompleted"];
            this.trainingPerformance = _data["trainingPerformance"];
            this.hasAIReview = _data["hasAIReview"];
        }
    }

    static fromJS(data: any): NightlyBreakdownSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NightlyBreakdownSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nightlyBreakdownID"] = this.nightlyBreakdownID;
        data["reportDate"] = this.reportDate ? formatDate(this.reportDate) : <any>undefined;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["overallDayRating"] = this.overallDayRating;
        data["trainingSessionsCompleted"] = this.trainingSessionsCompleted;
        data["trainingPerformance"] = this.trainingPerformance;
        data["hasAIReview"] = this.hasAIReview;
        return data;
    }
}

export interface INightlyBreakdownSummaryDTO {
    nightlyBreakdownID?: string;
    reportDate?: Date;
    generatedAt?: Date;
    overallDayRating?: DayRating;
    trainingSessionsCompleted?: number;
    trainingPerformance?: SessionPerformanceRating;
    hasAIReview?: boolean;
}

export enum PRType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class ParseSessionTextRequest implements IParseSessionTextRequest {
    sessionText?: string | undefined;
    userID?: string;

    constructor(data?: IParseSessionTextRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionText = _data["sessionText"];
            this.userID = _data["userID"];
        }
    }

    static fromJS(data: any): ParseSessionTextRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ParseSessionTextRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionText"] = this.sessionText;
        data["userID"] = this.userID;
        return data;
    }
}

export interface IParseSessionTextRequest {
    sessionText?: string | undefined;
    userID?: string;
}

export class ParseSessionTextResponse implements IParseSessionTextResponse {
    success?: boolean;
    errorMessage?: string | undefined;
    parsedSession?: ParsedSessionData;

    constructor(data?: IParseSessionTextResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
            this.parsedSession = _data["parsedSession"] ? ParsedSessionData.fromJS(_data["parsedSession"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ParseSessionTextResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParseSessionTextResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        data["parsedSession"] = this.parsedSession ? this.parsedSession.toJSON() : <any>undefined;
        return data;
    }
}

export interface IParseSessionTextResponse {
    success?: boolean;
    errorMessage?: string | undefined;
    parsedSession?: ParsedSessionData;
}

export class ParsedDTSet implements IParsedDTSet {
    recommendedDistance?: number | undefined;
    actualDistance?: number | undefined;
    intervalDuration?: string | undefined;
    targetPace?: string | undefined;
    actualPace?: string | undefined;
    recommendedDuration?: string | undefined;
    actualDuration?: string | undefined;
    recommendedRest?: string | undefined;
    actualRest?: string | undefined;
    intervalType?: string | undefined;
    distanceUnit?: string | undefined;
    actualRPE?: number | undefined;

    constructor(data?: IParsedDTSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recommendedDistance = _data["recommendedDistance"];
            this.actualDistance = _data["actualDistance"];
            this.intervalDuration = _data["intervalDuration"];
            this.targetPace = _data["targetPace"];
            this.actualPace = _data["actualPace"];
            this.recommendedDuration = _data["recommendedDuration"];
            this.actualDuration = _data["actualDuration"];
            this.recommendedRest = _data["recommendedRest"];
            this.actualRest = _data["actualRest"];
            this.intervalType = _data["intervalType"];
            this.distanceUnit = _data["distanceUnit"];
            this.actualRPE = _data["actualRPE"];
        }
    }

    static fromJS(data: any): ParsedDTSet {
        data = typeof data === 'object' ? data : {};
        let result = new ParsedDTSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recommendedDistance"] = this.recommendedDistance;
        data["actualDistance"] = this.actualDistance;
        data["intervalDuration"] = this.intervalDuration;
        data["targetPace"] = this.targetPace;
        data["actualPace"] = this.actualPace;
        data["recommendedDuration"] = this.recommendedDuration;
        data["actualDuration"] = this.actualDuration;
        data["recommendedRest"] = this.recommendedRest;
        data["actualRest"] = this.actualRest;
        data["intervalType"] = this.intervalType;
        data["distanceUnit"] = this.distanceUnit;
        data["actualRPE"] = this.actualRPE;
        return data;
    }
}

export interface IParsedDTSet {
    recommendedDistance?: number | undefined;
    actualDistance?: number | undefined;
    intervalDuration?: string | undefined;
    targetPace?: string | undefined;
    actualPace?: string | undefined;
    recommendedDuration?: string | undefined;
    actualDuration?: string | undefined;
    recommendedRest?: string | undefined;
    actualRest?: string | undefined;
    intervalType?: string | undefined;
    distanceUnit?: string | undefined;
    actualRPE?: number | undefined;
}

export class ParsedLiftSet implements IParsedLiftSet {
    recommendedReps?: number | undefined;
    recommendedWeight?: number | undefined;
    recommendedRPE?: number | undefined;
    actualReps?: number | undefined;
    actualWeight?: number | undefined;
    actualRPE?: number | undefined;
    weightUnit?: string | undefined;

    constructor(data?: IParsedLiftSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recommendedReps = _data["recommendedReps"];
            this.recommendedWeight = _data["recommendedWeight"];
            this.recommendedRPE = _data["recommendedRPE"];
            this.actualReps = _data["actualReps"];
            this.actualWeight = _data["actualWeight"];
            this.actualRPE = _data["actualRPE"];
            this.weightUnit = _data["weightUnit"];
        }
    }

    static fromJS(data: any): ParsedLiftSet {
        data = typeof data === 'object' ? data : {};
        let result = new ParsedLiftSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recommendedReps"] = this.recommendedReps;
        data["recommendedWeight"] = this.recommendedWeight;
        data["recommendedRPE"] = this.recommendedRPE;
        data["actualReps"] = this.actualReps;
        data["actualWeight"] = this.actualWeight;
        data["actualRPE"] = this.actualRPE;
        data["weightUnit"] = this.weightUnit;
        return data;
    }
}

export interface IParsedLiftSet {
    recommendedReps?: number | undefined;
    recommendedWeight?: number | undefined;
    recommendedRPE?: number | undefined;
    actualReps?: number | undefined;
    actualWeight?: number | undefined;
    actualRPE?: number | undefined;
    weightUnit?: string | undefined;
}

export class ParsedMovement implements IParsedMovement {
    exerciseName?: string | undefined;
    equipment?: string | undefined;
    modifier?: string | undefined;
    notes?: string | undefined;
    liftSets?: ParsedLiftSet[] | undefined;
    distanceTimeSets?: ParsedDTSet[] | undefined;

    constructor(data?: IParsedMovement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseName = _data["exerciseName"];
            this.equipment = _data["equipment"];
            this.modifier = _data["modifier"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["liftSets"])) {
                this.liftSets = [] as any;
                for (let item of _data["liftSets"])
                    this.liftSets!.push(ParsedLiftSet.fromJS(item));
            }
            if (Array.isArray(_data["distanceTimeSets"])) {
                this.distanceTimeSets = [] as any;
                for (let item of _data["distanceTimeSets"])
                    this.distanceTimeSets!.push(ParsedDTSet.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParsedMovement {
        data = typeof data === 'object' ? data : {};
        let result = new ParsedMovement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseName"] = this.exerciseName;
        data["equipment"] = this.equipment;
        data["modifier"] = this.modifier;
        data["notes"] = this.notes;
        if (Array.isArray(this.liftSets)) {
            data["liftSets"] = [];
            for (let item of this.liftSets)
                data["liftSets"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.distanceTimeSets)) {
            data["distanceTimeSets"] = [];
            for (let item of this.distanceTimeSets)
                data["distanceTimeSets"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IParsedMovement {
    exerciseName?: string | undefined;
    equipment?: string | undefined;
    modifier?: string | undefined;
    notes?: string | undefined;
    liftSets?: ParsedLiftSet[] | undefined;
    distanceTimeSets?: ParsedDTSet[] | undefined;
}

export class ParsedSessionData implements IParsedSessionData {
    sessionTitle?: string | undefined;
    suggestedDate?: Date | undefined;
    notes?: string | undefined;
    movements?: ParsedMovement[] | undefined;

    constructor(data?: IParsedSessionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionTitle = _data["sessionTitle"];
            this.suggestedDate = _data["suggestedDate"] ? new Date(_data["suggestedDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            if (Array.isArray(_data["movements"])) {
                this.movements = [] as any;
                for (let item of _data["movements"])
                    this.movements!.push(ParsedMovement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParsedSessionData {
        data = typeof data === 'object' ? data : {};
        let result = new ParsedSessionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionTitle"] = this.sessionTitle;
        data["suggestedDate"] = this.suggestedDate ? formatDate(this.suggestedDate) : <any>undefined;
        data["notes"] = this.notes;
        if (Array.isArray(this.movements)) {
            data["movements"] = [];
            for (let item of this.movements)
                data["movements"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IParsedSessionData {
    sessionTitle?: string | undefined;
    suggestedDate?: Date | undefined;
    notes?: string | undefined;
    movements?: ParsedMovement[] | undefined;
}

export enum PerformanceStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class PersonalRecordDTO implements IPersonalRecordDTO {
    personalRecordID?: string;
    setEntryID?: string;
    movementName?: string | undefined;
    recordType?: PRType;
    weightPR?: number | undefined;
    volumePR?: number | undefined;
    distancePR?: number | undefined;
    bestPace?: string | undefined;
    longestDuration?: string | undefined;
    improvementPercentage?: number;
    achievedAt?: Date;
    previousRecordValue?: string | undefined;
    newRecordValue?: string | undefined;

    constructor(data?: IPersonalRecordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.personalRecordID = _data["personalRecordID"];
            this.setEntryID = _data["setEntryID"];
            this.movementName = _data["movementName"];
            this.recordType = _data["recordType"];
            this.weightPR = _data["weightPR"];
            this.volumePR = _data["volumePR"];
            this.distancePR = _data["distancePR"];
            this.bestPace = _data["bestPace"];
            this.longestDuration = _data["longestDuration"];
            this.improvementPercentage = _data["improvementPercentage"];
            this.achievedAt = _data["achievedAt"] ? new Date(_data["achievedAt"].toString()) : <any>undefined;
            this.previousRecordValue = _data["previousRecordValue"];
            this.newRecordValue = _data["newRecordValue"];
        }
    }

    static fromJS(data: any): PersonalRecordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalRecordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personalRecordID"] = this.personalRecordID;
        data["setEntryID"] = this.setEntryID;
        data["movementName"] = this.movementName;
        data["recordType"] = this.recordType;
        data["weightPR"] = this.weightPR;
        data["volumePR"] = this.volumePR;
        data["distancePR"] = this.distancePR;
        data["bestPace"] = this.bestPace;
        data["longestDuration"] = this.longestDuration;
        data["improvementPercentage"] = this.improvementPercentage;
        data["achievedAt"] = this.achievedAt ? this.achievedAt.toISOString() : <any>undefined;
        data["previousRecordValue"] = this.previousRecordValue;
        data["newRecordValue"] = this.newRecordValue;
        return data;
    }
}

export interface IPersonalRecordDTO {
    personalRecordID?: string;
    setEntryID?: string;
    movementName?: string | undefined;
    recordType?: PRType;
    weightPR?: number | undefined;
    volumePR?: number | undefined;
    distancePR?: number | undefined;
    bestPace?: string | undefined;
    longestDuration?: string | undefined;
    improvementPercentage?: number;
    achievedAt?: Date;
    previousRecordValue?: string | undefined;
    newRecordValue?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class ReadinessAssessmentDTO implements IReadinessAssessmentDTO {
    overallReadiness?: ReadinessLevel;
    ouraReadinessScore?: number | undefined;
    wellnessScore?: number | undefined;
    recoveryStatus?: RecoveryStatus;
    hrv?: number | undefined;
    restingHeartRate?: number | undefined;
    temperatureDeviation?: number | undefined;
    sleepRecovery?: number | undefined;
    daytimeRecovery?: number | undefined;
    readinessSummary?: string | undefined;
    keyReadinessFactors?: string[] | undefined;

    constructor(data?: IReadinessAssessmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.overallReadiness = _data["overallReadiness"];
            this.ouraReadinessScore = _data["ouraReadinessScore"];
            this.wellnessScore = _data["wellnessScore"];
            this.recoveryStatus = _data["recoveryStatus"];
            this.hrv = _data["hrv"];
            this.restingHeartRate = _data["restingHeartRate"];
            this.temperatureDeviation = _data["temperatureDeviation"];
            this.sleepRecovery = _data["sleepRecovery"];
            this.daytimeRecovery = _data["daytimeRecovery"];
            this.readinessSummary = _data["readinessSummary"];
            if (Array.isArray(_data["keyReadinessFactors"])) {
                this.keyReadinessFactors = [] as any;
                for (let item of _data["keyReadinessFactors"])
                    this.keyReadinessFactors!.push(item);
            }
        }
    }

    static fromJS(data: any): ReadinessAssessmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReadinessAssessmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["overallReadiness"] = this.overallReadiness;
        data["ouraReadinessScore"] = this.ouraReadinessScore;
        data["wellnessScore"] = this.wellnessScore;
        data["recoveryStatus"] = this.recoveryStatus;
        data["hrv"] = this.hrv;
        data["restingHeartRate"] = this.restingHeartRate;
        data["temperatureDeviation"] = this.temperatureDeviation;
        data["sleepRecovery"] = this.sleepRecovery;
        data["daytimeRecovery"] = this.daytimeRecovery;
        data["readinessSummary"] = this.readinessSummary;
        if (Array.isArray(this.keyReadinessFactors)) {
            data["keyReadinessFactors"] = [];
            for (let item of this.keyReadinessFactors)
                data["keyReadinessFactors"].push(item);
        }
        return data;
    }
}

export interface IReadinessAssessmentDTO {
    overallReadiness?: ReadinessLevel;
    ouraReadinessScore?: number | undefined;
    wellnessScore?: number | undefined;
    recoveryStatus?: RecoveryStatus;
    hrv?: number | undefined;
    restingHeartRate?: number | undefined;
    temperatureDeviation?: number | undefined;
    sleepRecovery?: number | undefined;
    daytimeRecovery?: number | undefined;
    readinessSummary?: string | undefined;
    keyReadinessFactors?: string[] | undefined;
}

export class ReadinessData implements IReadinessData {
    readinessScore?: number;
    temperatureDeviation?: number;
    activityBalance?: number;
    bodyTemperature?: number;
    hrvBalance?: number;
    previousDayActivity?: number;
    previousNight?: number;
    recoveryIndex?: number;
    restingHeartRate?: number;
    sleepBalance?: number;

    constructor(data?: IReadinessData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.readinessScore = _data["readinessScore"];
            this.temperatureDeviation = _data["temperatureDeviation"];
            this.activityBalance = _data["activityBalance"];
            this.bodyTemperature = _data["bodyTemperature"];
            this.hrvBalance = _data["hrvBalance"];
            this.previousDayActivity = _data["previousDayActivity"];
            this.previousNight = _data["previousNight"];
            this.recoveryIndex = _data["recoveryIndex"];
            this.restingHeartRate = _data["restingHeartRate"];
            this.sleepBalance = _data["sleepBalance"];
        }
    }

    static fromJS(data: any): ReadinessData {
        data = typeof data === 'object' ? data : {};
        let result = new ReadinessData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["readinessScore"] = this.readinessScore;
        data["temperatureDeviation"] = this.temperatureDeviation;
        data["activityBalance"] = this.activityBalance;
        data["bodyTemperature"] = this.bodyTemperature;
        data["hrvBalance"] = this.hrvBalance;
        data["previousDayActivity"] = this.previousDayActivity;
        data["previousNight"] = this.previousNight;
        data["recoveryIndex"] = this.recoveryIndex;
        data["restingHeartRate"] = this.restingHeartRate;
        data["sleepBalance"] = this.sleepBalance;
        return data;
    }
}

export interface IReadinessData {
    readinessScore?: number;
    temperatureDeviation?: number;
    activityBalance?: number;
    bodyTemperature?: number;
    hrvBalance?: number;
    previousDayActivity?: number;
    previousNight?: number;
    recoveryIndex?: number;
    restingHeartRate?: number;
    sleepBalance?: number;
}

export enum ReadinessLevel {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class RecoveryRecommendationsDTO implements IRecoveryRecommendationsDTO {
    sleepRecommendation?: SleepRecommendation;
    recommendedSleepHours?: number;
    recommendedBedtime?: string | undefined;
    recoveryActions?: string[] | undefined;
    thingsToAvoid?: string[] | undefined;
    recoverySummary?: string | undefined;

    constructor(data?: IRecoveryRecommendationsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sleepRecommendation = _data["sleepRecommendation"];
            this.recommendedSleepHours = _data["recommendedSleepHours"];
            this.recommendedBedtime = _data["recommendedBedtime"];
            if (Array.isArray(_data["recoveryActions"])) {
                this.recoveryActions = [] as any;
                for (let item of _data["recoveryActions"])
                    this.recoveryActions!.push(item);
            }
            if (Array.isArray(_data["thingsToAvoid"])) {
                this.thingsToAvoid = [] as any;
                for (let item of _data["thingsToAvoid"])
                    this.thingsToAvoid!.push(item);
            }
            this.recoverySummary = _data["recoverySummary"];
        }
    }

    static fromJS(data: any): RecoveryRecommendationsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RecoveryRecommendationsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sleepRecommendation"] = this.sleepRecommendation;
        data["recommendedSleepHours"] = this.recommendedSleepHours;
        data["recommendedBedtime"] = this.recommendedBedtime;
        if (Array.isArray(this.recoveryActions)) {
            data["recoveryActions"] = [];
            for (let item of this.recoveryActions)
                data["recoveryActions"].push(item);
        }
        if (Array.isArray(this.thingsToAvoid)) {
            data["thingsToAvoid"] = [];
            for (let item of this.thingsToAvoid)
                data["thingsToAvoid"].push(item);
        }
        data["recoverySummary"] = this.recoverySummary;
        return data;
    }
}

export interface IRecoveryRecommendationsDTO {
    sleepRecommendation?: SleepRecommendation;
    recommendedSleepHours?: number;
    recommendedBedtime?: string | undefined;
    recoveryActions?: string[] | undefined;
    thingsToAvoid?: string[] | undefined;
    recoverySummary?: string | undefined;
}

export enum RecoveryStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class RefreshRequest implements IRefreshRequest {
    refreshToken!: string | undefined;

    constructor(data?: IRefreshRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshRequest {
    refreshToken: string | undefined;
}

export class RegisterRequest implements IRegisterRequest {
    email!: string | undefined;
    password!: string | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterRequest {
    email: string | undefined;
    password: string | undefined;
}

export class ResendConfirmationEmailRequest implements IResendConfirmationEmailRequest {
    email!: string | undefined;

    constructor(data?: IResendConfirmationEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResendConfirmationEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResendConfirmationEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IResendConfirmationEmailRequest {
    email: string | undefined;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    email!: string | undefined;
    resetCode!: string | undefined;
    newPassword!: string | undefined;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.resetCode = _data["resetCode"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["resetCode"] = this.resetCode;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordRequest {
    email: string | undefined;
    resetCode: string | undefined;
    newPassword: string | undefined;
}

export class ResilienceData implements IResilienceData {
    sleepRecovery?: number;
    daytimeRecovery?: number;
    stress?: number;
    resilienceLevel?: string | undefined;

    constructor(data?: IResilienceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sleepRecovery = _data["sleepRecovery"];
            this.daytimeRecovery = _data["daytimeRecovery"];
            this.stress = _data["stress"];
            this.resilienceLevel = _data["resilienceLevel"];
        }
    }

    static fromJS(data: any): ResilienceData {
        data = typeof data === 'object' ? data : {};
        let result = new ResilienceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sleepRecovery"] = this.sleepRecovery;
        data["daytimeRecovery"] = this.daytimeRecovery;
        data["stress"] = this.stress;
        data["resilienceLevel"] = this.resilienceLevel;
        return data;
    }
}

export interface IResilienceData {
    sleepRecovery?: number;
    daytimeRecovery?: number;
    stress?: number;
    resilienceLevel?: string | undefined;
}

export class RideDetails implements IRideDetails {
    activityID?: string;
    distance?: number;
    elevationGain?: number;
    averagePower?: number;
    averageSpeed?: number;
    rideType?: string | undefined;

    constructor(data?: IRideDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityID = _data["activityID"];
            this.distance = _data["distance"];
            this.elevationGain = _data["elevationGain"];
            this.averagePower = _data["averagePower"];
            this.averageSpeed = _data["averageSpeed"];
            this.rideType = _data["rideType"];
        }
    }

    static fromJS(data: any): RideDetails {
        data = typeof data === 'object' ? data : {};
        let result = new RideDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityID"] = this.activityID;
        data["distance"] = this.distance;
        data["elevationGain"] = this.elevationGain;
        data["averagePower"] = this.averagePower;
        data["averageSpeed"] = this.averageSpeed;
        data["rideType"] = this.rideType;
        return data;
    }
}

export interface IRideDetails {
    activityID?: string;
    distance?: number;
    elevationGain?: number;
    averagePower?: number;
    averageSpeed?: number;
    rideType?: string | undefined;
}

export class RunWalkDetails implements IRunWalkDetails {
    activityID?: string;
    distance?: number;
    elevationGain?: number;
    averagePaceInSeconds?: number;
    mileSplitsInSeconds?: number[] | undefined;
    runType?: string | undefined;

    constructor(data?: IRunWalkDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityID = _data["activityID"];
            this.distance = _data["distance"];
            this.elevationGain = _data["elevationGain"];
            this.averagePaceInSeconds = _data["averagePaceInSeconds"];
            if (Array.isArray(_data["mileSplitsInSeconds"])) {
                this.mileSplitsInSeconds = [] as any;
                for (let item of _data["mileSplitsInSeconds"])
                    this.mileSplitsInSeconds!.push(item);
            }
            this.runType = _data["runType"];
        }
    }

    static fromJS(data: any): RunWalkDetails {
        data = typeof data === 'object' ? data : {};
        let result = new RunWalkDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityID"] = this.activityID;
        data["distance"] = this.distance;
        data["elevationGain"] = this.elevationGain;
        data["averagePaceInSeconds"] = this.averagePaceInSeconds;
        if (Array.isArray(this.mileSplitsInSeconds)) {
            data["mileSplitsInSeconds"] = [];
            for (let item of this.mileSplitsInSeconds)
                data["mileSplitsInSeconds"].push(item);
        }
        data["runType"] = this.runType;
        return data;
    }
}

export interface IRunWalkDetails {
    activityID?: string;
    distance?: number;
    elevationGain?: number;
    averagePaceInSeconds?: number;
    mileSplitsInSeconds?: number[] | undefined;
    runType?: string | undefined;
}

export class SessionMetricsDTO implements ISessionMetricsDTO {
    totalMovements?: number;
    totalSets?: number;
    completedMovements?: number;
    completedSets?: number;
    totalVolumeLifted?: number | undefined;
    totalDistanceCovered?: number | undefined;
    totalTimeUnderTension?: string | undefined;
    sessionCompletionPercentage?: number;
    averageIntensity?: number;
    estimatedDuration?: string | undefined;
    overallRating?: SessionPerformanceRating;

    constructor(data?: ISessionMetricsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalMovements = _data["totalMovements"];
            this.totalSets = _data["totalSets"];
            this.completedMovements = _data["completedMovements"];
            this.completedSets = _data["completedSets"];
            this.totalVolumeLifted = _data["totalVolumeLifted"];
            this.totalDistanceCovered = _data["totalDistanceCovered"];
            this.totalTimeUnderTension = _data["totalTimeUnderTension"];
            this.sessionCompletionPercentage = _data["sessionCompletionPercentage"];
            this.averageIntensity = _data["averageIntensity"];
            this.estimatedDuration = _data["estimatedDuration"];
            this.overallRating = _data["overallRating"];
        }
    }

    static fromJS(data: any): SessionMetricsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SessionMetricsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalMovements"] = this.totalMovements;
        data["totalSets"] = this.totalSets;
        data["completedMovements"] = this.completedMovements;
        data["completedSets"] = this.completedSets;
        data["totalVolumeLifted"] = this.totalVolumeLifted;
        data["totalDistanceCovered"] = this.totalDistanceCovered;
        data["totalTimeUnderTension"] = this.totalTimeUnderTension;
        data["sessionCompletionPercentage"] = this.sessionCompletionPercentage;
        data["averageIntensity"] = this.averageIntensity;
        data["estimatedDuration"] = this.estimatedDuration;
        data["overallRating"] = this.overallRating;
        return data;
    }
}

export interface ISessionMetricsDTO {
    totalMovements?: number;
    totalSets?: number;
    completedMovements?: number;
    completedSets?: number;
    totalVolumeLifted?: number | undefined;
    totalDistanceCovered?: number | undefined;
    totalTimeUnderTension?: string | undefined;
    sessionCompletionPercentage?: number;
    averageIntensity?: number;
    estimatedDuration?: string | undefined;
    overallRating?: SessionPerformanceRating;
}

export enum SessionPerformanceRating {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class SessionReportDTO implements ISessionReportDTO {
    sessionReportID?: string;
    trainingSessionID?: string;
    userID?: string;
    generatedAt?: Date;
    sessionDate?: Date;
    setEntryInsights?: SetEntryInsightDTO[] | undefined;
    personalRecords?: PersonalRecordDTO[] | undefined;
    externalFactorsSummary?: ExternalFactorsSummaryDTO;
    sessionMetrics?: SessionMetricsDTO;
    aiGeneratedReview?: string | undefined;
    aiReviewGeneratedAt?: Date | undefined;

    constructor(data?: ISessionReportDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionReportID = _data["sessionReportID"];
            this.trainingSessionID = _data["trainingSessionID"];
            this.userID = _data["userID"];
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.sessionDate = _data["sessionDate"] ? new Date(_data["sessionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["setEntryInsights"])) {
                this.setEntryInsights = [] as any;
                for (let item of _data["setEntryInsights"])
                    this.setEntryInsights!.push(SetEntryInsightDTO.fromJS(item));
            }
            if (Array.isArray(_data["personalRecords"])) {
                this.personalRecords = [] as any;
                for (let item of _data["personalRecords"])
                    this.personalRecords!.push(PersonalRecordDTO.fromJS(item));
            }
            this.externalFactorsSummary = _data["externalFactorsSummary"] ? ExternalFactorsSummaryDTO.fromJS(_data["externalFactorsSummary"]) : <any>undefined;
            this.sessionMetrics = _data["sessionMetrics"] ? SessionMetricsDTO.fromJS(_data["sessionMetrics"]) : <any>undefined;
            this.aiGeneratedReview = _data["aiGeneratedReview"];
            this.aiReviewGeneratedAt = _data["aiReviewGeneratedAt"] ? new Date(_data["aiReviewGeneratedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SessionReportDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SessionReportDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionReportID"] = this.sessionReportID;
        data["trainingSessionID"] = this.trainingSessionID;
        data["userID"] = this.userID;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["sessionDate"] = this.sessionDate ? formatDate(this.sessionDate) : <any>undefined;
        if (Array.isArray(this.setEntryInsights)) {
            data["setEntryInsights"] = [];
            for (let item of this.setEntryInsights)
                data["setEntryInsights"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.personalRecords)) {
            data["personalRecords"] = [];
            for (let item of this.personalRecords)
                data["personalRecords"].push(item ? item.toJSON() : <any>undefined);
        }
        data["externalFactorsSummary"] = this.externalFactorsSummary ? this.externalFactorsSummary.toJSON() : <any>undefined;
        data["sessionMetrics"] = this.sessionMetrics ? this.sessionMetrics.toJSON() : <any>undefined;
        data["aiGeneratedReview"] = this.aiGeneratedReview;
        data["aiReviewGeneratedAt"] = this.aiReviewGeneratedAt ? this.aiReviewGeneratedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISessionReportDTO {
    sessionReportID?: string;
    trainingSessionID?: string;
    userID?: string;
    generatedAt?: Date;
    sessionDate?: Date;
    setEntryInsights?: SetEntryInsightDTO[] | undefined;
    personalRecords?: PersonalRecordDTO[] | undefined;
    externalFactorsSummary?: ExternalFactorsSummaryDTO;
    sessionMetrics?: SessionMetricsDTO;
    aiGeneratedReview?: string | undefined;
    aiReviewGeneratedAt?: Date | undefined;
}

export class SessionReportSummaryDTO implements ISessionReportSummaryDTO {
    sessionReportID?: string;
    trainingSessionID?: string;
    sessionDate?: Date;
    generatedAt?: Date;
    totalPRsAchieved?: number;
    overallRating?: SessionPerformanceRating;
    recoveryStatus?: RecoveryStatus;
    hasAIReview?: boolean;

    constructor(data?: ISessionReportSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionReportID = _data["sessionReportID"];
            this.trainingSessionID = _data["trainingSessionID"];
            this.sessionDate = _data["sessionDate"] ? new Date(_data["sessionDate"].toString()) : <any>undefined;
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.totalPRsAchieved = _data["totalPRsAchieved"];
            this.overallRating = _data["overallRating"];
            this.recoveryStatus = _data["recoveryStatus"];
            this.hasAIReview = _data["hasAIReview"];
        }
    }

    static fromJS(data: any): SessionReportSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SessionReportSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionReportID"] = this.sessionReportID;
        data["trainingSessionID"] = this.trainingSessionID;
        data["sessionDate"] = this.sessionDate ? formatDate(this.sessionDate) : <any>undefined;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["totalPRsAchieved"] = this.totalPRsAchieved;
        data["overallRating"] = this.overallRating;
        data["recoveryStatus"] = this.recoveryStatus;
        data["hasAIReview"] = this.hasAIReview;
        return data;
    }
}

export interface ISessionReportSummaryDTO {
    sessionReportID?: string;
    trainingSessionID?: string;
    sessionDate?: Date;
    generatedAt?: Date;
    totalPRsAchieved?: number;
    overallRating?: SessionPerformanceRating;
    recoveryStatus?: RecoveryStatus;
    hasAIReview?: boolean;
}

export class SetEntryInsightDTO implements ISetEntryInsightDTO {
    setEntryInsightID?: string;
    setEntryID?: string;
    movementName?: string | undefined;
    setEntryType?: SetEntryType;
    weightUsed?: number | undefined;
    repsCompleted?: number | undefined;
    totalVolume?: number | undefined;
    intensityPercentage?: number | undefined;
    actualRPE?: number | undefined;
    distanceCompleted?: number | undefined;
    timeCompleted?: string | undefined;
    paceAchieved?: string | undefined;
    volumeCompleted?: number | undefined;
    performanceStatus?: PerformanceStatus;
    notes?: string | undefined;

    constructor(data?: ISetEntryInsightDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryInsightID = _data["setEntryInsightID"];
            this.setEntryID = _data["setEntryID"];
            this.movementName = _data["movementName"];
            this.setEntryType = _data["setEntryType"];
            this.weightUsed = _data["weightUsed"];
            this.repsCompleted = _data["repsCompleted"];
            this.totalVolume = _data["totalVolume"];
            this.intensityPercentage = _data["intensityPercentage"];
            this.actualRPE = _data["actualRPE"];
            this.distanceCompleted = _data["distanceCompleted"];
            this.timeCompleted = _data["timeCompleted"];
            this.paceAchieved = _data["paceAchieved"];
            this.volumeCompleted = _data["volumeCompleted"];
            this.performanceStatus = _data["performanceStatus"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): SetEntryInsightDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SetEntryInsightDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryInsightID"] = this.setEntryInsightID;
        data["setEntryID"] = this.setEntryID;
        data["movementName"] = this.movementName;
        data["setEntryType"] = this.setEntryType;
        data["weightUsed"] = this.weightUsed;
        data["repsCompleted"] = this.repsCompleted;
        data["totalVolume"] = this.totalVolume;
        data["intensityPercentage"] = this.intensityPercentage;
        data["actualRPE"] = this.actualRPE;
        data["distanceCompleted"] = this.distanceCompleted;
        data["timeCompleted"] = this.timeCompleted;
        data["paceAchieved"] = this.paceAchieved;
        data["volumeCompleted"] = this.volumeCompleted;
        data["performanceStatus"] = this.performanceStatus;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ISetEntryInsightDTO {
    setEntryInsightID?: string;
    setEntryID?: string;
    movementName?: string | undefined;
    setEntryType?: SetEntryType;
    weightUsed?: number | undefined;
    repsCompleted?: number | undefined;
    totalVolume?: number | undefined;
    intensityPercentage?: number | undefined;
    actualRPE?: number | undefined;
    distanceCompleted?: number | undefined;
    timeCompleted?: string | undefined;
    paceAchieved?: string | undefined;
    volumeCompleted?: number | undefined;
    performanceStatus?: PerformanceStatus;
    notes?: string | undefined;
}

export enum SetEntryType {
    _0 = 0,
    _1 = 1,
}

export class SleepAnalysisDTO implements ISleepAnalysisDTO {
    sleepScore?: number | undefined;
    totalSleepMinutes?: number | undefined;
    deepSleepMinutes?: number | undefined;
    remSleepMinutes?: number | undefined;
    lightSleepMinutes?: number | undefined;
    sleepEfficiency?: number | undefined;
    sleepLatency?: number | undefined;
    sleepQuality?: SleepQuality;
    sleepSummary?: string | undefined;
    sleepInsights?: string[] | undefined;

    constructor(data?: ISleepAnalysisDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sleepScore = _data["sleepScore"];
            this.totalSleepMinutes = _data["totalSleepMinutes"];
            this.deepSleepMinutes = _data["deepSleepMinutes"];
            this.remSleepMinutes = _data["remSleepMinutes"];
            this.lightSleepMinutes = _data["lightSleepMinutes"];
            this.sleepEfficiency = _data["sleepEfficiency"];
            this.sleepLatency = _data["sleepLatency"];
            this.sleepQuality = _data["sleepQuality"];
            this.sleepSummary = _data["sleepSummary"];
            if (Array.isArray(_data["sleepInsights"])) {
                this.sleepInsights = [] as any;
                for (let item of _data["sleepInsights"])
                    this.sleepInsights!.push(item);
            }
        }
    }

    static fromJS(data: any): SleepAnalysisDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SleepAnalysisDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sleepScore"] = this.sleepScore;
        data["totalSleepMinutes"] = this.totalSleepMinutes;
        data["deepSleepMinutes"] = this.deepSleepMinutes;
        data["remSleepMinutes"] = this.remSleepMinutes;
        data["lightSleepMinutes"] = this.lightSleepMinutes;
        data["sleepEfficiency"] = this.sleepEfficiency;
        data["sleepLatency"] = this.sleepLatency;
        data["sleepQuality"] = this.sleepQuality;
        data["sleepSummary"] = this.sleepSummary;
        if (Array.isArray(this.sleepInsights)) {
            data["sleepInsights"] = [];
            for (let item of this.sleepInsights)
                data["sleepInsights"].push(item);
        }
        return data;
    }
}

export interface ISleepAnalysisDTO {
    sleepScore?: number | undefined;
    totalSleepMinutes?: number | undefined;
    deepSleepMinutes?: number | undefined;
    remSleepMinutes?: number | undefined;
    lightSleepMinutes?: number | undefined;
    sleepEfficiency?: number | undefined;
    sleepLatency?: number | undefined;
    sleepQuality?: SleepQuality;
    sleepSummary?: string | undefined;
    sleepInsights?: string[] | undefined;
}

export class SleepData implements ISleepData {
    sleepScore?: number;
    deepSleep?: number;
    efficiency?: number;
    latency?: number;
    remSleep?: number;
    restfulness?: number;
    timing?: number;
    totalSleep?: number;

    constructor(data?: ISleepData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sleepScore = _data["sleepScore"];
            this.deepSleep = _data["deepSleep"];
            this.efficiency = _data["efficiency"];
            this.latency = _data["latency"];
            this.remSleep = _data["remSleep"];
            this.restfulness = _data["restfulness"];
            this.timing = _data["timing"];
            this.totalSleep = _data["totalSleep"];
        }
    }

    static fromJS(data: any): SleepData {
        data = typeof data === 'object' ? data : {};
        let result = new SleepData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sleepScore"] = this.sleepScore;
        data["deepSleep"] = this.deepSleep;
        data["efficiency"] = this.efficiency;
        data["latency"] = this.latency;
        data["remSleep"] = this.remSleep;
        data["restfulness"] = this.restfulness;
        data["timing"] = this.timing;
        data["totalSleep"] = this.totalSleep;
        return data;
    }
}

export interface ISleepData {
    sleepScore?: number;
    deepSleep?: number;
    efficiency?: number;
    latency?: number;
    remSleep?: number;
    restfulness?: number;
    timing?: number;
    totalSleep?: number;
}

export enum SleepQuality {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum SleepRecommendation {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class TomorrowOutlookDTO implements ITomorrowOutlookDTO {
    expectedRecoveryLevel?: ExpectedRecoveryLevel;
    hasScheduledTraining?: boolean;
    scheduledSessionName?: string | undefined;
    outlookSummary?: string | undefined;
    preparations?: string[] | undefined;
    considerations?: string[] | undefined;

    constructor(data?: ITomorrowOutlookDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expectedRecoveryLevel = _data["expectedRecoveryLevel"];
            this.hasScheduledTraining = _data["hasScheduledTraining"];
            this.scheduledSessionName = _data["scheduledSessionName"];
            this.outlookSummary = _data["outlookSummary"];
            if (Array.isArray(_data["preparations"])) {
                this.preparations = [] as any;
                for (let item of _data["preparations"])
                    this.preparations!.push(item);
            }
            if (Array.isArray(_data["considerations"])) {
                this.considerations = [] as any;
                for (let item of _data["considerations"])
                    this.considerations!.push(item);
            }
        }
    }

    static fromJS(data: any): TomorrowOutlookDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TomorrowOutlookDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expectedRecoveryLevel"] = this.expectedRecoveryLevel;
        data["hasScheduledTraining"] = this.hasScheduledTraining;
        data["scheduledSessionName"] = this.scheduledSessionName;
        data["outlookSummary"] = this.outlookSummary;
        if (Array.isArray(this.preparations)) {
            data["preparations"] = [];
            for (let item of this.preparations)
                data["preparations"].push(item);
        }
        if (Array.isArray(this.considerations)) {
            data["considerations"] = [];
            for (let item of this.considerations)
                data["considerations"].push(item);
        }
        return data;
    }
}

export interface ITomorrowOutlookDTO {
    expectedRecoveryLevel?: ExpectedRecoveryLevel;
    hasScheduledTraining?: boolean;
    scheduledSessionName?: string | undefined;
    outlookSummary?: string | undefined;
    preparations?: string[] | undefined;
    considerations?: string[] | undefined;
}

export class TrainingDayReviewDTO implements ITrainingDayReviewDTO {
    completedSessionIDs?: string[] | undefined;
    totalSetsCompleted?: number;
    totalVolumeLifted?: number | undefined;
    totalDistanceCovered?: number | undefined;
    averageIntensity?: number;
    overallPerformance?: SessionPerformanceRating;
    personalRecordsAchieved?: number;
    performanceSummary?: string | undefined;
    achievements?: string[] | undefined;
    challengesEncountered?: string[] | undefined;

    constructor(data?: ITrainingDayReviewDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["completedSessionIDs"])) {
                this.completedSessionIDs = [] as any;
                for (let item of _data["completedSessionIDs"])
                    this.completedSessionIDs!.push(item);
            }
            this.totalSetsCompleted = _data["totalSetsCompleted"];
            this.totalVolumeLifted = _data["totalVolumeLifted"];
            this.totalDistanceCovered = _data["totalDistanceCovered"];
            this.averageIntensity = _data["averageIntensity"];
            this.overallPerformance = _data["overallPerformance"];
            this.personalRecordsAchieved = _data["personalRecordsAchieved"];
            this.performanceSummary = _data["performanceSummary"];
            if (Array.isArray(_data["achievements"])) {
                this.achievements = [] as any;
                for (let item of _data["achievements"])
                    this.achievements!.push(item);
            }
            if (Array.isArray(_data["challengesEncountered"])) {
                this.challengesEncountered = [] as any;
                for (let item of _data["challengesEncountered"])
                    this.challengesEncountered!.push(item);
            }
        }
    }

    static fromJS(data: any): TrainingDayReviewDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingDayReviewDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.completedSessionIDs)) {
            data["completedSessionIDs"] = [];
            for (let item of this.completedSessionIDs)
                data["completedSessionIDs"].push(item);
        }
        data["totalSetsCompleted"] = this.totalSetsCompleted;
        data["totalVolumeLifted"] = this.totalVolumeLifted;
        data["totalDistanceCovered"] = this.totalDistanceCovered;
        data["averageIntensity"] = this.averageIntensity;
        data["overallPerformance"] = this.overallPerformance;
        data["personalRecordsAchieved"] = this.personalRecordsAchieved;
        data["performanceSummary"] = this.performanceSummary;
        if (Array.isArray(this.achievements)) {
            data["achievements"] = [];
            for (let item of this.achievements)
                data["achievements"].push(item);
        }
        if (Array.isArray(this.challengesEncountered)) {
            data["challengesEncountered"] = [];
            for (let item of this.challengesEncountered)
                data["challengesEncountered"].push(item);
        }
        return data;
    }
}

export interface ITrainingDayReviewDTO {
    completedSessionIDs?: string[] | undefined;
    totalSetsCompleted?: number;
    totalVolumeLifted?: number | undefined;
    totalDistanceCovered?: number | undefined;
    averageIntensity?: number;
    overallPerformance?: SessionPerformanceRating;
    personalRecordsAchieved?: number;
    performanceSummary?: string | undefined;
    achievements?: string[] | undefined;
    challengesEncountered?: string[] | undefined;
}

export class TrainingLoadAssessmentDTO implements ITrainingLoadAssessmentDTO {
    sessionsLast7Days?: number;
    sessionsLast30Days?: number;
    totalVolumeLast7Days?: number | undefined;
    totalVolumeLast30Days?: number | undefined;
    averageIntensityLast7Days?: number | undefined;
    loadLevel?: TrainingLoadLevel;
    fatigueLevel?: FatigueLevel;
    loadSummary?: string | undefined;
    loadInsights?: string[] | undefined;
    daysSinceLastRest?: number;
    restDayRecommended?: boolean;

    constructor(data?: ITrainingLoadAssessmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionsLast7Days = _data["sessionsLast7Days"];
            this.sessionsLast30Days = _data["sessionsLast30Days"];
            this.totalVolumeLast7Days = _data["totalVolumeLast7Days"];
            this.totalVolumeLast30Days = _data["totalVolumeLast30Days"];
            this.averageIntensityLast7Days = _data["averageIntensityLast7Days"];
            this.loadLevel = _data["loadLevel"];
            this.fatigueLevel = _data["fatigueLevel"];
            this.loadSummary = _data["loadSummary"];
            if (Array.isArray(_data["loadInsights"])) {
                this.loadInsights = [] as any;
                for (let item of _data["loadInsights"])
                    this.loadInsights!.push(item);
            }
            this.daysSinceLastRest = _data["daysSinceLastRest"];
            this.restDayRecommended = _data["restDayRecommended"];
        }
    }

    static fromJS(data: any): TrainingLoadAssessmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingLoadAssessmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionsLast7Days"] = this.sessionsLast7Days;
        data["sessionsLast30Days"] = this.sessionsLast30Days;
        data["totalVolumeLast7Days"] = this.totalVolumeLast7Days;
        data["totalVolumeLast30Days"] = this.totalVolumeLast30Days;
        data["averageIntensityLast7Days"] = this.averageIntensityLast7Days;
        data["loadLevel"] = this.loadLevel;
        data["fatigueLevel"] = this.fatigueLevel;
        data["loadSummary"] = this.loadSummary;
        if (Array.isArray(this.loadInsights)) {
            data["loadInsights"] = [];
            for (let item of this.loadInsights)
                data["loadInsights"].push(item);
        }
        data["daysSinceLastRest"] = this.daysSinceLastRest;
        data["restDayRecommended"] = this.restDayRecommended;
        return data;
    }
}

export interface ITrainingLoadAssessmentDTO {
    sessionsLast7Days?: number;
    sessionsLast30Days?: number;
    totalVolumeLast7Days?: number | undefined;
    totalVolumeLast30Days?: number | undefined;
    averageIntensityLast7Days?: number | undefined;
    loadLevel?: TrainingLoadLevel;
    fatigueLevel?: FatigueLevel;
    loadSummary?: string | undefined;
    loadInsights?: string[] | undefined;
    daysSinceLastRest?: number;
    restDayRecommended?: boolean;
}

export enum TrainingLoadLevel {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class TrainingProgram implements ITrainingProgram {
    trainingProgramID!: string;
    userID!: string;
    title!: string | undefined;
    startDate!: Date;
    nextTrainingSessionDate?: Date;
    endDate!: Date;
    isCompleted!: boolean;
    trainingSessions!: TrainingSession[] | undefined;
    tags!: string[] | undefined;

    constructor(data?: ITrainingProgram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingProgramID = _data["trainingProgramID"];
            this.userID = _data["userID"];
            this.title = _data["title"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.nextTrainingSessionDate = _data["nextTrainingSessionDate"] ? new Date(_data["nextTrainingSessionDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.isCompleted = _data["isCompleted"];
            if (Array.isArray(_data["trainingSessions"])) {
                this.trainingSessions = [] as any;
                for (let item of _data["trainingSessions"])
                    this.trainingSessions!.push(TrainingSession.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): TrainingProgram {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingProgram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramID"] = this.trainingProgramID;
        data["userID"] = this.userID;
        data["title"] = this.title;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["nextTrainingSessionDate"] = this.nextTrainingSessionDate ? formatDate(this.nextTrainingSessionDate) : <any>undefined;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        data["isCompleted"] = this.isCompleted;
        if (Array.isArray(this.trainingSessions)) {
            data["trainingSessions"] = [];
            for (let item of this.trainingSessions)
                data["trainingSessions"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface ITrainingProgram {
    trainingProgramID: string;
    userID: string;
    title: string | undefined;
    startDate: Date;
    nextTrainingSessionDate?: Date;
    endDate: Date;
    isCompleted: boolean;
    trainingSessions: TrainingSession[] | undefined;
    tags: string[] | undefined;
}

export class TrainingProgramDTO implements ITrainingProgramDTO {
    trainingProgramID!: string;
    title!: string;
    startDate!: Date;
    nextTrainingSessionDate!: Date;
    endDate!: Date;
    isCompleted!: boolean;
    trainingSessions!: TrainingSession[];
    tags!: string[];

    constructor(data?: ITrainingProgramDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.trainingSessions = [];
            this.tags = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingProgramID = _data["trainingProgramID"];
            this.title = _data["title"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.nextTrainingSessionDate = _data["nextTrainingSessionDate"] ? new Date(_data["nextTrainingSessionDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.isCompleted = _data["isCompleted"];
            if (Array.isArray(_data["trainingSessions"])) {
                this.trainingSessions = [] as any;
                for (let item of _data["trainingSessions"])
                    this.trainingSessions!.push(TrainingSession.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): TrainingProgramDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingProgramDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramID"] = this.trainingProgramID;
        data["title"] = this.title;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["nextTrainingSessionDate"] = this.nextTrainingSessionDate ? formatDate(this.nextTrainingSessionDate) : <any>undefined;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        data["isCompleted"] = this.isCompleted;
        if (Array.isArray(this.trainingSessions)) {
            data["trainingSessions"] = [];
            for (let item of this.trainingSessions)
                data["trainingSessions"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface ITrainingProgramDTO {
    trainingProgramID: string;
    title: string;
    startDate: Date;
    nextTrainingSessionDate: Date;
    endDate: Date;
    isCompleted: boolean;
    trainingSessions: TrainingSession[];
    tags: string[];
}

export class TrainingProgramGuidanceDTO implements ITrainingProgramGuidanceDTO {
    scheduledSessionID?: string | undefined;
    sessionName?: string | undefined;
    sessionType?: string | undefined;
    estimatedDurationMinutes?: number;
    readinessConsideration?: string | undefined;
    thingsToWatchFor?: string[] | undefined;
    movementsToBeCarefulWith?: string[] | undefined;
    suggestedModifications?: string[] | undefined;
    injuryWarnings?: string[] | undefined;

    constructor(data?: ITrainingProgramGuidanceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheduledSessionID = _data["scheduledSessionID"];
            this.sessionName = _data["sessionName"];
            this.sessionType = _data["sessionType"];
            this.estimatedDurationMinutes = _data["estimatedDurationMinutes"];
            this.readinessConsideration = _data["readinessConsideration"];
            if (Array.isArray(_data["thingsToWatchFor"])) {
                this.thingsToWatchFor = [] as any;
                for (let item of _data["thingsToWatchFor"])
                    this.thingsToWatchFor!.push(item);
            }
            if (Array.isArray(_data["movementsToBeCarefulWith"])) {
                this.movementsToBeCarefulWith = [] as any;
                for (let item of _data["movementsToBeCarefulWith"])
                    this.movementsToBeCarefulWith!.push(item);
            }
            if (Array.isArray(_data["suggestedModifications"])) {
                this.suggestedModifications = [] as any;
                for (let item of _data["suggestedModifications"])
                    this.suggestedModifications!.push(item);
            }
            if (Array.isArray(_data["injuryWarnings"])) {
                this.injuryWarnings = [] as any;
                for (let item of _data["injuryWarnings"])
                    this.injuryWarnings!.push(item);
            }
        }
    }

    static fromJS(data: any): TrainingProgramGuidanceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingProgramGuidanceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduledSessionID"] = this.scheduledSessionID;
        data["sessionName"] = this.sessionName;
        data["sessionType"] = this.sessionType;
        data["estimatedDurationMinutes"] = this.estimatedDurationMinutes;
        data["readinessConsideration"] = this.readinessConsideration;
        if (Array.isArray(this.thingsToWatchFor)) {
            data["thingsToWatchFor"] = [];
            for (let item of this.thingsToWatchFor)
                data["thingsToWatchFor"].push(item);
        }
        if (Array.isArray(this.movementsToBeCarefulWith)) {
            data["movementsToBeCarefulWith"] = [];
            for (let item of this.movementsToBeCarefulWith)
                data["movementsToBeCarefulWith"].push(item);
        }
        if (Array.isArray(this.suggestedModifications)) {
            data["suggestedModifications"] = [];
            for (let item of this.suggestedModifications)
                data["suggestedModifications"].push(item);
        }
        if (Array.isArray(this.injuryWarnings)) {
            data["injuryWarnings"] = [];
            for (let item of this.injuryWarnings)
                data["injuryWarnings"].push(item);
        }
        return data;
    }
}

export interface ITrainingProgramGuidanceDTO {
    scheduledSessionID?: string | undefined;
    sessionName?: string | undefined;
    sessionType?: string | undefined;
    estimatedDurationMinutes?: number;
    readinessConsideration?: string | undefined;
    thingsToWatchFor?: string[] | undefined;
    movementsToBeCarefulWith?: string[] | undefined;
    suggestedModifications?: string[] | undefined;
    injuryWarnings?: string[] | undefined;
}

export class TrainingSession implements ITrainingSession {
    trainingSessionID!: string;
    trainingProgramID!: string;
    trainingProgram?: TrainingProgram;
    date!: Date;
    status!: TrainingSessionStatus;
    movements!: Movement[] | undefined;
    creationTime!: Date;
    notes!: string | undefined;

    constructor(data?: ITrainingSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            this.trainingProgramID = _data["trainingProgramID"];
            this.trainingProgram = _data["trainingProgram"] ? TrainingProgram.fromJS(_data["trainingProgram"]) : <any>undefined;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            if (Array.isArray(_data["movements"])) {
                this.movements = [] as any;
                for (let item of _data["movements"])
                    this.movements!.push(Movement.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): TrainingSession {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        data["trainingProgramID"] = this.trainingProgramID;
        data["trainingProgram"] = this.trainingProgram ? this.trainingProgram.toJSON() : <any>undefined;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["status"] = this.status;
        if (Array.isArray(this.movements)) {
            data["movements"] = [];
            for (let item of this.movements)
                data["movements"].push(item ? item.toJSON() : <any>undefined);
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ITrainingSession {
    trainingSessionID: string;
    trainingProgramID: string;
    trainingProgram?: TrainingProgram;
    date: Date;
    status: TrainingSessionStatus;
    movements: Movement[] | undefined;
    creationTime: Date;
    notes: string | undefined;
}

export class TrainingSessionDTO implements ITrainingSessionDTO {
    trainingSessionID?: string;
    trainingProgramID?: string;
    date?: Date;
    status?: TrainingSessionStatus;
    movements?: MovementDTO[] | undefined;
    creationTime?: Date;
    notes?: string | undefined;

    constructor(data?: ITrainingSessionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            this.trainingProgramID = _data["trainingProgramID"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            if (Array.isArray(_data["movements"])) {
                this.movements = [] as any;
                for (let item of _data["movements"])
                    this.movements!.push(MovementDTO.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): TrainingSessionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSessionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        data["trainingProgramID"] = this.trainingProgramID;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["status"] = this.status;
        if (Array.isArray(this.movements)) {
            data["movements"] = [];
            for (let item of this.movements)
                data["movements"].push(item ? item.toJSON() : <any>undefined);
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ITrainingSessionDTO {
    trainingSessionID?: string;
    trainingProgramID?: string;
    date?: Date;
    status?: TrainingSessionStatus;
    movements?: MovementDTO[] | undefined;
    creationTime?: Date;
    notes?: string | undefined;
}

export enum TrainingSessionStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum TrendDirection {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class TwoFactorRequest implements ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;

    constructor(data?: ITwoFactorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enable = _data["enable"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.resetSharedKey = _data["resetSharedKey"];
            this.resetRecoveryCodes = _data["resetRecoveryCodes"];
            this.forgetMachine = _data["forgetMachine"];
        }
    }

    static fromJS(data: any): TwoFactorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enable"] = this.enable;
        data["twoFactorCode"] = this.twoFactorCode;
        data["resetSharedKey"] = this.resetSharedKey;
        data["resetRecoveryCodes"] = this.resetRecoveryCodes;
        data["forgetMachine"] = this.forgetMachine;
        return data;
    }
}

export interface ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;
}

export class TwoFactorResponse implements ITwoFactorResponse {
    sharedKey!: string | undefined;
    recoveryCodesLeft!: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled!: boolean;
    isMachineRemembered!: boolean;

    constructor(data?: ITwoFactorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sharedKey = _data["sharedKey"];
            this.recoveryCodesLeft = _data["recoveryCodesLeft"];
            if (Array.isArray(_data["recoveryCodes"])) {
                this.recoveryCodes = [] as any;
                for (let item of _data["recoveryCodes"])
                    this.recoveryCodes!.push(item);
            }
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isMachineRemembered = _data["isMachineRemembered"];
        }
    }

    static fromJS(data: any): TwoFactorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sharedKey"] = this.sharedKey;
        data["recoveryCodesLeft"] = this.recoveryCodesLeft;
        if (Array.isArray(this.recoveryCodes)) {
            data["recoveryCodes"] = [];
            for (let item of this.recoveryCodes)
                data["recoveryCodes"].push(item);
        }
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isMachineRemembered"] = this.isMachineRemembered;
        return data;
    }
}

export interface ITwoFactorResponse {
    sharedKey: string | undefined;
    recoveryCodesLeft: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled: boolean;
    isMachineRemembered: boolean;
}

export class UpdateDTSetEntryRequest implements IUpdateDTSetEntryRequest {
    setEntryID?: string;
    movementID?: string;
    recommendedDistance?: number;
    actualDistance?: number;
    intervalDuration?: string;
    targetPace?: string;
    actualPace?: string;
    recommendedDuration?: string;
    actualDuration?: string;
    recommendedRest?: string;
    actualRest?: string;
    intervalType?: IntervalType;
    distanceUnit?: DistanceUnit;
    actualRPE?: number;

    constructor(data?: IUpdateDTSetEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryID = _data["setEntryID"];
            this.movementID = _data["movementID"];
            this.recommendedDistance = _data["recommendedDistance"];
            this.actualDistance = _data["actualDistance"];
            this.intervalDuration = _data["intervalDuration"];
            this.targetPace = _data["targetPace"];
            this.actualPace = _data["actualPace"];
            this.recommendedDuration = _data["recommendedDuration"];
            this.actualDuration = _data["actualDuration"];
            this.recommendedRest = _data["recommendedRest"];
            this.actualRest = _data["actualRest"];
            this.intervalType = _data["intervalType"];
            this.distanceUnit = _data["distanceUnit"];
            this.actualRPE = _data["actualRPE"];
        }
    }

    static fromJS(data: any): UpdateDTSetEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDTSetEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryID"] = this.setEntryID;
        data["movementID"] = this.movementID;
        data["recommendedDistance"] = this.recommendedDistance;
        data["actualDistance"] = this.actualDistance;
        data["intervalDuration"] = this.intervalDuration;
        data["targetPace"] = this.targetPace;
        data["actualPace"] = this.actualPace;
        data["recommendedDuration"] = this.recommendedDuration;
        data["actualDuration"] = this.actualDuration;
        data["recommendedRest"] = this.recommendedRest;
        data["actualRest"] = this.actualRest;
        data["intervalType"] = this.intervalType;
        data["distanceUnit"] = this.distanceUnit;
        data["actualRPE"] = this.actualRPE;
        return data;
    }
}

export interface IUpdateDTSetEntryRequest {
    setEntryID?: string;
    movementID?: string;
    recommendedDistance?: number;
    actualDistance?: number;
    intervalDuration?: string;
    targetPace?: string;
    actualPace?: string;
    recommendedDuration?: string;
    actualDuration?: string;
    recommendedRest?: string;
    actualRest?: string;
    intervalType?: IntervalType;
    distanceUnit?: DistanceUnit;
    actualRPE?: number;
}

export class UpdateInjuryEventRequest implements IUpdateInjuryEventRequest {
    trainingSessionID?: string | undefined;
    injuryEventID!: string;
    painLevel!: number;
    injuryType!: InjuryEventType;
    notes!: string;

    constructor(data?: IUpdateInjuryEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            this.injuryEventID = _data["injuryEventID"];
            this.painLevel = _data["painLevel"];
            this.injuryType = _data["injuryType"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): UpdateInjuryEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInjuryEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        data["injuryEventID"] = this.injuryEventID;
        data["painLevel"] = this.painLevel;
        data["injuryType"] = this.injuryType;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IUpdateInjuryEventRequest {
    trainingSessionID?: string | undefined;
    injuryEventID: string;
    painLevel: number;
    injuryType: InjuryEventType;
    notes: string;
}

export class UpdateInjuryRequest implements IUpdateInjuryRequest {
    injuryID!: string;
    name!: string;
    notes!: string;
    isActive!: boolean;

    constructor(data?: IUpdateInjuryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.injuryID = _data["injuryID"];
            this.name = _data["name"];
            this.notes = _data["notes"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateInjuryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInjuryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["injuryID"] = this.injuryID;
        data["name"] = this.name;
        data["notes"] = this.notes;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateInjuryRequest {
    injuryID: string;
    name: string;
    notes: string;
    isActive: boolean;
}

export class UpdateLiftSetEntryRequest implements IUpdateLiftSetEntryRequest {
    setEntryID?: string;
    movementID?: string;
    recommendedReps?: number;
    recommendedWeight?: number;
    recommendedRPE?: number;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit?: WeightUnit;

    constructor(data?: IUpdateLiftSetEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setEntryID = _data["setEntryID"];
            this.movementID = _data["movementID"];
            this.recommendedReps = _data["recommendedReps"];
            this.recommendedWeight = _data["recommendedWeight"];
            this.recommendedRPE = _data["recommendedRPE"];
            this.actualReps = _data["actualReps"];
            this.actualWeight = _data["actualWeight"];
            this.actualRPE = _data["actualRPE"];
            this.weightUnit = _data["weightUnit"];
        }
    }

    static fromJS(data: any): UpdateLiftSetEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLiftSetEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setEntryID"] = this.setEntryID;
        data["movementID"] = this.movementID;
        data["recommendedReps"] = this.recommendedReps;
        data["recommendedWeight"] = this.recommendedWeight;
        data["recommendedRPE"] = this.recommendedRPE;
        data["actualReps"] = this.actualReps;
        data["actualWeight"] = this.actualWeight;
        data["actualRPE"] = this.actualRPE;
        data["weightUnit"] = this.weightUnit;
        return data;
    }
}

export interface IUpdateLiftSetEntryRequest {
    setEntryID?: string;
    movementID?: string;
    recommendedReps?: number;
    recommendedWeight?: number;
    recommendedRPE?: number;
    actualReps?: number;
    actualWeight?: number;
    actualRPE?: number;
    weightUnit?: WeightUnit;
}

export class UpdateMovementRequest implements IUpdateMovementRequest {
    movementID?: string;
    movementBaseID?: string;
    movementModifier?: MovementModifier;
    notes?: string | undefined;
    isCompleted?: boolean;

    constructor(data?: IUpdateMovementRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movementID = _data["movementID"];
            this.movementBaseID = _data["movementBaseID"];
            this.movementModifier = _data["movementModifier"] ? MovementModifier.fromJS(_data["movementModifier"]) : <any>undefined;
            this.notes = _data["notes"];
            this.isCompleted = _data["isCompleted"];
        }
    }

    static fromJS(data: any): UpdateMovementRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMovementRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movementID"] = this.movementID;
        data["movementBaseID"] = this.movementBaseID;
        data["movementModifier"] = this.movementModifier ? this.movementModifier.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        data["isCompleted"] = this.isCompleted;
        return data;
    }
}

export interface IUpdateMovementRequest {
    movementID?: string;
    movementBaseID?: string;
    movementModifier?: MovementModifier;
    notes?: string | undefined;
    isCompleted?: boolean;
}

export class UpdateTrainingProgramRequest implements IUpdateTrainingProgramRequest {
    trainingProgramID?: string;
    title?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    isCompleted?: boolean;
    tags?: string[] | undefined;

    constructor(data?: IUpdateTrainingProgramRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingProgramID = _data["trainingProgramID"];
            this.title = _data["title"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.isCompleted = _data["isCompleted"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateTrainingProgramRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTrainingProgramRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramID"] = this.trainingProgramID;
        data["title"] = this.title;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        data["isCompleted"] = this.isCompleted;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface IUpdateTrainingProgramRequest {
    trainingProgramID?: string;
    title?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    isCompleted?: boolean;
    tags?: string[] | undefined;
}

export class UpdateTrainingSessionRequest implements IUpdateTrainingSessionRequest {
    trainingSessionID?: string;
    trainingProgramID?: string;
    date?: Date;
    status?: TrainingSessionStatus;
    creationTime?: Date;
    notes?: string | undefined;

    constructor(data?: IUpdateTrainingSessionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingSessionID = _data["trainingSessionID"];
            this.trainingProgramID = _data["trainingProgramID"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): UpdateTrainingSessionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTrainingSessionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingSessionID"] = this.trainingSessionID;
        data["trainingProgramID"] = this.trainingProgramID;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["status"] = this.status;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IUpdateTrainingSessionRequest {
    trainingSessionID?: string;
    trainingProgramID?: string;
    date?: Date;
    status?: TrainingSessionStatus;
    creationTime?: Date;
    notes?: string | undefined;
}

export enum WeightUnit {
    _0 = 0,
    _1 = 1,
}

export class WellnessReviewDTO implements IWellnessReviewDTO {
    wellnessScore?: number | undefined;
    energyScore?: number | undefined;
    motivationScore?: number | undefined;
    moodScore?: number | undefined;
    stressScore?: number | undefined;
    resilienceStress?: number | undefined;
    activityScore?: number | undefined;
    wellnessSummary?: string | undefined;
    positiveFactors?: string[] | undefined;
    stressFactors?: string[] | undefined;

    constructor(data?: IWellnessReviewDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wellnessScore = _data["wellnessScore"];
            this.energyScore = _data["energyScore"];
            this.motivationScore = _data["motivationScore"];
            this.moodScore = _data["moodScore"];
            this.stressScore = _data["stressScore"];
            this.resilienceStress = _data["resilienceStress"];
            this.activityScore = _data["activityScore"];
            this.wellnessSummary = _data["wellnessSummary"];
            if (Array.isArray(_data["positiveFactors"])) {
                this.positiveFactors = [] as any;
                for (let item of _data["positiveFactors"])
                    this.positiveFactors!.push(item);
            }
            if (Array.isArray(_data["stressFactors"])) {
                this.stressFactors = [] as any;
                for (let item of _data["stressFactors"])
                    this.stressFactors!.push(item);
            }
        }
    }

    static fromJS(data: any): WellnessReviewDTO {
        data = typeof data === 'object' ? data : {};
        let result = new WellnessReviewDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wellnessScore"] = this.wellnessScore;
        data["energyScore"] = this.energyScore;
        data["motivationScore"] = this.motivationScore;
        data["moodScore"] = this.moodScore;
        data["stressScore"] = this.stressScore;
        data["resilienceStress"] = this.resilienceStress;
        data["activityScore"] = this.activityScore;
        data["wellnessSummary"] = this.wellnessSummary;
        if (Array.isArray(this.positiveFactors)) {
            data["positiveFactors"] = [];
            for (let item of this.positiveFactors)
                data["positiveFactors"].push(item);
        }
        if (Array.isArray(this.stressFactors)) {
            data["stressFactors"] = [];
            for (let item of this.stressFactors)
                data["stressFactors"].push(item);
        }
        return data;
    }
}

export interface IWellnessReviewDTO {
    wellnessScore?: number | undefined;
    energyScore?: number | undefined;
    motivationScore?: number | undefined;
    moodScore?: number | undefined;
    stressScore?: number | undefined;
    resilienceStress?: number | undefined;
    activityScore?: number | undefined;
    wellnessSummary?: string | undefined;
    positiveFactors?: string[] | undefined;
    stressFactors?: string[] | undefined;
}

export class WellnessState implements IWellnessState {
    stateID?: string;
    userID?: string;
    date?: Date;
    motivationScore?: number;
    stressScore?: number;
    moodScore?: number;
    energyScore?: number;
    overallScore?: number;

    constructor(data?: IWellnessState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stateID = _data["stateID"];
            this.userID = _data["userID"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.motivationScore = _data["motivationScore"];
            this.stressScore = _data["stressScore"];
            this.moodScore = _data["moodScore"];
            this.energyScore = _data["energyScore"];
            this.overallScore = _data["overallScore"];
        }
    }

    static fromJS(data: any): WellnessState {
        data = typeof data === 'object' ? data : {};
        let result = new WellnessState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stateID"] = this.stateID;
        data["userID"] = this.userID;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["motivationScore"] = this.motivationScore;
        data["stressScore"] = this.stressScore;
        data["moodScore"] = this.moodScore;
        data["energyScore"] = this.energyScore;
        data["overallScore"] = this.overallScore;
        return data;
    }
}

export interface IWellnessState {
    stateID?: string;
    userID?: string;
    date?: Date;
    motivationScore?: number;
    stressScore?: number;
    moodScore?: number;
    energyScore?: number;
    overallScore?: number;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}